[{"title":"Oracle学习笔记1","url":"/2018/12/23/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","content":"<p><em>Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。</em></p>\n<ul>\n<li><a href=\"#a\">01基础</a></li>\n<li><a href=\"#b\">02多表查询、子查询</a></li>\n</ul>\n<hr>\n<p><span id=\"a\"></span></p>\n<h2 id=\"基础部分\"><a href=\"#基础部分\" class=\"headerlink\" title=\"基础部分\"></a>基础部分</h2><p>Oracle中distinct可以消除重复的行，如果指定多个列名，则要保证多列的数据皆重复才会消除。</p>\n<pre><code>select distinct name,sal from emp\n</code></pre><hr>\n<p>Oracle中有独特的字符串连接符’<strong>||</strong>‘，相当于java里的’+’,MYSQL里可以用concat连接字符串。</p>\n<pre><code>select &apos;姓名是:&apos; || NAME || &apos;的年龄为&apos; || AGE from emp;\n\nselect concat(NAME,&apos;是姓名&apos;，AGE，&apos;是年龄&apos;    ) from emp;\n</code></pre><hr>\n<p>查询列取别名时，若别名中有特殊字符或者关键字需要加上双引号。(其他地方大部分使用单引号）</p>\n<pre><code>select name &quot;my name&quot; from emp;\n</code></pre><hr>\n<p>LIKE关键字使用时，若匹配的字符里有特殊字符，需要使用escape关键字<br>如，要查询员工姓名里有’%’字符的员工信息。</p>\n<pre><code>select * from emp where name like &apos;%\\%%&apos; escape &apos;\\&apos;;\n</code></pre><p>其中第一和最后一个%号都表示任意字符，而escape声明’\\‘为转义字符，所以第二个%表示字符’%’。<br>也可以这样写:</p>\n<pre><code>select * from emp where name like &apos;%#%%&apos; escape &apos;#&apos;;\n</code></pre><p>所以我猜想在oracle里反斜杠并不代表转义字符的意思吧。。</p>\n<hr>\n<p>在排序的时候，如果有空值，需要在末尾加上null的说明</p>\n<pre><code>select * from emp order by number desc nulls last;\n</code></pre><p>表示null值放在末尾，还有nulls first.</p>\n<hr>\n<p>oracle里有一个伪表用来做返回字符或者数值，叫做<strong>dual</strong>，在MYSQL中不用加from dual；</p>\n<p>同样的，oracle里也有很多一样的函数</p>\n<h2 id=\"单行函数\"><a href=\"#单行函数\" class=\"headerlink\" title=\"单行函数\"></a>单行函数</h2><ul>\n<li><p>concat():    字符串连接</p>\n<pre><code>select concat(&apos;hello&apos;,&apos;world&apos;) from dual;\n</code></pre></li>\n<li>substr():字符串的截取substr(str,0,3)表示从索引位置0（<strong>0和1效果相同</strong>）开始截取str，截取3个字符的长度。</li>\n<li>length()：获取字符串长度    </li>\n<li>replace()：replace(str,’a’,’b’)表示把str里所有的a替换成b</li>\n<li>round()：四舍五入round(num,2)，2表示保留2位小数0</li>\n<li>ceil()：进1取整</li>\n<li>trunc()：截断trunc(num,2)去掉小数点后2位的尾数</li>\n<li>MOD()：求余MOD(NUM1,NUM2)</li>\n<li>MONTHS_BETWEEN()：获得两个时间段中的月数，months_between(sysdate,finishdate)——<strong>sysdate</strong>表示系统时间</li>\n<li>ADD_MONTHS()：获取几个月后的日期，add_months(sysdate,3)系统时间3个月后。</li>\n<li>TO_CHAR：字符串转换函数</li>\n<li>TO_NUMBER：数值转换函数</li>\n<li>TO_DATE：日期转换函数<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fygwfj010wj30h407sjt2.jpg\" alt=\"\"><br>如：<br>TO_CHAR(date,’yyyy-mm-dd’)<br>TO_CHAR(date,’yyyy’)等<br>把月和日前面的0去掉要在后面的model前加上fm<br>TO_CHAR(date,’fmyyyy-mm-dd’)<br>TO_CHAR(sysdate,’d’)一个d代表一个星期的第几天，两个d代表一个月的第几天，三个d代表一年中的第几天<br>TO_CHAR(sysdate,’day’)星期几–返回monday什么的，如果是dy，则返回简写–mon之类的</li>\n</ul>\n<p>也就是这三种类型的相互转换函数<br>TO_CHAR(sal,’L9,999.99’),可以格式化货币，L表示本地货币</p>\n<ul>\n<li>NVL()：空值处理，如果为空值就取后面的值为默认值，nvl(name,’Peter’)</li>\n<li>NVL2()：nvl2(参数1，参数2，参数3)，如果参数1为空值，就返回参数3，否则返回参数2</li>\n<li>nullif()：nullif(参数1，参数2)如果参数1等于参数2，那么就返回null，否则返回参数1</li>\n<li>coalesce()：这个函数传入很多参数，然后返回第一个不为null的值</li>\n</ul>\n<hr>\n<p>条件表达式：在SQL语句中使用IF-THEN-ELSE</p>\n<p><strong>CASE</strong>表达式：SQL99的语法，类似Basic，比较繁琐</p>\n<pre><code>select\n    case name\n        when &apos;Peter&apos; then &apos;P&apos;\n        when &apos;Bob&apos; then &apos;B&apos;\n        else \n            &apos;C&apos;\n        end\nfrom emp;\n</code></pre><p>就是当name等于when里的值就改为then后面的值，这种写法通用于MYSQL和Oracle</p>\n<p><strong>DECODE</strong>函数：Oracle自己的语法，类似java，比较简洁</p>\n<pre><code>select decode(name,&apos;Peter&apos;,&apos;P&apos;,&apos;Bob&apos;,&apos;B&apos;,&apos;C&apos;) from emp;\n</code></pre><p>效果和上面一样</p>\n<hr>\n<h2 id=\"多行函数\"><a href=\"#多行函数\" class=\"headerlink\" title=\"多行函数\"></a>多行函数</h2><ul>\n<li>max()：某列最大值</li>\n<li>min()：某列最小值</li>\n<li>count()：统计行数</li>\n<li>avg()：平均数，注意空值影响</li>\n<li>sum()：求和<br>多行函数常与分组关键字Group by配合使用，另外having关键字在group by后执行，where后不能接多行函数。<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fygz2iqixhj30kg02yjtb.jpg\" alt=\"\"></li>\n</ul>\n<p>就是说只能这样写</p>\n<pre><code>select 列名a，分组函数 from 表 group by 这个列名a having 条件\n</code></pre><hr>\n<p><span id=\"b\"></span></p>\n<h2 id=\"多表查询、子查询\"><a href=\"#多表查询、子查询\" class=\"headerlink\" title=\"多表查询、子查询\"></a>多表查询、子查询</h2><h2 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h2><p>内外连接我在前面sql写过了，就写一些oracle不同的地方</p>\n<p>全外连接为俩表都完全匹配。不加where条件即为外连接</p>\n<p>内连接，加where条件</p>\n<p>左（外）连接<br>显示左边表的全部，匹配右边的表<br>select e.empno,e.ename,m.empno,m.ename from emp e,emp m where e.mgr=m.empno(+)<br>在右边加+号表示用该表匹配左表，故为左连接。</p>\n<p>右连接反之。</p>\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>也就是在一个大的主查询里先做一个小的子查询供主查询使用。</p>\n<p>例</p>\n<pre><code>select name,job,sal from emp \nwhere sal=(select min(sal) from emp)\n</code></pre><p>子查询返回结果类型要和比较类型相同。</p>\n<p>多行子查询<br>若子查询返回多行结果，应与多行比较符匹配：in、&gt;any….</p>\n<p>子查询返回空值可能会报错，这个时候需要使用<strong>exists()</strong>，括号里加入子查询语句，若查询结果为空，返回false</p>\n<pre><code>select * from emp where exists(select * from dept where deptno=1)\n</code></pre><p><strong>Rownum</strong><br>当要查询第几行到第几行的数据时，我们使用rownum。</p>\n<p>rownum是oracle预处理字段，默认标序是1，只有记录集已经满足条件后才会进行后续编号。这样你查询表时遍历第一条数据时rownum是1，不符合条件，继续遍历到第二条数据rownum仍为1，仍不符合条件，直至遍历完所有数据，都无数据返回。</p>\n<p>查询第二行之后的数据</p>\n<pre><code>select * from(select rownum no ,id,name from student) where no&gt;2;\n</code></pre><p>rownum不能直接使用判断&gt;的条件。<br>另外，rownum是按照插入顺序排列的，所以要按某列排序需要使用子查询</p>\n<pre><code>select rownum ,id,name from (select * from student order by name)\n</code></pre><p>查询第n行到m行的数据</p>\n<pre><code>(select empno,ename from emp where rownum&lt;m)\n\nminus\n\n(select empno,ename from emp where rownum&lt;n)\n</code></pre><hr>\n<h2 id=\"集合运算\"><a href=\"#集合运算\" class=\"headerlink\" title=\"集合运算\"></a>集合运算</h2><p>就是俩条语句的结果集的运算<br>有</p>\n<ul>\n<li>UNION并集</li>\n<li>intersect交集</li>\n<li>minus差集</li>\n</ul>\n<p>特征：<br>两边查询的字段数量、字段类型、顺序必须一致。</p>\n","categories":["数据库"],"tags":["oracle"]},{"title":"Oracle学习笔记2","url":"/2018/12/25/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","content":"<h2 id=\"DDL（database-define-language）数据库定义语言\"><a href=\"#DDL（database-define-language）数据库定义语言\" class=\"headerlink\" title=\"DDL（database define language）数据库定义语言\"></a>DDL（database define language）数据库定义语言</h2><p>创建表：create table tablename（….）</p>\n<p>修改表：alter table tablename add（columnname type …）;<br>alter table tablename modify …</p>\n<p>删除表：drop table tablename</p>\n<hr>\n<h2 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h2><ul>\n<li>主键Primary key</li>\n<li>非空约束NOT NULL</li>\n<li>唯一约束Unique</li>\n<li>外键约束foreign key</li>\n<li>检查性约束check（加在列后写上对列条件）</li>\n</ul>\n<hr>\n<h2 id=\"DML（database-manager-language）数据库操作语言\"><a href=\"#DML（database-manager-language）数据库操作语言\" class=\"headerlink\" title=\"DML（database manager language）数据库操作语言\"></a>DML（database manager language）数据库操作语言</h2><p>INSERT INTO TABLENAME() VALUES()</p>\n<p>UPDATE TABLENAME SET COLUMN=VALUE… WHERE 条件</p>\n<p>DELETE FROM TABLENAME WHERE 条件</p>\n<hr>\n<h2 id=\"视图view\"><a href=\"#视图view\" class=\"headerlink\" title=\"视图view\"></a>视图view</h2><p>简化复杂的查询，查询部分数据作为一个视图<br>create view view_name as (查询语句)<br>create or replace view view_name as ….</p>\n<hr>\n<h2 id=\"序列SEQUENCE\"><a href=\"#序列SEQUENCE\" class=\"headerlink\" title=\"序列SEQUENCE\"></a>序列SEQUENCE</h2><p>若想和mysql等数据库一样实现某列自动增长的功能，可以利用序列</p>\n<p>其中有两个变量：<br>nextval：取得序列的下一个内容<br>currval：取得序列的当前内容<br>先创建序列：<br>CREATE SEQUENCE SEQUENCENAME<br>                                     INCREMENT BY 10<br>                                    START WITH 120<br>                                    MAXVALUE 9999<br>                                    NOCACHE<br>                                    NOCYCLE;</p>\n<p>自增这样写：insert into tablename values(列名.nextval….)</p>\n<h2 id=\"索引index\"><a href=\"#索引index\" class=\"headerlink\" title=\"索引index\"></a>索引index</h2><p>单列索引：<br>create index indexname on tablename(columnname)</p>\n<p>复合索引<br>create index indexname on tablename(…)</p>\n<p>当数据量较大的时候，索引能加快查询速度。</p>\n<h2 id=\"同义词SYNONYM\"><a href=\"#同义词SYNONYM\" class=\"headerlink\" title=\"同义词SYNONYM\"></a>同义词SYNONYM</h2><p>CREATE PUBLIC SYNONYM synonymname for othertable.emp</p>\n<hr>\n<h1 id=\"PL-SQL\"><a href=\"#PL-SQL\" class=\"headerlink\" title=\"PL/SQL\"></a>PL/SQL</h1><p>declare<br>这里写一些说明（变量定义什么的。。。）<br>begin<br>代码部分，语句序列，DML<br>exception<br>例外语句，类似异常处理<br>End;</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvio5aq1j30ev09dt9p.jpg\" alt=\"\"></p>\n<p><strong>选择</strong><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvj6bwbgj309u0ant9h.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvji4pvvj30e4064q3j.jpg\" alt=\"\"><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvjw7525j30hy07tmyb.jpg\" alt=\"\"></p>\n<p><strong>循环</strong><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvk97rujj30bt0frwg5.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"游标cursor\"><a href=\"#游标cursor\" class=\"headerlink\" title=\"游标cursor\"></a>游标cursor</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjvr2tozmj30gd05edhp.jpg\" alt=\"\"><br>使用</p>\n<p>例：</p>\n<pre><code>declare    //声明部分\n    cursor cl is  //声明游标\n        select * from emp;  //游标指向\n    pemp emp%rowtype;    //声明变量，类型为emp表\nbegin  \n    open cl;    //打开游标\n        loop    \n            fetch cl    //取一行游标的值\n                into pemp;    //放入pemp变量中\n            exit when cl%notfound;    //当游标为空的时候跳出循环\n            dbms_output.put_line(pemp.empno || &apos; &apos; || pemp.ename);    //打印变量所指行的信息\n        end loop\n    close cl    //关闭游标\nend; \n</code></pre><p>也可以指定游标的类型为特定的某一行<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjw17a91wj30f801imxv.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"例外exception\"><a href=\"#例外exception\" class=\"headerlink\" title=\"例外exception\"></a>例外exception</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjw41x9ltj30a103s3yz.jpg\" alt=\"\"></p>\n<p>类似与java，也可以自己手动抛出异常。</p>\n<p>自定义异常需要在declare中定义，然后使用时可以加入条件控制中，如果不正确可以抛出（raise）一个异常，然后进入exception块中</p>\n<pre><code>exception\n     when   自定义异常名   then\n         处理语句\n</code></pre><hr>\n<h2 id=\"存储过程procedure\"><a href=\"#存储过程procedure\" class=\"headerlink\" title=\"存储过程procedure\"></a>存储过程procedure</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjwafrjz7j30de08gaav.jpg\" alt=\"\"><br>在AS或者IS后可以加变量定义。<br>调用<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjwifmffyj309f04hmxo.jpg\" alt=\"\"></p>\n<h2 id=\"存储函数function\"><a href=\"#存储函数function\" class=\"headerlink\" title=\"存储函数function\"></a>存储函数function</h2><p>存储函数和存储过程一般来说没有什么区别，返回结果的数量可以通过参数里的<strong>out</strong>指定</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjwpj3k0kj30gp04iwf7.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjwu2zddoj30b1013aa1.jpg\" alt=\"\"></p>\n<pre><code>create or replace function  empincome (eno in emp.empno%type) return number is  //声明存储过程\n    psal emp.sal%type;  //定义薪水变量\n    pcomm emp.comm%type;  //定义奖金变量\nbegin\n    select t.sal,t.pcomm into psal,pcomm from emp t where t.empno=eno;\n    return psal*12+nvl(pcomm,0);\nend\n</code></pre><p>用存储过程实现<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjx0o7by5j30i60bvadt.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"java调用存储过程\"><a href=\"#java调用存储过程\" class=\"headerlink\" title=\"java调用存储过程\"></a>java调用存储过程</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjx2q44rzj30ga0bk415.jpg\" alt=\"\"></p>\n<p>若使用游标<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjx6rz4flj30g305rq4e.jpg\" alt=\"\"><br>只需要将游标提取，然后用ResultSet类型转换即可查询游标所指内容</p>\n<p>另外，写在过程中out语句后的用来返回结果集的游标类型应该为sys_refcursor，具体可以查看</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/liuqiyun/p/6796740.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/liuqiyun/p/6796740.html</a></p>\n</blockquote>\n<hr>\n<h2 id=\"触发器TRIGGER\"><a href=\"#触发器TRIGGER\" class=\"headerlink\" title=\"触发器TRIGGER\"></a>触发器TRIGGER</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjxr3dooij309p06674r.jpg\" alt=\"\"></p>\n<p>触发器自带变量<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjxsqbtsuj30hx047t9o.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyjxyacxucj30fv0dkju9.jpg\" alt=\"\"></p>\n<p>另外一般不允许多个触发器对同一张表进行操作或者在触发器中对同一张表进行操作，容易产生递归循环触发。</p>\n","categories":["数据库"],"tags":["oracle"]},{"title":"SQL一些基本语句使用","url":"/2018/11/29/SQL%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8/","content":"<p>选出不重复的列<br>SELECT DISTINCT COLUMN FROM TABLE<br>用某列来进行排序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN<br>逆序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN DESC<br>选出开始几行<br>SELECT TOP NUMBER|PERCENT * FROM TABLE<br>MYSQL中用LIMIT关键字</p>\n<hr>\n<p>like关键字<br>Where column like ‘pattern’<br>_表示一位<br>%表示任何多位<br>[]表示方括号里的某一单一字符<br>[^]反向</p>\n<hr>\n<p>范围条件IN<br>Where column in （VALUES…）<br>BETWEEN…AND..<br>a&lt;x&lt;b</p>\n<hr>\n<p>内连接、左外连接、右外连接、全连接<br>Inner JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN</p>\n<hr>\n<p>创建索引</p>\n<p><strong>CREATE INDEX 语句用于在表中创建索引。</strong></p>\n<p><strong>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</strong></p>\n<p>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引</p>\n<p>CREATE INDEX index_name<br>ON table_name (column_name)</p>\n<p>删除索引–MYSQL<br>ALTER TABLE table_name DROP INDEX index_name</p>\n<p>删除表、数据库<br>DROP TABLE 表名称<br>DROP DATABASE 数据库名称</p>\n<hr>\n<p>创建视图</p>\n<p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>\n<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p>\n<p>注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响<br><a href=\"http://www.w3school.com.cn/sql/sql_view.asp\" target=\"_blank\" rel=\"noopener\">CLICK</a></p>\n<hr>\n<p>关键字ALTER用于修改表以及行<br>ALTER TABLE table_name<br>ALTER COLUMN column_name datatype</p>\n<hr>\n<p>SQL函数<br>平均AVG()<br>例：希望找到 OrderPrice 值高于 OrderPrice 平均值的客户<br>SELECT Customer FROM Orders<br>WHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders)</p>\n<p>计数COUNT()<br>SELECT COUNT(column_name) FROM table_name//括号里可加DISTINCT关键字</p>\n<p>第一、最后一条记录<br>FIRST()、LAST()</p>\n<p>最大值、最小值<br>MAX()、MIN()</p>\n<p>计和<br>SUM()</p>\n<p>按列分项算总和<br>例SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer</p>\n<p>计和增加条件用关键字HAVING</p>\n<p>转大小写<br>UCASE()、LCASE()</p>\n<p>MID() 函数<br>MID 函数用于从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name<br>例SELECT MID(City,1,3) as SmallCity FROM Persons</p>\n<p>LEN()<br>LEN 函数返回文本字段中值的长度。</p>\n<p>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name</p>\n<p>NOW()<br>NOW 函数返回当前的日期和时间</p>\n<p>FORMAT 函数用于对字段的显示进行格式化。<br>SELECT FORMAT(column_name,format) FROM table_name</p>\n","categories":["数据库"],"tags":["sql"]},{"title":"dubboDemo搭建例子","url":"/2019/01/21/dubboDemo%E6%90%AD%E5%BB%BA%E4%BE%8B%E5%AD%90/","content":"<p>创建一个工作空间DubboDemo<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdxu1zgm4j309b05qjre.jpg\" alt=\"\"></p>\n<p>在项目下新建module</p>\n<h2 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h2><p>新建service接口并编写实现类<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdxw3w8j3j30j7078wes.jpg\" alt=\"\"></p>\n<p>将service提取到另一module中</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdxxcld7jj30bi09bmxg.jpg\" alt=\"\"></p>\n<p>新建服务消费者module</p>\n<p>和提供者类似将service接口提取到主module中</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdxzsttuaj30v80by405.jpg\" alt=\"\"></p>\n<hr>\n<p>可以看到消费者里需要用到提供者的Service</p>\n<p>其他的domain和service需要引入主module 的依赖</p>\n<pre><code>&lt;dependency&gt;  \n &lt;groupId&gt;xff&lt;/groupId&gt;  \n &lt;artifactId&gt;themainservice&lt;/artifactId&gt;  \n &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  \n&lt;/dependency&gt;\n</code></pre><p>这个时候在服务提供者里添加依赖和配置文件</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  \n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  \n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  \n &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  \n\n &lt;groupId&gt;xff&lt;/groupId&gt;  \n &lt;artifactId&gt;user-service-provider&lt;/artifactId&gt;  \n &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  \n &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;  \n &lt;artifactId&gt;lombok&lt;/artifactId&gt;  \n &lt;version&gt;1.16.18&lt;/version&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xff&lt;/groupId&gt;  \n &lt;artifactId&gt;themainservice&lt;/artifactId&gt;  \n &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  \n &lt;artifactId&gt;dubbo&lt;/artifactId&gt;  \n &lt;version&gt;2.6.5&lt;/version&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;  \n &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;  \n &lt;version&gt;2.12.0&lt;/version&gt;  \n &lt;/dependency&gt; &lt;/dependencies&gt;  \n\n&lt;/project&gt;\n</code></pre><p>provider.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  \n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;  \n  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;  \n\n &lt;dubbo:application name=&quot;userserviceprovider&quot;&gt;&lt;/dubbo:application&gt;  \n\n &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;  \n\n &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt;  \n\n &lt;dubbo:service interface=&quot;service.UserService&quot; ref=&quot;userServiceImpl&quot;&gt;&lt;/dubbo:service&gt;  \n\n &lt;bean id=&quot;userServiceImpl&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;  \n&lt;/beans&gt;\n</code></pre><p>这样就能将服务暴露给其他服务使用</p>\n<p>再写一个类运行</p>\n<pre><code>public static void main(String[] args) throws IOException {  \n    ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);  \n  ioc.start();  \n\n  System.in.read();  \n}\n</code></pre><hr>\n<p>类似的，在服务消费者里</p>\n<p>依赖一样</p>\n<p>consumer.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  \n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;  \n  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  \n  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;  \n\n &lt;context:component-scan base-package=&quot;service.impl&quot;&gt;&lt;/context:component-scan&gt;  \n\n &lt;dubbo:application name=&quot;orderserviceconsumer&quot;&gt;&lt;/dubbo:application&gt;  \n\n &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;  \n\n &lt;dubbo:reference interface=&quot;service.UserService&quot; id=&quot;userService&quot;&gt;&lt;/dubbo:reference&gt;  \n\n\n\n&lt;/beans&gt;\n</code></pre><p>写一个类测试</p>\n<pre><code>public static void main(String[] args) throws IOException {  \n    ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);  \n\n  OrderService one= ioc.getBean(OrderService.class);  \n  Order order=new Order();  \n  order.setPrice(123);  \n  System.out.println(one.findPrice(order));  \n  System.in.read();  \n}\n</code></pre><hr>\n<p>运行</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdyp5y2xzj30i505bmxq.jpg\" alt=\"\"></p>\n<p>这个时候打开上篇的OPS控制台可以看到服务提供者，打开在下面可以看到服务消费者正在使用</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzdyq0wp4zj30t50czdg9.jpg\" alt=\"\"></p>\n<hr>\n","categories":["分布式"],"tags":["dubbo","demo"]},{"title":"Mybatis传参方法","url":"/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/","content":"<p><em>Mybatis在xml文件中使用接口类传来的参数一般设置parameterType类型，然后在对应的接口方法中传入相应类型的参数，即可在xml语句中使用上面的参数</em></p>\n<p>然而我今天在使用中遇到了不使用parameterType的方式，记录一下</p>\n<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><p>一般来说，我们传多个参数可以使用parameterType，自定义一个pojo类，然后把想传入的多个参数放入该类中，parameterType指定该类，即可通过该类调用其中包含的多个参数。</p>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>若是不想多定义pojo类</p>\n<p>那么可以定义参赛为一个Map类型，如何取其中的参数呢？</p>\n<p>在xml文件中可以不用写parameterType类型，然后想使用时使用#{key}，key填入你map里的键值，即可取到对应的值</p>\n<blockquote>\n<p>参考 <a href=\"https://blog.csdn.net/u014268482/article/details/80622216\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u014268482/article/details/80622216</a></p>\n</blockquote>\n<h2 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h2><p>不用传Map，直接传入多个参数，在调用时直接#{0},#{1}….</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyxtywczrkj30hm0620tf.jpg\" alt=\"\"></p>\n<h2 id=\"方法4\"><a href=\"#方法4\" class=\"headerlink\" title=\"方法4\"></a>方法4</h2><p>基于注解</p>\n<p>在接口方法中传入Map类型参数，并在参数前加上@<strong>param</strong>(“<strong>myparam</strong>“)注解，然后在xml中调用参数时</p>\n<ul>\n<li>${myparam.key}，参数默认为字符串</li>\n<li>#{myparam.key}，参数可以为多种类型</li>\n</ul>\n<blockquote>\n<p>参考 <a href=\"https://blog.csdn.net/earthhour/article/details/79635633\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/earthhour/article/details/79635633</a></p>\n</blockquote>\n<hr>\n","categories":["mybatis"],"tags":["传参"]},{"title":"The Messenger通关","url":"/2019/01/02/The-Messenger%E9%80%9A%E5%85%B3/","content":"<p>元旦通关了一款2018年出的解密复古风小游戏，感觉还蛮有意思的。<br>《The Messenger》中译叫信使。</p>\n<p>游戏中会记录死亡数。</p>\n<p>有只恶魔在旁边负责复活你，复活之后会把你吃的碎片（类似金币）给吞掉。并且，每死一次都要嘲讽你，特别烦人啊hhh</p>\n<p>然后，后期来了一个叫堕落的未来的地方，遇到一直巨大的怪，bgm全变了，感觉有点恐怖。这个时候你死了，恶魔也不说话了，直接默默把你复活，感觉设计的还是很有意思。</p>\n<p>就是下面这个东西。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fyrzpn1xzvj311y0lcqau.jpg\" alt=\"\"></p>\n<p>就在我截图出来后回去，发现居然出bug了，大怪兽不知道为什么不追我了， 然后</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fys07btpkhj311y0lcwmj.jpg\" alt=\"\"></p>\n<p>调戏一下</p>\n<p>要不是这个bug，我可能又要多死几十次</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fys08upvhqj311y0lcgr7.jpg\" alt=\"\"></p>\n<p>八音盒解锁</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fys09oh8gyj311y0lctdj.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fys0a79ckmj311y0lcdks.jpg\" alt=\"\"></p>\n<p>场景设计的很有意思</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fys0atb7ovj311y0lcnau.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fys0b5vij7j311y0lc0z7.jpg\" alt=\"\"></p>\n<p>死了400+次总算是通关了。</p>\n<p>最难拿的一个封印</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fys0c3502xj311y0lcdh6.jpg\" alt=\"\"></p>\n<p>辛辛苦苦拿了四十几个封印，居然只是解锁一个回旋镖，这个做的太伤人心了叭！</p>\n<hr>\n<hr>\n<p>通关还是蛮有成就感的233</p>\n","categories":["杂记"],"tags":["杂记，游戏"]},{"title":"fish学习","url":"/2019/01/03/fish%E5%AD%A6%E4%B9%A0/","content":"<p>fish，前端框架。<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fyticwu43jj30jc0aot9e.jpg\" alt=\"\"></p>\n<hr>\n<p>安装命令<br>$ npm i -g @ngweb/fish-cli –registry <a href=\"http://registry.npm.ztesoft.com\" target=\"_blank\" rel=\"noopener\">http://registry.npm.ztesoft.com</a></p>\n<h3 id=\"fish-new或n-lt-project-name-gt\"><a href=\"#fish-new或n-lt-project-name-gt\" class=\"headerlink\" title=\"fish new或n &lt;project-name&gt;\"></a><code>fish new或n &lt;project-name&gt;</code></h3><p>创建项目</p>\n<h3 id=\"fish-config或c\"><a href=\"#fish-config或c\" class=\"headerlink\" title=\"fish config或c\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-config%E6%88%96c\" target=\"_blank\" rel=\"noopener\"></a><code>fish config或c</code></h3><p>在当前目录下，创建fish.config.js文件</p>\n<h3 id=\"fish-serve或s-p-port-port-w-watch\"><a href=\"#fish-serve或s-p-port-port-w-watch\" class=\"headerlink\" title=\"fish serve或s [-p port/--port] [-w / --watch]\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-serve%E6%88%96s-p-port-port-w-watch\" target=\"_blank\" rel=\"noopener\"></a><code>fish serve或s [-p port/--port] [-w / --watch]</code></h3><p>启动服务，-p/–port设置启动端口号，-w/–watch设置是否热部署(实时编译，自动刷新)，一般适用于fish-cli初始化的项目(标准目录)，同时生成sourcemaps。</p>\n<h3 id=\"fish-generate-module-lt-module-name-gt\"><a href=\"#fish-generate-module-lt-module-name-gt\" class=\"headerlink\" title=\"fish generate module &lt;module-name&gt;\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-generate-module-module-name\" target=\"_blank\" rel=\"noopener\"></a><code>fish generate module &lt;module-name&gt;</code></h3><p>创建模块，支持缩写  <code>fish g module &lt;module-name&gt;</code>，这里的  <code>module-name</code>  可以是相对路径</p>\n<h3 id=\"fish-generate-view-lt-file-name-gt\"><a href=\"#fish-generate-view-lt-file-name-gt\" class=\"headerlink\" title=\"fish generate view &lt;file-name&gt;\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-generate-view-file-name\" target=\"_blank\" rel=\"noopener\"></a><code>fish generate view &lt;file-name&gt;</code></h3><p>在当前目录下创建文件/文件夹，支持缩写  <code>fish g view &lt;file-name&gt;</code>，这里的  <code>file-name</code>  可以是相对路径</p>\n<h3 id=\"fish-update-version\"><a href=\"#fish-update-version\" class=\"headerlink\" title=\"fish update [version]\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-update-version\" target=\"_blank\" rel=\"noopener\"></a><code>fish update [version]</code></h3><p>更新目录fish-desktop版本。命令会自动找到目录下第一个fish-desktop所在目录，进行覆盖更新。可指定版本号，不指定则更新至最新版本</p>\n<h3 id=\"fish-addon-lt-addon-name-gt\"><a href=\"#fish-addon-lt-addon-name-gt\" class=\"headerlink\" title=\"fish addon &lt;addon-name&gt;\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-addon-addon-name\" target=\"_blank\" rel=\"noopener\"></a><code>fish addon &lt;addon-name&gt;</code></h3><p>添加  <code>fish-desktop</code>  提供的第三方组件</p>\n<h2 id=\"eslint检测\"><a href=\"#eslint检测\" class=\"headerlink\" title=\"eslint检测\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#eslint%E6%A3%80%E6%B5%8B-1\" target=\"_blank\" rel=\"noopener\"></a>eslint检测</h2><p>读取项目根目录下.eslintrc文件，运行eslint，检测js规范</p>\n<h3 id=\"fish-build\"><a href=\"#fish-build\" class=\"headerlink\" title=\"fish build\"></a><a href=\"http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-build\" target=\"_blank\" rel=\"noopener\"></a><code>fish build</code></h3><p>编译、压缩、autoprefix样式文件，输出到styles文件夹里，并将fontAweSome字体拷贝至styles，可在fish.config.js里配置编译文件和编译方式</p>\n<hr>\n<p>fish new myapp<br>新建一个fish项目<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fytiid3xs3j30g6077q3g.jpg\" alt=\"\"></p>\n<p>项目结构为<br>fish serve -w<br>编译运行，进入localhost:8088<br>即可见到fish项目原始页面</p>\n<hr>\n<p>index.html为入口</p>\n<pre><code>&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;\n    &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;\n    &lt;title&gt;myapp&lt;/title&gt;\n    &lt;link href=&quot;image/favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;frm/fish-desktop/css/fish-desktop-default.css&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/css/myapp-proj-all.css&quot;&gt;\n    &lt;!--[if lt IE 9]&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/libs/bootstrap/respond.js&quot;&gt;&lt;/script&gt;\n    &lt;![endif]--&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/js/fish-desktop-all.js&quot;&gt;&lt;/script&gt;\n    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/js/fish-desktop-require.js&quot; data-main=&quot;main&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>加载到data-main时会读取main.js文件，在main.js中</p>\n<pre><code>fish.View.configure({manage: true});\n\nrequire([&apos;modules/main/views/IndexView&apos;], function(IndexView){\n\n    new IndexView().render();\n})\n</code></pre><p>加载IndexView.js文件</p>\n<p>在modules模块目录下<br>按照路径找到IndexView.js文件</p>\n<pre><code>define([\n    &apos;hbs!modules/main/templates/IndexView.html&apos;,\n    &apos;i18n!modules/main/i18n/IndexView.i18n&apos;\n],function(tpl, i18n) {\n    var me = null;\n\n    return fish.View.extend({\n        el:&apos;body&apos;,\n        template: tpl,\n        i18nData: fish.extend({}, i18n), // i18nData: fish.extend({}, i18n, commonI18n),\n        //提供模板数据\n        serialize: function () {\n            return this.i18nData;\n        },\n        //视图事件定义\n        events:{},\n        //一些初始化设置 (不能进行dom操作)\n        initialize: function() {\n            me = this;\n        },\n        //视图渲染完毕处理函数\n        afterRender: function() {\n        },\n        // 视图被删除时候做的事情\n        cleanup: function () {\n            me = null;\n        }        \n    });\n\n\n\n});\n</code></pre><p>指向templates/IndexView.html</p>\n<p>找到IndexView.html</p>\n<pre><code>&lt;p&gt;Welcome to fish...&lt;/p&gt;\n</code></pre><hr>\n","categories":["前端"],"tags":["fish"]},{"title":"linux&shell学习","url":"/2018/12/27/linux-shell%E5%AD%A6%E4%B9%A0/","content":"<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyl1m3hagrj321c10w1ca.jpg\" alt=\"\"></p>\n<hr>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mmoq4jj32cg168nld.jpg\" alt=\"\"></p>\n<hr>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mw2ld7j321c10wwyg.jpg\" alt=\"\"></p>\n<p>….</p>\n","categories":["linux"],"tags":["linux","shell"]},{"title":"Hello World","url":"/2018/08/03/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"dubboOPS控制台安装使用","url":"/2019/01/18/dubboOPS%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"zooKeeper注册中心\"><a href=\"#zooKeeper注册中心\" class=\"headerlink\" title=\"zooKeeper注册中心\"></a>zooKeeper注册中心</h2><p>先从该网站下载</p>\n<blockquote>\n<p><a href=\"https://www.apache.org/dyn/closer.cgi/zookeeper/\" target=\"_blank\" rel=\"noopener\">https://www.apache.org/dyn/closer.cgi/zookeeper/</a><br>（这里我下的3.4.12稳定版本）</p>\n</blockquote>\n<p>解压到自选目录下</p>\n<p>打开bin目录</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzaj2epa5dj30gy05s74u.jpg\" alt=\"\"></p>\n<p>zkServer是我们要运行的zookeeper服务，在地址栏输入cmd可以快速进入当前目录的命令行，但是这个时候运行会报错，我们需要改一下配置文件</p>\n<p>打开conf目录</p>\n<p>将zoo_sample.cfg复制粘贴一份重命名为zoo.cfg</p>\n<p>用文本编辑器打开zoo.cfg文件</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzaj70159jj308v055wen.jpg\" alt=\"\"></p>\n<p>上面标记的那列是产生的数据存放位置，原目录结构为linux文件结构，这里我在windows上使用，于是在上一级目录新建了一个data文件夹，并修改目录</p>\n<p>下面的是端口号，无特殊要求使用默认的2181</p>\n<hr>\n<p>这个时候去运行zkServer，可以看到成功运行<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzajahm3xpj30o406twf0.jpg\" alt=\"\"></p>\n<p>先放在后台</p>\n<hr>\n<p>然后可以去运行zkCli客户端，可以查看zookeeper相关的状态，get / 查看根结点下有什么值<br>使用ls /查看根结点下有什么结点<br>这个时候一般会有个zooKeeper结点<br>我们可以通过create -e /你的结点名 结点值<br>创建新结点<br>（关于zooKeeper我不太熟）</p>\n<hr>\n<h2 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h2><p>接下来我们进入Dubbo官网</p>\n<blockquote>\n<p><a href=\"http://dubbo.apache.org/en-us/\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/en-us/</a><br>在这能找到很多介绍指南</p>\n</blockquote>\n<p>进入github库，往下在README里</p>\n<p>Dubbo eco system<br>下面最后一项</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-dubbo-ops\" target=\"_blank\" rel=\"noopener\">Dubbo OPS</a>  - The reference implementation for Dubbo admin<br>就是我们要找的了。<br>打开是另一个代码库，下载到本地</li>\n</ul>\n<p>下面可以选择中文的README，可以根据这里的介绍一步一步安装运行。</p>\n<hr>\n<p>我们把下载下来的压缩包解压<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzajmdtoelj30fv07ojrz.jpg\" alt=\"\"></p>\n<p>如图，backend是springBoot项目，frontend是vue.js项目，整体采用了前后端分离的方式。</p>\n<p>前端页面8081<br>后端端口是8080<br>我们先运行后端项目，用IDEA打开backend项目，等待依赖导入下载完成，可以直接运行，也可以将项目用maven打包</p>\n<p>然后在项目目录的target下面可以看到一个jar文件</p>\n<p>可以直接在该目录下的命令行运行</p>\n<pre><code>java -jar 加上jar包名\n</code></pre><p>可以看到项目成功运行在8080端口，我们可以访问 <a href=\"http://localhost:8080/swagger-ui.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api</p>\n<p>后端项目运行完成，现在去运行前端</p>\n<p>打开frontend目录，运行</p>\n<pre><code>npm run dev\n</code></pre><p>报错了，经过搜索，按下面博客的解决方式</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/laraLee/p/9174383.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/laraLee/p/9174383.html</a></p>\n</blockquote>\n<p>运行一下npm install再npm run dev成功</p>\n<p>打开localhost:8081，就可以看到我们需要的OPS页面了<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzajwwuqqej311y0hojsn.jpg\" alt=\"\"></p>\n<p>记住需要zookeeper和后端项目在后台运行，否则前端只是个界面，没有实际效果…</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzajyax34sj30hf09g0td.jpg\" alt=\"\"><br>如上是后端没有在运行时无法从8080端口获取数据的报错。</p>\n<hr>\n","categories":["分布式"],"tags":["dubbo"]},{"title":"vuejs总体结构学习","url":"/2019/01/29/vuejs%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/","content":"<p>偶然翻到一篇讲解一个vue项目的搭建的博客。全部撸完后觉得写的很好，决定在这里总结一下，原博地址</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/fungleo/article/details/77606321\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/fungleo/article/details/77606321</a></p>\n</blockquote>\n<hr>\n<p>首先，看一下大体的项目结构</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzniy1h619j30fo0ix42b.jpg\" alt=\"\"></p>\n<p>贴代码<br>main.js</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznj3i8xvgj30o70eu0uh.jpg\" alt=\"\"></p>\n<p>红框框起来的是必要代码，引入Vue和App模版、vue路由。然后引入全局的路由配置文件routes.js<br>使用路由需要Vue.use(VueRouter)</p>\n<hr>\n<p>看一下App.vue<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznj87c7lmj30hq08a0t3.jpg\" alt=\"\"><br>很简单，在模版里加入了路由的标签router-view</p>\n<hr>\n<p>接下来是路由配置文件routes.js<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznj9o2ircj30gw0fet9w.jpg\" alt=\"\"></p>\n<p>也就是把要配置的路径对应的vue文件导入，一一配置。<br>path为’/‘时为默认路径，即当页面路径/后有问题的时候默认也导入到该页面</p>\n<p>配置第二个content路径的时候，<strong>：id</strong>表示动态映射路径，当/content匹配成功的时候就会进入content.vue文件对应的页面，该页面中可以通过<span>this.$routes.params.id</span>获取该id值</p>\n<p>第三个是将/user/xxx匹配成功时将子页面渲染到Frame里的router-view标签里<br>subroute的代码为<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznjqeoykyj30ei04bmx6.jpg\" alt=\"\"><br>比如这个时候我请求/user/love时就会映射到userLove对应的页面上，如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznjs4mre3j30q706f0t4.jpg\" alt=\"\"></p>\n<hr>\n<p>组件定义<br>当一个页面的某部分在页面变化保持不变的时候，我们就可以把该部分写在component文件夹下，定义组件，并在其他页面使用</p>\n<p>比如，我们定义一个页面的头部和尾部<br>header.vue<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznjx4yo7kj30f704gjrm.jpg\" alt=\"\"></p>\n<p>尾部<br>footer.vue<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznjy0p9u1j30dg03lgll.jpg\" alt=\"\"></p>\n<p>然后在使用时导入</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznjzqucmgj30ql0cjmz1.jpg\" alt=\"\"></p>\n<p>这样就可以把组件渲染到页面上</p>\n<hr>\n<p>引用静态文件时,src定义为static/xxx即可</p>\n<hr>\n<p>具体项目代码我传到了github上，地址</p>\n<blockquote>\n<p><a href=\"https://github.com/HolyDogs/VueStructDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/HolyDogs/VueStructDemo</a></p>\n</blockquote>\n","categories":["前端"],"tags":["vue","js"]},{"title":"mybatis plus自动生成代码","url":"/2019/01/10/mybatis-plus%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/","content":"<p>mybatis plus的核心功能之一就是能自动生成代码。</p>\n<p>类似mybatis的逆向工程，但是mybatis plus能生成mapper、service、controller、serviceImpl等，而且封装好了基本的CRUD功能，在xml中找不到对应的sql语句。</p>\n<hr>\n<p>创建一个test类<br>如下</p>\n<pre><code>package com.atguigu.mp.test;  \n\nimport javax.swing.text.DefaultStyledDocument.AttributeUndoableEdit;  \n\nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n\nimport com.baomidou.mybatisplus.enums.IdType;  \nimport com.baomidou.mybatisplus.generator.AutoGenerator;  \nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;  \nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;  \nimport com.baomidou.mybatisplus.generator.config.PackageConfig;  \nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;  \nimport com.baomidou.mybatisplus.generator.config.rules.DbType;  \nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;  \n\npublic class TestMP {  \n\n\n   /**  \n * 代码生成    示例代码 */  @Test  \n  public void testGenerator() {  \n      //1. 全局配置  \n  GlobalConfig config = new GlobalConfig();  \n  config.setActiveRecord(true) // 是否支持AR模式  \n  .setAuthor(&quot;weiyunhui&quot;) // 作者  \n/*         .setOutputDir(&quot;D:\\\\workspace_mp\\\\mp03\\\\src\\\\main\\\\java&quot;) // 生成路径*/  \n  .setOutputDir(&quot;E:\\\\study\\\\代码\\\\jjjj\\\\代码\\\\mp03\\\\src\\\\main\\\\java&quot;)  \n           .setFileOverride(true)  // 文件覆盖  \n  .setIdType(IdType.AUTO) // 主键策略  \n  .setServiceName(&quot;%sService&quot;)  // 设置生成的service接口的名字的首字母是否为I  \n // IEmployeeService  .setBaseResultMap(true)  \n           .setBaseColumnList(true);  \n  //2. 数据源配置  \n  DataSourceConfig  dsConfig  = new DataSourceConfig();  \n  dsConfig.setDbType(DbType.MYSQL)  // 设置数据库类型  \n  .setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;)  \n            .setUrl(&quot;jdbc:mysql://localhost:3306/mpdemo?useSSL=false&amp;&amp;serverTimezone=GMT&quot;)  \n            .setUsername(&quot;root&quot;)  \n            .setPassword(&quot;olonn&quot;);  \n  //3. 策略配置  \n  StrategyConfig stConfig = new StrategyConfig();  \n  stConfig.setCapitalMode(true) //全局大写命名  \n  .setDbColumnUnderline(true)  // 指定表名 字段名是否使用下划线  \n  .setNaming(NamingStrategy.underline_to_camel) // 数据库表映射到实体的命名策略  \n  .setInclude(&quot;user&quot;)       ;  \n  /*.setTablePrefix(&quot;tbl_&quot;)  \n .setInclude(&quot;tbl_employee&quot;);  // 生成的表*/       //4. 包名策略配置   \n PackageConfig pkConfig = new PackageConfig();  \n  pkConfig.setParent(&quot;com.atguigu.mp&quot;)  \n            .setMapper(&quot;mapper&quot;)  \n            .setService(&quot;service&quot;)  \n            .setController(&quot;controller&quot;)  \n            .setEntity(&quot;beans&quot;)  \n            .setXml(&quot;mapper&quot;);  \n  //5. 整合配置  \n  AutoGenerator  ag = new AutoGenerator();  \n  ag.setGlobalConfig(config)  \n        .setDataSource(dsConfig)  \n        .setStrategy(stConfig)  \n        .setPackageInfo(pkConfig);  \n  //6. 执行  \n  ag.execute();  \n  }  \n\n\n\n}\n</code></pre><p>添加相关的依赖</p>\n<p>这里我的数据库使用的mysql8.0，用的mysql-connector-java5.1.37报错，我改成了mysql-connector-java8.0.11，结果还是出错，提示SSL什么的，于是在url后加上了useSSL=false，然后又提示时区的错误，又在后面加上了serverTimezone=GMT，终于能运行成功了。</p>\n<p>解决方法参考:</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_37630354/article/details/82814330\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_37630354/article/details/82814330</a><br><a href=\"https://blog.csdn.net/u010429286/article/details/7775017\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010429286/article/details/7775017</a></p>\n</blockquote>\n<p>后记，我又遇到了新的连接问题，本来好好的，结果这次登陆又不能连接数据库了，网上查了一遍，在url后面加上了allowPublicKeyRetrieval=true得到解决<br>参考:</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/Yuriey/article/details/80423504\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Yuriey/article/details/80423504</a></p>\n</blockquote>\n<hr>\n<p>运行成功会将对应库里的表生成各类文件，对应结构是这样的</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz1l344lyfj30920dmaab.jpg\" alt=\"\"></p>\n<hr>\n<p>生成的mapper和service都包含基本的CRUD功能，另外，生成的service接口使用时，由于在impl实现类上使用了注解，所以实际@Autowired注解的service是一个实现类。</p>\n<hr>\n<p>大部分细节都写在代码里的注释中——</p>\n","categories":["mybatis"],"tags":["mybatis_plus"]},{"title":"mybatis操作text等长文本类型","url":"/2018/10/24/mybatis%E6%93%8D%E4%BD%9Ctext%E7%AD%89%E9%95%BF%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B/","content":"<hr>\n<p>在实现将图片以base64编码为字符串存入数据库时，我遇到了这个问题。<br>由于字符串过长，创建表时我用text类型来存放图片对应的base64编码字符串。</p>\n<hr>\n<p><strong>最初，我以为是事务配置有问题，导致对表数据修改没有提交，在我试了各种配置方法。</strong></p>\n<pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;\n            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;\n            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;\n            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;\n            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\n            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\n            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\n        &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n\n&lt;aop:config&gt;\n    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.me.service.*.*(..))&quot;/&gt;\n&lt;/aop:config&gt;\n</code></pre><p>注解扫描配置：</p>\n<pre><code>&lt;bean id=&quot;transactionManager&quot;  \nclass=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  \n&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  \n&lt;/bean&gt;  \n&lt;!--使用注释事务 --&gt;  \n&lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; /&gt;\n</code></pre><hr>\n<p>检验无误后我又认为是字符串不够长，把数据库的text类型改为mediumtext类型</p>\n<pre><code>ALTER TABLE tableName modify column columnName 类型\n</code></pre><p>发现还是没用，问题依然不出在这。</p>\n<p>网上说现在不推荐使用text类型，建议改为varchar(MAX)类型，于是我又尝试，发现mysql里没有该类型。</p>\n<hr>\n<h2 id=\"最终\"><a href=\"#最终\" class=\"headerlink\" title=\"最终\"></a>最终</h2><p>最后终于发现，mybatis对于text这些大文本类型，有特殊的操作方法接口。在逆向工程生成的方法里，有一些方法后面带有WithBloBs字样，这些就是针对这些类型的方法。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwjdmuerbcj309x00ma9u.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwjdnupkygj30bw00rjr6.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwjdon8yb8j30jk00sdfo.jpg\" alt=\"\"></p>\n<p>使用这些方法后，终于成功。</p>\n<p>其中xml中的实现如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwjdpyqowxj30gf033t8s.jpg\" alt=\"\"></p>\n<hr>\n","categories":["mybatis"],"tags":["mybatis","图片","数据库"]},{"title":"Tomcat控制台窗口中文乱码","url":"/2019/02/21/Tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","content":"<p>绕了很大一个圈子<br>今天终于解决了这个问题<br>特地用一篇博客记录</p>\n<p>按网上说的改注册表、改编码格式、加参数运行都试过，全都没有用，我又是个强迫症，看不得乱码</p>\n<p>今天对conf目录下的logging.properties文件查看后，觉得是里面的格式UTF-8和系统的936GB2312冲突问题，于是<strong>ctrl+h把所有的UTF-8全部替换为GBK</strong></p>\n<p>完美解决</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0e2ckpgkhj30zg0dj0uw.jpg\" alt=\"\"></p>\n","categories":["tomcat"],"tags":["乱码"]},{"title":"vue从入门到放弃","url":"/2019/01/17/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/","content":"<h2 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h2><p>将对应的html标签转为html页面形式而不是字符串</p>\n<h2 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h2><p>加载完script里的脚本才会加载被该属性标记的元素</p>\n<h2 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h2><p>等同于</p>\n<pre><code>{{}}\n</code></pre><p>卧槽，这里生成的时候一直报错，原来不能直接用两个花括号写在博客里，害我找了好久的错误    </p>\n<h2 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h2><p>告诉属性名指定的是一个变量   v-bind:text=”变量名”，可以简写为：，里面可以写表达式</p>\n<h2 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h2><p>事件绑定  v-on：事件名，简写为@</p>\n<h2 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h2><p>数据的双向绑定，v-bind是单向绑定。</p>\n<h2 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h2><p>循环</p>\n<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h2><p>通过一个flag变量控制是否移除创建元素，切换消耗较高</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h2><p>和v-if类似，但是v-show只是设置对应控件不可见，较高的初始渲染消耗</p>\n<hr>\n<h2 id=\"绑定class样式设置\"><a href=\"#绑定class样式设置\" class=\"headerlink\" title=\"绑定class样式设置\"></a>绑定class样式设置</h2><p>如下<br>使用：class=”[flag?’onestyle’:’’]”或者{‘onstyle’:flag}<br>可以定义一个flag标志，当为true时为标签添加class为onestyle的class属性。</p>\n<p>也可以在对象上添加：style=’{color：’red’ , …}’或者写入data，引用变量</p>\n<h2 id=\"setInterval（）\"><a href=\"#setInterval（）\" class=\"headerlink\" title=\"setInterval（）\"></a>setInterval（）</h2><p>定时器</p>\n<hr>\n<p>使用</p>\n<p>Vue.directive()</p>\n<p>自定义指令</p>\n<p>配合钩子函数使用</p>\n<hr>\n<p>好好看了下官方文档，写的很详细，但是点实在太多了，我肯定记不住，只能使用时再查了。。。</p>\n<p>官网</p>\n<blockquote>\n<p><a href=\"https://cn.vuejs.org/v2/guide/index.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/index.html</a></p>\n</blockquote>\n<p>顺便贴个js学习文档</p>\n<blockquote>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000</a></p>\n</blockquote>\n<p>最后贴个路由使用学习</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/SamWeb/p/6610733.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/SamWeb/p/6610733.html</a></p>\n</blockquote>\n<hr>\n<p>枯了~</p>\n","categories":["前端"],"tags":["vue"]},{"title":"win10使用hexo搭建blog","url":"/2018/09/10/win10%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/","content":"<h2 id=\"练习搭建ing…\"><a href=\"#练习搭建ing…\" class=\"headerlink\" title=\"练习搭建ing…..\"></a>练习搭建ing…..</h2><p><strong>从下列各个站点<del>边看边搭</del>…</strong></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/Hoshea_chx/article/details/78826689\" target=\"_blank\" rel=\"noopener\">[用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！]</a></li>\n<li><p><a href=\"http://blog.sunnyxx.com/2014/02/27/hexo_startup/\" target=\"_blank\" rel=\"noopener\">[hexo边搭边记]</a></p>\n<p>最後根目録下面的_config.yml文件里的deploy的type一定要設置為git~~~<br>這個問題是真磨人。。。</p>\n</li>\n</ul>\n<hr>\n<p> 模版TKL来源…</p>\n<ul>\n<li><p><a href=\"https://github.com/SuperKieran/TKL\" target=\"_blank\" rel=\"noopener\">[TKL]</a></p>\n</li>\n<li><p><a href=\"https://github.com/SuperKieran/hexo-generator-search-zip\" target=\"_blank\" rel=\"noopener\">[hexo搜索工具]</a></p>\n</li>\n</ul>\n<hr>\n<p><strong>模版很好看，感谢作者~</strong></p>\n<p><del>其实这篇文章只是为了试试能不能同步到github主页hhh</del></p>\n","categories":["hexo主题"],"tags":["hexo"]},{"title":"vue入门安装","url":"/2019/01/15/vue%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85/","content":"<p><em>入职前以为，我们写后端的，也许整天面对的就是后台的service、controller等层去开发，入职后上级和我们说后台大部分代码都可以自动生成，前端的js需要好好学习一下…</em>  </p>\n<p><em>我晕了，前端根本没怎么重视，JavaScript也没有系统地学习，现在想了想，要不好好学一个前端的框架吧。从各个网站上了解到一些信息和趋势，决定学习时下比较热门的前端框架vue.js</em>  </p>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>安装…<br>先安装个nodejs，官网下载即可（因为之前用hexo搭建博客的时候安装过了，这里就不写步骤了）  </p>\n<p>为了减少对C盘的使用，把nodejs安装在其他盘之后，还需要更改设置，不然还是会把一些文件和缓存放在C盘<br> npm config set prefix “xxx”<br>    npm config set cache “xxx”  </p>\n<p>新建两个文件夹,路径填入xxx即可  </p>\n<p>安装vue-cli<br> npm install -g vue-cli</p>\n<p>如果无法识别vue，可能是npm版本太低，运行<br> npm install -g npm </p>\n<p>完事运行<br> vue -V   </p>\n<p>出现版本号表示成功。  </p>\n<hr>\n<h2 id=\"生成项目\"><a href=\"#生成项目\" class=\"headerlink\" title=\"生成项目\"></a>生成项目</h2><p>命令行找个目录运行<br> vue init webpack yourproject</p>\n<p>yourproject是项目名，webpack是vue模版，除了webpack还有其他几个模版  </p>\n<p>这个时候会从github上下载对应的模版文件（这里也可以输入自己的自定义模版导入），途中会有很多选项，网上都建议有个ESLint选no，因为不会用…<br>其他一路回车和输入Y，最后结束命令行会显示如何开始自己的项目，以前的版本还需要install一下依赖，现在好像不需要  </p>\n<p>反正新版本只需要cd 进入项目目录，然后<br> npm run dev </p>\n<p>即可，在对应的页面能看到项目初始默认的页面。端口号打包目录什么的可以在config目录里修改。  </p>\n<p>打包命令<br> npm run build </p>\n<p>运行会生成一个dist文件夹，实际使用时只需要把该文件夹放到服务器即可。  </p>\n<hr>\n<p>目录结构大概是这样<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz9byntaasj304e0cnt8l.jpg\" alt=\"\"><br>开发目录为src<br>assets放静态文件<br>components放模版<br>router是vue路由<br>main.js是程序入口<br>….  </p>\n<hr>\n","categories":["前端"],"tags":["vue"]},{"title":"vue学习01","url":"/2019/01/17/vue%E5%AD%A6%E4%B9%A001/","content":"<hr>\n<p><del>这个时候我还没学路由…</del></p>\n<p>直接上使用的代码部分</p>\n<p>main.js</p>\n<pre><code>// The Vue build version to load with the `import` command\n// (runtime-only or standalone) has been set in webpack.base.conf with an alias.\nimport Vue from &apos;vue&apos;\nimport App from &apos;./App&apos;\n/*import router from &apos;./router&apos;*/\n\nVue.config.productionTip = false\n\nVue.filter(&apos;myreverse&apos;,function(value){\n    return value.split(&apos;&apos;).reverse().join(&apos;&apos;);\n})\n/* eslint-disable no-new */\nnew Vue({\n  el: &apos;#app&apos;,\n/*  router,*/\n  components: { App },\n  template: &apos;&lt;App/&gt;&apos;\n})\n</code></pre><p>由于没使用router被我注释了，<br>filter是过滤器，这里是全局定义方法，后面会介绍，其他都是模版的代码。</p>\n<hr>\n<p>App.vue</p>\n<pre><code>&lt;template&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;img src=&quot;./assets/logo.png&quot;&gt;\n    &lt;br/&gt;\n    &lt;hi&gt;&lt;/hi&gt;\n    &lt;mytest&gt;&lt;/mytest&gt;\n    &lt;pop&gt;&lt;/pop&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport hi from &apos;./components/hi&apos;\nimport mytest from &apos;./components/mytest&apos;\nimport pop from &apos;./components/pop&apos;\n\nexport default {\n  name: &apos;App&apos;,\n  components:{hi,mytest,pop}\n}\n&lt;/script&gt;\n\n&lt;style&gt;\n#app {\n  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n&lt;/style&gt;\n</code></pre><p>在template模版里根节点只运行存在一个div，那三个奇怪名字的是我自定义的三个页面（块）</p>\n<hr>\n<h2 id=\"hi-vue\"><a href=\"#hi-vue\" class=\"headerlink\" title=\"hi.vue\"></a>hi.vue</h2><pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;input v-model=&quot;message&quot; placeholder=&quot;input message&quot; /&gt;\n    &lt;input v-model=&quot;checked&quot; type=&quot;checkbox&quot; id=&quot;checkbox1&quot; value=&quot;checkbox11&quot;&gt;11&lt;/input&gt;\n    &lt;input v-model=&quot;checked&quot; type=&quot;checkbox&quot; id=&quot;checkbox2&quot; value=&quot;checkbox22&quot;&gt;22&lt;/input&gt;\n    &lt;br/&gt;\n    &lt;select v-model=&quot;selected&quot;&gt;\n      &lt;option disable value=&quot;&quot;&gt;请选择&lt;/option&gt;\n      &lt;option&gt;AA&lt;/option&gt;\n      &lt;option&gt;BB&lt;/option&gt;\n      &lt;option&gt;CC&lt;/option&gt;\n    &lt;/select&gt;\n    &lt;br/&gt;\n    &lt;select v-model=&quot;selected1&quot; style=&quot;width: 50px;&quot;&gt;\n      &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt;\n      {{option.text}}\n      &lt;/option&gt;\n    &lt;/select&gt;\n    &lt;br/&gt;\n    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;a&quot; /&gt;&lt;label&gt;a&lt;/label&gt;\n    &lt;br/&gt;\n    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;b&quot; /&gt;&lt;label&gt;b&lt;/label&gt;\n    &lt;br/&gt;\n    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;c&quot; /&gt;&lt;label&gt;c&lt;/label&gt;\n    &lt;br/&gt;\n    &lt;br/&gt;\n    &lt;br/&gt;\n    &lt;br/&gt;\n    &lt;span&gt;Message is:{{message}}&lt;/span&gt;\n    &lt;br/&gt;\n    &lt;span&gt;Message is:{{checked}}&lt;/span&gt;\n    &lt;br/&gt;\n    &lt;span&gt;select is : {{selected}}&lt;/span&gt;\n    &lt;br/&gt;\n    &lt;span&gt;select is : {{selected1}}&lt;/span&gt;\n    &lt;br/&gt;\n    &lt;span&gt;radio is : {{pick}}&lt;/span&gt;\n    &lt;br/&gt;\n    &lt;span&gt;reverse is :{{message|myreverse}}&lt;/span&gt;\n        &lt;br/&gt;\n    &lt;span&gt;up is :{{message|capitalize}}&lt;/span&gt;\n        &lt;br/&gt;\n    &lt;span&gt;myfilter3 is :{{message|myfilter('haha')}}&lt;/span&gt;\n\n\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &apos;hi&apos;,\n  data () {\n    return {\n      message: &apos;&apos;,\n      checked: [],\n      selected:&apos;&apos;,\n      options:[\n      {text:&quot;AA&quot;,value:&apos;A&apos;},\n      {text:&quot;BB&quot;,value:&apos;B&apos;},\n      {text:&quot;CC&quot;,value:&apos;C&apos;}\n      ],\n      selected1:&apos;&apos;,\n      pick:&apos;&apos;\n    }\n  },\n  filters:{\n  myfilter:function(value,value1){\n    return value.charAt(0).toLocaleUpperCase()+value.slice(1)+value1;\n  }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>实际效果<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz9bzb5mq9j30iu09zt8n.jpg\" alt=\"\"><br>这里注意在使用键值对时，value值才是选中的值，text值是选择框里的值。v-for可以对这种数组进行遍历…还有一些对字符串操作的方法等等…</p>\n<hr>\n<h2 id=\"mytest-vue\"><a href=\"#mytest-vue\" class=\"headerlink\" title=\"mytest.vue\"></a>mytest.vue</h2><pre><code>&lt;template&gt;\n&lt;div&gt;\n  &lt;div&gt;\n    &lt;h1&gt;There is mytest part----&lt;/h1&gt;\n    &lt;button v-on:click=&quot;count=count+1&quot;&gt;addit&lt;/button&gt;\n    &lt;span&gt;{{count}}&lt;/span&gt;\n    &lt;button v-on:click=&quot;sayhaha&quot;&gt;SAYhaha&lt;/button&gt;\n    &lt;button v-on:click=&quot;sayxixi&quot;&gt;SAYxixi&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;br/&gt;\n\n    &lt;div id=&quot;demo&quot; @click=&quot;commonAlert&quot;&gt;\n        &lt;button @click.stop=&quot;alertA&quot;&gt;内部标签&lt;/button&gt;\n    &lt;br&gt;\n    &lt;span&gt;哈哈哈&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;br/&gt;\n    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;preventWebJump&quot;&gt;百度一下&lt;/a&gt;\n    &lt;br/&gt;\n    &lt;div @click.capture=&quot;aa&quot;&gt;\n      &lt;div @click.capture=&quot;bb&quot;&gt;\n        &lt;Button @click.capture=&quot;cc&quot;&gt;冒泡&lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &apos;mytest&apos;,\n  data () {\n    return {\n      count:1\n    }\n  },\n  methods:{\n    sayhaha:function(){\n      alert(&quot;hahaha&quot;)\n    },\n    sayxixi:function(){\n      alert(&quot;xixixi&quot;)\n    },\n    commonAlert:function(){\n      alert(&quot;outclick!&quot;)\n    },\n    alertA:function(){\n      alert(&quot;innerClick!&quot;)\n    },\n    preventWebJump:function(){\n      alert(&quot;禁止跳转&quot;)\n    },\n    cc:function(){\n      alert(&quot;cc&quot;)\n    },\n    bb:function(){\n      alert(&quot;bb&quot;)\n    },\n    aa:function(){\n      alert(&quot;aa&quot;)\n    }\n  }\n}\n&lt;/script&gt;\n&lt;!--.once.passive.self--&gt;\n</code></pre><p>实际效果</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz9c09m6gej30gy06ajrb.jpg\" alt=\"\"><br>这里主要对事件处理方法进行了一些测试，还包括一些事件修饰符，实际效果用图片表现不出事件特性。<br>这里还有.once（指定事件只触发一次）.passive（和prevent相反，允许标签自带的事件）.self（冒泡事件时，不直接与该控件交互的事件会被跳过，不同于.stop是冒泡到该事件时停止）</p>\n<hr>\n<h2 id=\"pop-vue\"><a href=\"#pop-vue\" class=\"headerlink\" title=\"pop.vue\"></a>pop.vue</h2><pre><code>&lt;template&gt;\n  &lt;div id=&quot;demo&quot;&gt;\n  &lt;button v-on:click=&quot;greet =!greet&quot;&gt;点击&lt;/button&gt;\n  &lt;transition name=&quot;fade&quot;&gt;\n    &lt;p v-show=&quot;greet&quot;&gt;hello world jack!&lt;/p&gt;\n  &lt;/transition&gt;\n  &lt;/div&gt;  \n&lt;/template&gt;\n&lt;script&gt;\n  export default{\n    name:&apos;pop&apos;,\n    data(){\n      return{\n        greet:true\n      }\n    }\n  }\n&lt;/script&gt;\n\n&lt;style&gt;\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 0.5s;\n}\n.fade-enter, .fade-leave-to {\n  opacity: 0;\n}\n&lt;/style&gt;\n</code></pre><p>vue定义过渡，transition标签（name=fade）内的控件在消隐时可以通过css定义过渡动画，配合三方css文件，可以达到很有意思的效果。<br>参考</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/hanhailong18/article/details/82222316\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hanhailong18/article/details/82222316</a></p>\n</blockquote>\n<hr>\n<p>还有键盘输入事件绑定…<br>参考</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/hanhailong18/article/details/82584647\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hanhailong18/article/details/82584647</a></p>\n</blockquote>\n<p>很多点没提到，在之后的学习中再补上吧~</p>\n","categories":["前端"],"tags":["vue"]},{"title":"【SpringBoot】定时任务与Cron表达式","url":"/2019/04/12/%E3%80%90SpringBoot%E3%80%91%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%B8%8ECron%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<h1 id=\"SpringBoot定时器\"><a href=\"#SpringBoot定时器\" class=\"headerlink\" title=\"SpringBoot定时器\"></a>SpringBoot定时器</h1><p>SpringBoot自带定时器功能，若不考虑重复启动定时任务以及并发带来的问题，可以选择这种方式来简单快速地定义定时器。</p>\n<p>使用时只需要在声明定时任务的类或者启动类上添加注解@EnableScheduling配合使用在方法上的@Scheduled注解就能简单定义一个定时任务</p>\n<p>在启动类上加@EnableScheduling可以方便对所有任务进行开启和关闭</p>\n<p>在声明定时任务的类上需要加@Component将该类实例化到Spring容器中，才能被扫描到类里的定时任务。</p>\n<p>在方法上添加@Scheduled注解添加参数设置定时策略，有两种设置方式</p>\n<h2 id=\"1-fixedRate\"><a href=\"#1-fixedRate\" class=\"headerlink\" title=\"1.fixedRate\"></a>1.fixedRate</h2><p>这种方式适合不指定特定时间，间歇一段时间就执行一次的情况，功能较弱。</p>\n<h2 id=\"2-cron表达式\"><a href=\"#2-cron表达式\" class=\"headerlink\" title=\"2.cron表达式\"></a>2.cron表达式</h2><p>可以指定什么时候触发、多久触发一次等，功能较强大，需要使用特定的表达式。</p>\n<hr>\n<p><strong>两种方式使用如下：</strong></p>\n<pre><code>@Component\n@Slf4j\npublic class MyScheduledTask {\n\n    @Scheduled(fixedRate = 1000 * 5)\n    public void bootSchedule(){\n        log.info(&quot;SpringBoot自带定时器fixedRate5s启动：{}&quot;,LocalDateTime.now());\n    }\n\n    @Scheduled(cron = &quot;10/10 * * * * ?&quot;)\n    public void bootScheduleCron(){\n        log.info(&quot;SpringBoot自带Cron定时器fixedRate10s启动：{}&quot;, LocalDateTime.now().toString());\n    }\n}\n</code></pre><ul>\n<li>上面的方法表示每5秒该任务会执行一次</li>\n<li>下面的方法则表示任务会从每分钟的第10秒开始，每10秒执行一次</li>\n</ul>\n<p>运行效果如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1zoaoxn1uj30rv07p40a.jpg\" alt=\"\"></p>\n<p><strong>为什么上面的5条中，5秒运行一次的任务连续执行了4次而10秒的任务没有运行呢？</strong><br>原因是，当50秒时，运行10秒后进入到下一分钟的范围，而该任务指定从每分钟的第10秒开始运行，所以这次不会调用该任务。</p>\n<h2 id=\"Cron表达式介绍\"><a href=\"#Cron表达式介绍\" class=\"headerlink\" title=\"Cron表达式介绍\"></a>Cron表达式介绍</h2><p>cron表达式有6或7个域，中间以逗号分隔，理解也比较简单，每个域顺序表示的意义如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1zugibc32j30l504kaa7.jpg\" alt=\"\"></p>\n<ul>\n<li><p><strong>每个符号的含义</strong></p>\n<p> <img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1zuh44kq2j30oi0ev3zj.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<p><strong>注意：每周的第一天是周日</strong></p>\n<hr>\n<p>情景测试，我想让一个任务在2019到2020年每月的第3个周三的晚上6点的第20分开始，每5分钟的第30秒执行一次</p>\n<pre><code>30 20/5 18 ? * 4#3 2019-2020\n</code></pre>","categories":["SpringBoot"],"tags":["cron","定时任务"]},{"title":"【Error集合】","url":"/2018/10/03/%E3%80%90Error%E9%9B%86%E5%90%88%E3%80%91/","content":"<h2 id=\"Struts2\"><a href=\"#Struts2\" class=\"headerlink\" title=\"Struts2\"></a>Struts2</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhaideyou/p/5964509.html\" target=\"_blank\" rel=\"noopener\">Struts2配置问题java.lang.ClassNotFoundException:org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</a></li>\n<li><a href=\"https://blog.csdn.net/li7134600/article/details/78071785\" target=\"_blank\" rel=\"noopener\">动态通配符配置Action出错</a>  </li>\n<li><a href=\"https://blog.csdn.net/T_just_for_tomorrow/article/details/79504049\" target=\"_blank\" rel=\"noopener\">动态调用action</a>  </li>\n<li><a href=\"https://blog.csdn.net/cgy_workman/article/details/40862993\" target=\"_blank\" rel=\"noopener\">关于struts2配置struts.devMode问题解释</a>  </li>\n</ul>\n<hr>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><ul>\n<li><a href=\"https://blog.csdn.net/H_anxx/article/details/78983591\" target=\"_blank\" rel=\"noopener\">org.springframework.web.context.ContextLoaderListener解决方法</a></li>\n</ul>\n<hr>\n<h2 id=\"Hibernate\"><a href=\"#Hibernate\" class=\"headerlink\" title=\"Hibernate\"></a>Hibernate</h2><ul>\n<li><a href=\"https://blog.csdn.net/u010504064/article/details/47832721\" target=\"_blank\" rel=\"noopener\">关于Hibernate一对多关系加载方式fetch配置</a></li>\n</ul>\n<hr>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><ul>\n<li><a href=\"https://zhidao.baidu.com/question/1894863609449400500.html\" target=\"_blank\" rel=\"noopener\">JS中字符串与数字进行算术运算eval使用注意</a></li>\n</ul>\n<hr>\n<h2 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h2><ul>\n<li><a href=\"https://www.cnblogs.com/bsn-huang/p/3933442.html\" target=\"_blank\" rel=\"noopener\">githubSSHkey添加</a></li>\n<li><a href=\"https://www.cnblogs.com/sheldonxu/archive/2012/09/17/2688281.html\" target=\"_blank\" rel=\"noopener\">伴随问题</a></li>\n</ul>\n<hr>\n<p>持续更新…….<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw3j95uqblj31hc0u0b29.jpg\" alt=\"\"></p>\n","categories":["errors"],"tags":["errors"]},{"title":"【SpringBoot】使用mybatis查询返回map时空值不保存key的解决方法","url":"/2019/03/05/%E3%80%90SpringBoot%E3%80%91%E4%BD%BF%E7%94%A8mybatis%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Emap%E6%97%B6%E7%A9%BA%E5%80%BC%E4%B8%8D%E4%BF%9D%E5%AD%98key%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"<p><strong>在使用mybatis对数据库进行查询然后返回一个map类型的时候，如果某一列的值为空</strong></p>\n<p><strong>那么返回的map里是会没有这个值对应的列的key，也就是map的容量会比预期小，很容易出一些问题</strong></p>\n<p><strong>我在前端对传来的map遍历存入table时，由于缺少一些key，导致后面的列往前面推，使表格混乱</strong></p>\n<p>为了解决这个问题，我先是找到了这篇博客,分析了一下mybatis给map类型赋值的过程</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/zdazx/article/details/79289074\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zdazx/article/details/79289074</a></p>\n</blockquote>\n<hr>\n<p>但是它使用的是ssm框架，为了在springboot框架里配置mybatis配置，我新建了一个mybatis-config.xml配置文件，然后再springboot配置文件application.properties里引入</p>\n<p>mybatis-config.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  \n&lt;configuration&gt;  \n &lt;settings&gt; &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;true&quot;/&gt;  \n &lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;true&quot; /&gt;  \n &lt;/settings&gt;&lt;/configuration&gt;\n</code></pre><p>接着配置</p>\n<pre><code>mybatis-plus.mapper-locations=classpath*:/mapper/*.xml  \nmybatis-plus.config-location=classpath:/mybatis-setting.xml\n</code></pre><p>这里由于我使用的是mybatis-plus，前面需要更改为mybatis-plus</p>\n<p>另外，直接配置mybatis.configuration.returnInstanceForEmptyRow.value=true这种是不行的，没有效果</p>\n","categories":["SpringBoot"],"tags":["mybatis","error"]},{"title":"【SpringCloud】springCloud相关博客链接地址学习收集","url":"/2020/07/10/%E3%80%90SpringCloud%E3%80%91springCloud%E7%9B%B8%E5%85%B3%E5%8D%9A%E5%AE%A2%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/","content":"<p>Spring Cloud Finchley; Spring Boot 2.0.3</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81040925\" target=\"_blank\" rel=\"noopener\">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81040946\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81040965\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81040990\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041012\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041028\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041045\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041062\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041078\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041101\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041113\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)(Finchley版本)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/81041125\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)(Finchley版本)</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/83792388\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十四篇: Spring Cloud Gateway初体验</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/84926662\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十五篇: Spring Cloud Gateway 之Predict篇</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/85057268\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十六篇: Spring Cloud Gateway 之filter篇</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/85081162\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十七篇: Spring Cloud Gateway 之限流篇</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/85210153\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十八篇: spring cloud gateway之服务注册与发现</a></li>\n</ul>\n<h3 id=\"D版本\"><a href=\"#D版本\" class=\"headerlink\" title=\"D版本\"></a>D版本</h3><ul>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69696915\" target=\"_blank\" rel=\"noopener\">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69788938\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第二篇: 服务消费者（rest+ribbon）</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69808079\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第三篇: 服务消费者（Feign）</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69934399\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第四篇:断路器（Hystrix）</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69939114\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第五篇: 路由网关(zuul)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70037291\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第六篇: 分布式配置中心(Spring Cloud Config)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70037513\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70148235\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第八篇: 消息总线(Spring Cloud Bus)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70162074\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第九篇: 服务链路追踪(Spring Cloud Sleuth)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70183572\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十篇: 高可用的服务注册中心</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70198649\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十一篇:docker部署spring cloud项目</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70217283\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十二篇: 断路器监控(Hystrix Dashboard)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70233227\" target=\"_blank\" rel=\"noopener\">史上最简单的SpringCloud教程 | 第十三篇: 断路器聚合监控(Hystrix Turbine)</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70245644\" target=\"_blank\" rel=\"noopener\">史上最简单的 SpringCloud 教程 | 第十四篇: 服务注册(consul)</a></li>\n<li>未完。。。</li>\n<li>还有很多篇。。。</li>\n</ul>\n<h3 id=\"Spring-Cloud-Alibaba教程\"><a href=\"#Spring-Cloud-Alibaba教程\" class=\"headerlink\" title=\"Spring Cloud Alibaba教程\"></a>Spring Cloud Alibaba教程</h3><ul>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/90142744\" target=\"_blank\" rel=\"noopener\">Spring Cloud Alibaba教程：使用Nacos作为服务注册发现组件</a></li>\n</ul>\n<h3 id=\"Greenwich版本\"><a href=\"#Greenwich版本\" class=\"headerlink\" title=\"Greenwich版本\"></a>Greenwich版本</h3><ul>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/87273153\" target=\"_blank\" rel=\"noopener\">Spring Cloud Consul 之Greenwich版本全攻略</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/87866560\" target=\"_blank\" rel=\"noopener\">spring cloud config将配置存储在数据库中</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/87075651\" target=\"_blank\" rel=\"noopener\">Spring Cloud Sleuth 之Greenwich版本全攻略</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/86105850\" target=\"_blank\" rel=\"noopener\">Spring Boot Admin 2.1.0 全攻略</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/86634907\" target=\"_blank\" rel=\"noopener\">阿里分布式事务框架GTS开源了！</a></li>\n</ul>\n<h3 id=\"源码篇：\"><a href=\"#源码篇：\" class=\"headerlink\" title=\"源码篇：\"></a>源码篇：</h3><ul>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/73480304\" target=\"_blank\" rel=\"noopener\">深入理解Feign之源码解析</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/73017664\" target=\"_blank\" rel=\"noopener\">深入理解Eureka之源码解析</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/74820899\" target=\"_blank\" rel=\"noopener\">深入理解Ribbon之源码解析</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/75333088\" target=\"_blank\" rel=\"noopener\">深入理解Hystrix之文档翻译</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/76211680\" target=\"_blank\" rel=\"noopener\">深入理解Zuul之源码解析</a></li>\n</ul>\n<h3 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h3><ul>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/76795269\" target=\"_blank\" rel=\"noopener\">Spring Cloud Sleuth超详细实战</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/83999882\" target=\"_blank\" rel=\"noopener\">拜托！面试请不要再问我Spring Cloud底层原理</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/83999947\" target=\"_blank\" rel=\"noopener\">微服务注册中心如何承载大型系统的千万级访问？</a></li>\n<li><a href=\"https://blog.csdn.net/forezp/article/details/83999975\" target=\"_blank\" rel=\"noopener\">每秒上万并发下的Spring Cloud参数优化实战</a></li>\n</ul>\n<h3 id=\"番外篇：\"><a href=\"#番外篇：\" class=\"headerlink\" title=\"番外篇：\"></a>番外篇：</h3><ul>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/69056017\" target=\"_blank\" rel=\"noopener\">如何使用MongoDB+Springboot实现分布式ID?</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/68957681\" target=\"_blank\" rel=\"noopener\">如何在springcloud分布式系统中实现分布式锁？</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/70305336\" target=\"_blank\" rel=\"noopener\">如何用Redlock实现分布式锁</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/76408139\" target=\"_blank\" rel=\"noopener\">如何在IDEA启动多个Spring Boot工程实例</a></li>\n<li><a href=\"http://blog.csdn.net/forezp/article/details/78676036\" target=\"_blank\" rel=\"noopener\">JWT如何在Spring Cloud微服务系统中在服务相互调时传</a></li>\n</ul>\n<h3 id=\"博客：\"><a href=\"#博客：\" class=\"headerlink\" title=\"博客：\"></a>博客：</h3><p><a href=\"https://windmt.com/2018/04/26/spring-cloud-full-reactive-microservices/\" target=\"_blank\" rel=\"noopener\">https://windmt.com/2018/04/26/spring-cloud-full-reactive-microservices/</a></p>\n","categories":["SpringCloud"],"tags":["SpringCloud"]},{"title":"【Error】2020-7-20记录","url":"/2020/01/01/%E3%80%90Error%E3%80%912020-7-20%E8%AE%B0%E5%BD%95/","content":"<p>指定文件输入框可以多选文件：<strong>multiple</strong>属性</p>\n<pre><code>&lt;input type=&quot;file&quot; size=&quot;30&quot; name=&quot;excel&quot; multiple=&quot;multiple&quot; accept=&quot;application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot; onchange=&quot;uploadFile(this)&quot;&gt;\n</code></pre><p>指定可选择的文件类型：<strong>accept</strong>属性</p>\n<ul>\n<li>xls文件：application/vnd.ms-excel</li>\n<li>xlsx文件：application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</li>\n</ul>\n<p>多种类型用逗号隔开</p>\n<hr>\n<p>Vue使用webpack打包后放入服务器（后端代码）的步骤，resources下创建一个<strong>static</strong>文件夹，然后把打包生成的dist里的static和index.html放入这个文件夹</p>\n<p>这个时候重新启动项目访问可能访问不了这个index.html文件，需要maven clean一下，重新编译运行项目后才可以正常访问。</p>\n","categories":["errors"]},{"title":"【ajax】springmvc下使用","url":"/2018/10/25/%E3%80%90ajax%E3%80%91springmvc%E4%B8%8B%E4%BD%BF%E7%94%A8/","content":"<p>在做ssm项目的时候用到ajax的记录…</p>\n<hr>\n<p>post方法：<br>动态获取div的value，隐藏对应的div项</p>\n<pre><code>var str=this.value;\n$.post(&quot;lover/deleteL&quot;,{&quot;id&quot;:str},function(data){\n    alert(data);\n    $(&quot;#div&quot;+str).hide();\n});\n</code></pre><p>data为后台printwriter.write数据</p>\n<hr>\n<p>当用ajax提交form表单的时候<br>直接：</p>\n<pre><code>$(&quot;#btntj&quot;).click(function(){\n    var form=new FormData(document.getElementById(&quot;forml&quot;));\n    $.ajax({\n        url:&quot;lover/addl&quot;,\n        type:&quot;post&quot;,\n         processData:false,\n        contentType:false,\n        data:form,\n        success:function(data){\n            alert(&quot;添加成功&quot;);\n            window.location.reload()\n        },\n        error:function(){\n            alert(&quot;添加失败&quot;);\n        }\n\n    }); \n});\n</code></pre><p>FormData类能自动把表单内的数据封装好，后台用request.getparemeter(“”)就能获得对应的值，可以说是十分方便了。另外，<strong>表单支持file文件上传类型</strong>。</p>\n<p>后台代码（我这个项目暂时用到的提取方法）：</p>\n<pre><code>@RequestMapping(&quot;/addl&quot;)\npublic void addl(@RequestParam(&quot;lname&quot;) String name,@RequestParam(&quot;month&quot;) String month,@RequestParam(&quot;day&quot;) String day,@RequestParam(&quot;year&quot;)String year,HttpServletRequest request,PrintWriter writer) throws ParseException {\n    User user=(User) request.getSession().getAttribute(&quot;user&quot;);\n    Lover lover=new Lover();\n    lover.setUserid(user.getId());\n    lover.setName(name);\n    lover.setBirth(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(year+&quot;-&quot;+month+&quot;-&quot;+day));\n    loverServiece.saveLover(lover);\n    writer.write(name);\n}\n</code></pre><hr>\n<p><strong>另外</strong>，由于表单提交的是request payload，要在springmvc配置文件中添加</p>\n<pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\n   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;\n   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;10240000&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>才能生效。</p>\n<p>可以通过maxUploadSize设置上传文件的总大小上限，maxInMemorySize设置上传时允许写到内存中的最大值（默认为10240字节）</p>\n<hr>\n","categories":["前端"],"tags":["ajax","springmvc"]},{"title":"【IndexedDB】基本使用","url":"/2019/04/09/%E3%80%90IndexedDB%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"<p>本文来源：本人在使用网页的StackEdit时，发现这东西不用网络，不用登陆，也能保存所有写过的文章，那么这些文章存在哪了呢？Cookie？LocalStorage？好像都不适合存太长的数据，然后发现了IndexedDB这个东西，随后对其进行了探索。</p>\n<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法。IndexedDB 为生成 Web Application 提供了丰富的查询能力，使我们的应用在在线和离线时都可以正常工作。</p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><h2 id=\"创建数据库表以及索引\"><a href=\"#创建数据库表以及索引\" class=\"headerlink\" title=\"创建数据库表以及索引\"></a>创建数据库表以及索引</h2><p>不同于关系型数据库，IndexedDB使用键值对的方式存储数据，且支持灵活的数据类型。结构如下图。<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1wgpqw5doj30v60h5426.jpg\" alt=\"\"></p>\n<p>上图为我用来写MarkDown的StackEdit在本地存储的数据库表，可以看到其是采用键值对的方式存储数据的，Key列是Value列里抽取的某一属性的值，#可以用来生成自动增长的主键。</p>\n<p>创建一个简单的数据库表代码内容如下。（可以通过<a href=\"http://www.runoob.com/try/try.php?filename=tryjs_regexp_exec\" target=\"_blank\" rel=\"noopener\">菜鸟在线工具练习使用</a>）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//当该数据库不存在时会自动创建新库，后面的数字代表版本，当版本更新会进入onupgradeneeded对应的方法</span><br><span class=\"line\">var request = window.indexedDB.open(&quot;mydb&quot;,5);</span><br><span class=\"line\">request.onerror = function(event)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;数据库打开报错&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var db;</span><br><span class=\"line\">request.onsuccess = function(event)&#123;</span><br><span class=\"line\">\tdb = event.target.result;</span><br><span class=\"line\">\tconsole.log(&apos;数据库打开成功&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var mydb;</span><br><span class=\"line\">request.onupgradeneeded = function(event)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;数据库更新成功&apos;);</span><br><span class=\"line\">\tmydb = event.target.result;</span><br><span class=\"line\">\t//创建person表，并设置id属性为主键</span><br><span class=\"line\">\tvar objectStore = mydb.createObjectStore(&apos;person&apos;,&#123;keyPath:&apos;id&apos;&#125;);</span><br><span class=\"line\">\t//创建索引</span><br><span class=\"line\">\tobjectStore.createIndex(&apos;name&apos;, &apos;name&apos;, &#123; unique: false &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>创建结果<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1wgxcw8cpj30uu0acq3s.jpg\" alt=\"\"></p>\n<p>（数据是我后来插入的）</p>\n<hr>\n<h2 id=\"数据基本操作\"><a href=\"#数据基本操作\" class=\"headerlink\" title=\"数据基本操作\"></a>数据基本操作</h2><p>我们可以把每次对数据库的操作看成是一个请求，然后通过该请求的onsuccess和onerror属性判断操作结果以及进行其他运算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">//连接数据库，版本号可不写</span><br><span class=\"line\">var request = window.indexedDB.open(&quot;mydb&quot;,6);</span><br><span class=\"line\"></span><br><span class=\"line\">const personData = [</span><br><span class=\"line\">\t&#123; id:&quot;5&quot;,name:&quot;asdf&quot;,value:&quot;ccc&quot; &#125;,</span><br><span class=\"line\">\t&#123; id:&quot;6&quot;,name:&quot;asdfasdf&quot;,value:&quot;ccdsc&quot; &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">//如果数据库打开成功</span><br><span class=\"line\">var mydb;</span><br><span class=\"line\">request.onsuccess = function(event)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;数据库打开成功&apos;);</span><br><span class=\"line\">\tmydb = event.target.result;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//这个对象很重要，大概所有的操作都要通过该对象进行</span><br><span class=\"line\">\tvar objSto = mydb.transaction(&quot;person&quot;,&quot;readwrite&quot;).objectStore(&quot;person&quot;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//删除请求，参数指定的是主键的值</span><br><span class=\"line\">\tvar deleterequest = objSto.delete(&quot;5&quot;);</span><br><span class=\"line\">\tdeleterequest.onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;数据删除成功&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t这里是添加数据模块，由于某行数据重复添加会出现错误导致后面的全部操作事务全部失败，故注释了</span><br><span class=\"line\">\tvar addrequest = objSto.add(&#123; id:&quot;8&quot;,name:&quot;asdfasdf&quot;,value:&quot;ccdsc&quot; &#125;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\taddrequest.onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;add success!&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\taddrequest.onerror = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;add failed!&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t*/</span><br><span class=\"line\"></span><br><span class=\"line\">\t//查询模块</span><br><span class=\"line\">\tvar findrequest = objSto.get(&quot;2&quot;);</span><br><span class=\"line\">\tfindrequest.onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;success find&quot;)</span><br><span class=\"line\">\t\tif(findrequest.result)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(&quot;name:&quot; + findrequest.result.name);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tfindrequest.onerror = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;failed&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//遍历查询模块，使用到了游标</span><br><span class=\"line\">\tobjSto.openCursor().onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tvar cursor = event.target.result;</span><br><span class=\"line\">\t\tif (cursor)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(cursor.key);</span><br><span class=\"line\">\t\t\tconsole.log(cursor.value.name);</span><br><span class=\"line\">\t\t\tcursor.continue();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//更新数据模块</span><br><span class=\"line\">\tvar updaterequest = objSto.put(&#123; id:&quot;6&quot;,name:&quot;呜哈哈&quot;,value:&quot;ccdsc&quot; &#125;);</span><br><span class=\"line\">\tupdaterequest.onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tconsole.log(&quot;更新成功&quot;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//索引查询</span><br><span class=\"line\">\tvar index = objSto.index(&quot;name&quot;);</span><br><span class=\"line\">\tvar indexrequest = index.get(&quot;asdf&quot;);</span><br><span class=\"line\">\tindexrequest.onsuccess = function(event)&#123;</span><br><span class=\"line\">\t\tvar result = event.target.result;</span><br><span class=\"line\">\t\tif(result)&#123;</span><br><span class=\"line\">\t\t\tconsole.log(result);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t/*\t</span><br><span class=\"line\">\t下面的代码可以把前面定义的personData里的数组插入库中</span><br><span class=\"line\">\tpersonData.forEach(function(person)&#123;</span><br><span class=\"line\">\t\tobjSto.add(person);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1whaf3z84j30hz08m0t2.jpg\" alt=\"\"></p>\n<p>这里可以看到，遍历还没结束的时候，下面的更新模块就运行完了，所以使用游标遍历要注意顺序问题。可能会出现某些问题。</p>\n","categories":["数据库"],"tags":["js","前端"]},{"title":"【ajax】请求服务器+参数双向传递","url":"/2018/10/24/%E3%80%90ajax%E3%80%91%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8F%82%E6%95%B0%E5%8F%8C%E5%90%91%E4%BC%A0%E9%80%92/","content":"<hr>\n<p><strong>Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。</strong></p>\n<hr>\n<p> <strong>1. GET方式</strong></p>\n<pre><code>$(document).ready(function(){\n\n    $(&quot;#btnsub&quot;).click(function(){\n        var xmlhttp,cardId,date;\n        cardId=$(&quot;#cardId&quot;).val();\n        date=$(&quot;#date&quot;).val();\n\n        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;\n        if (window.XMLHttpRequest)\n          {// code for IE7+, Firefox, Chrome, Opera, Safari\n          xmlhttp=new XMLHttpRequest();\n          }\n        else\n          {// code for IE6, IE5\n          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n          }\n        xmlhttp.onreadystatechange=function()\n          {\n          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)\n            {\n            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;\n            }\n          }\n        xmlhttp.open(&quot;GET&quot;,&quot;ajax!findRecord.action?&quot;+str,true);\n        xmlhttp.send();\n\n    });\n});\n</code></pre><p>通过在请求的URL”？”后加参数而达到传参的目的。<br>对于URL尾部的参数，后台action中只要通过request域对象即可取值。</p>\n<pre><code>HttpServletRequest request=ServletActionContext.getRequest();\nHttpServletResponse response=ServletActionContext.getResponse();\n\nresponse.setContentType(&quot;text/html&quot;);\nresponse.setCharacterEncoding(&quot;UTF-8&quot;);\n\nInteger cardId=Integer.parseInt(request.getParameter(&quot;cardId&quot;));\nString date=request.getParameter(&quot;date&quot;);\n</code></pre><p>struts2里配置为:</p>\n<pre><code>&lt;package name=&quot;actionA&quot; extends=&quot;json-default&quot;&gt;\n    &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt;\n    &lt;action name=&quot;ajax!*&quot; class=&quot;ajaxAction&quot; method=&quot;{1}&quot;&gt;\n        &lt;result type=&quot;json&quot;&gt;&lt;/result&gt;\n    &lt;/action&gt;\n&lt;/package&gt;\n</code></pre><hr>\n<p> <strong>2. —- POST方式</strong><br>    &nbsp;post请求方式相对于get请求方式更加安全（数据信息不会显示在URL中），发送请求能提交的数据也更大。</p>\n<pre><code>$(document).ready(function(){\n\n    $(&quot;#btnsub&quot;).click(function(){\n        var xmlhttp,cardId,date;\n        cardId=$(&quot;#cardId&quot;).val();\n        date=$(&quot;#date&quot;).val();\n\n        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;\n        if (window.XMLHttpRequest)\n          {// code for IE7+, Firefox, Chrome, Opera, Safari\n          xmlhttp=new XMLHttpRequest();\n          }\n        else\n          {// code for IE6, IE5\n          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n          }\n        xmlhttp.onreadystatechange=function()\n          {\n          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)\n            {\n            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;\n            }\n          }\n        xmlhttp.open(&quot;POST&quot;,&quot;ajax!findRecord.action&quot;,true);\n        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);\n        xmlhttp.send(str);\n    });\n});\n</code></pre><p>后台action内获取ajax发送来的数据参数方式同上。</p>\n<hr>\n<hr>\n<h3 id=\"Ajax-ajax\"><a href=\"#Ajax-ajax\" class=\"headerlink\" title=\"Ajax-ajax()\"></a><strong>Ajax-ajax()</strong></h3><p>它是最底层、功能最强大的请求服务器数据方式，它的调用格式为：</p>\n<pre><code>$.ajax([settings]);\n</code></pre><p>接下来是实际使用:</p>\n<pre><code>$(document).ready(function(){\n    function doappend(list){\n        var tbody=&quot;&quot;;\n        for(i in list){\n            tbody+=&quot;&lt;tr&gt;&lt;td&gt;&quot;+list[i].userId+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].userName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].password+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].cards+&quot;&lt;/td&gt;&lt;td&gt;&lt;a href=\\&quot;#\\&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=\\&quot;#\\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;\n        }\n         document.getElementById(&quot;divtable&quot;).innerHTML=tbody;\n    };\n\n    $(&quot;#btnSend&quot;).click(function(){\n        $(this).attr(&quot;disabled&quot;,true);\n        var pag=document.getElementById(&quot;thepage&quot;).innerText;\n        $.ajax({\n            type:&quot;POST&quot;,\n            url:&quot;ajax!findall.action&quot;,\n            data:{&quot;page&quot;:pag},\n            dataType:&quot;json&quot;,\n            success:function(data){\n                var a=eval(&apos;(&apos;+data+&apos;)&apos;);\n                var am=a.aMap;\n                var list=am.user;\n                doappend(list);\n\n            }\n        });\n    });\n\n});\n</code></pre><p>data:标签对应为发送给服务器后台的数据，必须要使用json格式｛”name”:name,”id”:id｝。type对应请求方式，url为请求的定位，dataType为服务器返回数据的类型，success为成功获取服务器返回数据后可以执行的操作（这里我正在做分页，把页数发送给服务器，服务器查询数据库后返回相应条数的数据）。<br>function里的data为服务器返回的数据，这里是一个hashmap类型，先对data用eval方法进行json格式解析，aMap为当时hashmap设置的name值，在hashmap格式里，key值为‘user’对应的对象，为一个list<user>类型，具体可以看下面的后台代码，然后执行doappend方法，将数据一条一条加入到表格格式里。</user></p>\n<pre><code>private String page;\n\nHashMap&lt;String, Object&gt; aMap=new HashMap&lt;String,Object&gt;();\n\npublic HashMap&lt;String, Object&gt; getaMap() {\n    return aMap;\n}\n\npublic String getPage() {\n    return page;\n}\n\npublic void setPage(String page) {\n    this.page = page;\n}\n\npublic String findall() {\n    int c=userService.count();\n    int d;\n    if(0==c%5) {\n        d=c/5;\n    }else {\n        d=(c/5)+1;\n    }\n    aMap.clear();\n    int p=Integer.parseInt(page);\n    if(p&lt;1||p&gt;d) {\n        return NONE;\n    }else {\n        int begin=(p-1)*5;\n        List&lt;User&gt; pList=userService.findPage(begin, 5);\n        List&lt;UserForAjax&gt; uList=new ArrayList&lt;UserForAjax&gt;();\n        for (User user : pList) {\n            StringBuffer sv=new StringBuffer(&quot;&quot;);\n            for(BankCard bCard:user.getSetBank()) {\n                sv.append(bCard.getCardId()+&quot; &quot;);\n            }\n            String str=sv.toString();\n            UserForAjax userForAjax=new UserForAjax();\n            userForAjax.setUserId(user.getUserId());\n            userForAjax.setEmail(user.getEmail());\n            userForAjax.setPassword(user.getPassword());\n            userForAjax.setUserName(user.getUserName());\n            userForAjax.setCards(str);\n            uList.add(userForAjax);\n        }\n        aMap.put(&quot;user&quot;, uList);\n        aMap.put(&quot;result&quot;, &quot;success&quot;);\n        return SUCCESS;\n    }\n}\n</code></pre><p>后台代码中，通过命名一个叫做page的string对象，并生成set和get方法，接收请求后，就能直接得到请求数据中的page对象的值（会调用set方法给this.page赋值），另外创建一个hashmap对象用来存放返回给前端的数据，并生成<strong>get</strong>方法，这样ajax那边才能得到返回的aMap，在方法中给aMap存入需要传递的值。</p>\n<hr>\n<p>一个简单的分页就做好啦!<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw7552c8jpj30x30at74d.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw755vane7j30x80apq30.jpg\" alt=\"\"></p>\n","categories":["前端"],"tags":["ajax"]},{"title":"【java】使用javaCV对直播RTSP流实时转码，使用flvjs控件播放","url":"/2020/06/01/%E3%80%90java%E3%80%91%E4%BD%BF%E7%94%A8javaCV%E5%AF%B9%E7%9B%B4%E6%92%ADRTSP%E6%B5%81%E5%AE%9E%E6%97%B6%E8%BD%AC%E7%A0%81%EF%BC%8C%E4%BD%BF%E7%94%A8flvjs%E6%8E%A7%E4%BB%B6%E6%92%AD%E6%94%BE/","content":"<h2 id=\"javaCV，计算机视觉领域常用库与程序类\"><a href=\"#javaCV，计算机视觉领域常用库与程序类\" class=\"headerlink\" title=\"javaCV，计算机视觉领域常用库与程序类\"></a>javaCV，计算机视觉领域常用库与程序类</h2><p>最近由于工作需要接触了直播视频RTSP流转码写出到前端的项目，需要使用其对监控视频RTSP流进行转码才能使用h5控件播放。主要用到的工具为JavaCV封装的FFmpeg，因此不必引入其所有的子依赖。pom文件部分内容如下：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n    &lt;artifactId&gt;ffmpeg-platform&lt;/artifactId&gt;\n    &lt;version&gt;4.1.3-1.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- rtsp视频流转码工具 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n    &lt;artifactId&gt;javacv&lt;/artifactId&gt;\n    &lt;version&gt;1.5.1&lt;/version&gt;\n    &lt;!-- 简化依赖，排除不必要的依赖模块 --&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;opencv&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;flandmark&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;tesseract&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;leptonica&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;artoolkitplus&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;videoinput&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;librealsense&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;libfreenect&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;libfreenect2&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;libdc1394&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;flycapture&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;openblas&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;ffmpeg&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;\n            &lt;artifactId&gt;javacpp&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><p>其中<strong>platform</strong>的依赖可以在打包时选择具体应用的平台，精简依赖项。详情见：</p>\n<blockquote>\n<p><a href=\"https://github.com/bytedeco/javacpp-presets/wiki/Reducing-the-Number-of-Dependencies\" target=\"_blank\" rel=\"noopener\">https://github.com/bytedeco/javacpp-presets/wiki/Reducing-the-Number-of-Dependencies</a></p>\n</blockquote>\n<h2 id=\"使用FFmpeg抓流\"><a href=\"#使用FFmpeg抓流\" class=\"headerlink\" title=\"使用FFmpeg抓流\"></a>使用FFmpeg抓流</h2><p>读流器：<strong>FFmpegFrameGrabber</strong><br>可设置参数：</p>\n<pre><code>//设置打开协议tcp / udp\ngrabber.setOption(&quot;rtsp_transport&quot;, &quot;tcp&quot;);\n//设置未响应超时时间 0.5秒\ngrabber.setOption(&quot;stimeout&quot;, &quot;500000&quot;);\n//设置缓存大小，提高画质、减少卡顿花屏\n//grabber.setOption(&quot;buffer_size&quot;, &quot;1024000&quot;);\n//设置视频比例\n//grabber.setAspectRatio(1.7777);\n</code></pre><p>打开协议要注意，根据视频流的要求选择。如果是本地生成的RTSP视频流，就不要选择tcp协议了，会报错。（VLC控件可以将本地视频转化为RTSP流）<br>转码器：<strong>FFmpegFrameRecorder</strong></p>\n<p>实际工作过程为，后台不断从RTSP流链接读流，然后转码，写新转码的流到前台，前台可通过该长连接请求播放直播视频。</p>\n<p>由于是一个耗时的过程，而每个视频又不能等待前面的转码结束后才开始，因此这里我使用了没有阻塞队列的线程池newCachedThreadPool来创建启动转码线程。<br>当前台每次销毁一个播放视频时，请求一次后台停止对应的视频转码线程。而当用户异常关闭页面、中止请求时，后台也会实时获取状态，停止对应的线程节省空间。</p>\n<p>项目相关代码已上传github，注释已写的很清晰：</p>\n<blockquote>\n<p><a href=\"https://github.com/HolyDogs/RTSP-Video-Flv\" target=\"_blank\" rel=\"noopener\">https://github.com/HolyDogs/RTSP-Video-Flv</a></p>\n</blockquote>\n<p>有问题可以去官方项目提issues，作者回复很及时：</p>\n<blockquote>\n<p><a href=\"https://github.com/bytedeco/javacv/issues\" target=\"_blank\" rel=\"noopener\">https://github.com/bytedeco/javacv/issues</a></p>\n</blockquote>\n","categories":["java"],"tags":["视频","flvjs"]},{"title":"【java】关于replace字符串时特殊字符的坑","url":"/2019/02/25/%E3%80%90java%E3%80%91%E5%85%B3%E4%BA%8Ereplace%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%9D%91/","content":"<p>刚遇到个字符串替换的坑，记录一下</p>\n<p>实际使用时是这样的，有一个字符串里面包含\\n \\“等字符</p>\n<p>现在我要把他们替换为空格和”</p>\n<p>第一时间我想到的是</p>\n<pre><code>str.replaceAll(&quot;\\\\n&quot;,&quot;&quot;);\nstr.replaceAll(&quot;\\\\\\&quot;&quot;,&quot;&quot;&quot;);\n</code></pre><p>实际上完全替换不了，还有错误</p>\n<p>实际\\n和\\“在java中是这样存储的</p>\n<pre><code>\\\\n 和 \\\\&quot;\n</code></pre><p>正确的替换方式:</p>\n<pre><code>replaceAll(&quot;\\\\\\\\n&quot;,&quot;&quot;)\nreplaceAll(&quot;\\\\\\\\\\&quot;&quot;,&quot;\\&quot;&quot;)\n</code></pre><p>居然需要4个反斜线…</p>\n","categories":["java"]},{"title":"【SpringBoot】自定义SpringBoot定时任务线程池","url":"/2020/07/05/%E3%80%90SpringBoot%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>多个定时任务设置同时启动时，只有一个定时任务被执行。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>ScheduledTaskRegistrar类里有一段这样的代码<br><img src=\"https://oscimg.oschina.net/oscnet/f93c93a461d70bcfd43b294e6972469cfa9.jpg\" alt=\"jpg\"><br>springBoot定时任务默认使用newSingleThreadScheduledExecutor创建线程池，最多只能同时存在一个定时任务线程运行。</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>方法1：项目启动时注入TaskScheduler的bean，并设置线程池大小（未尝试）</p>\n<pre><code>@Bean\npublic TaskScheduler taskScheduler() {\n    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();\n    taskScheduler.setPoolSize(50);\n    return taskScheduler;\n}\n</code></pre><p>方法2：增加springBoot配置</p>\n<pre><code>spring.task.scheduling.pool.size=50\n</code></pre><hr>\n<p>根据我的实际使用，发现运行过程中虽然可以成功创建多个线程来运行定时任务了，但是运行结束后通过Jconsole查看线程，线程一直处于未关闭的状态。我的定时任务设定是每个月执行一次，这样的线程池也不符合我的需求。于是便开始尝试使用自定的线程池来创建线程运行定时任务。</p>\n<p>解决步骤：</p>\n<ol>\n<li><p>创建线程池配置类</p>\n<pre><code>@Configuration\npublic class TaskPoolConfig implements AsyncConfigurer {\n\n    @Override\n    @Bean(&quot;taskExecutor&quot;)\n    public Executor getAsyncExecutor(){\n        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();\n        //线程核心池，每月执行一次，设为0\n        taskExecutor.setCorePoolSize(0);\n        //线程核心池最大值\n        taskExecutor.setMaxPoolSize(50);\n        //线程等待队列0\n        taskExecutor.setQueueCapacity(0);\n        //线程空闲等待时间，超过60秒关闭\n        taskExecutor.setKeepAliveSeconds(60);\n        //线程前缀\n        taskExecutor.setThreadNamePrefix(&quot;taskExecutorXFF--&quot;);\n        taskExecutor.setWaitForTasksToCompleteOnShutdown(true);\n        taskExecutor.setAwaitTerminationSeconds(60);\n        return taskExecutor;\n    }\n}\n</code></pre></li>\n<li><p>启动类上添加@EnableAsync注解</p>\n</li>\n<li><p>在定时任务方法上添加@Async(“taskExecutor”)注解</p>\n<pre><code>@Scheduled(cron = &quot;0 0 0 1 7/1 ?&quot;)  \n@Async(&quot;taskExecutor&quot;)  \npublic void dataUpdate1() {\n    ...\n}\n</code></pre></li>\n</ol>\n<p>这样就做到了自定义SpringBoot定时任务运行的线程池</p>\n","categories":["SpringBoot"],"tags":["定时任务","线程池"]},{"title":"【java】日志打印","url":"/2019/03/20/%E3%80%90java%E3%80%91%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0/","content":"<p>日常开发中，想打印某些值的信息时</p>\n<p>总是Syso=&gt;System.out.pringln(xxx)</p>\n<p>然后在代码规范里看到了，禁止使用这种方式打印信息，可以选择日志工具打印查看</p>\n<p>日常使用的工具有log4j、logback、slf4j</p>\n<p>log4j必须配置配置文件log4j.properties，类似下面这样，可以指定打印级别</p>\n<pre><code># Configure logging for testing: optionally with log file\nlog4j.rootLogger=INFO, stdout \n# log4j.rootLogger=WARN, stdout, logfile\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n\n\nlog4j.appender.logfile=org.apache.log4j.FileAppender\nlog4j.appender.logfile.File=target/spring.log\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre><p>一般log4j会和commons-logging搭配使用</p>\n<p>commons-logging提供一个统一的日志接口，简单了操作，同时避免项目与某个日志实现系统紧密a耦合很贴心的帮我们自动选择适当的日志实现系统（这一点非常好！）它甚至不需要配置</p>\n<p>在使用时，会从classpath查找commons-logging.properties文件</p>\n<p>若找不到，则在查找是否已定义系统环境变量org.apache.commons.logging.Log，找到则使用其定义的Log实现类<br>这样使用</p>\n<pre><code>private static Log log = LogFactory.getLog(YouClassName. class );\n</code></pre><hr>\n<h2 id=\"Slf4j\"><a href=\"#Slf4j\" class=\"headerlink\" title=\"Slf4j\"></a>Slf4j</h2><p>主要还是用这个打印日志吧<br>不需要配置文件，只需要依赖slf4j-api即可</p>\n<p>然后使用时直接</p>\n<pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(CheckCodeUtills.class);\n</code></pre><p>然后使用</p>\n<pre><code>LOGGER.info、warn、error(xxxx)\n</code></pre><p>之类的</p>\n<h2 id=\"注解方式\"><a href=\"#注解方式\" class=\"headerlink\" title=\"注解方式\"></a>注解方式</h2><p>只需要在需要使用的类上加上（需要提前引入lombok依赖）</p>\n<pre><code>@Slf4j\n</code></pre><p>然后在使用时</p>\n<pre><code>log.info、warn....(xxxx)\n</code></pre><p>即可</p>\n<p>另外下面这篇博客说明了slf4j和log4j的好坏</p>\n<blockquote>\n<p><a href=\"https://www.oschina.net/translate/why-use-sl4j-over-log4j-for-logging\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/translate/why-use-sl4j-over-log4j-for-logging</a></p>\n</blockquote>\n","categories":["java"]},{"title":"【SpringCloud】springCloud总体结构和技术熟悉","url":"/2020/07/10/%E3%80%90SpringCloud%E3%80%91springCloud%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%92%8C%E6%8A%80%E6%9C%AF%E7%86%9F%E6%82%89/","content":"<p>springCloud组件图<br><img src=\"https://src.windmt.com/img/006tNc79ly1fqc4dcx75gj31ab0o775w.jpg\" alt=\"https://src.windmt.com/img/006tNc79ly1fqc4dcx75gj31ab0o775w.jpg\"><br>springCloud结构图<br><img src=\"https://src.windmt.com/img/006tNc79ly1fqc2klep72j30n00jhjsd.jpg\" alt=\"\"></p>\n<h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><p><strong>服务注册中心：Eureka、（zookeeper等）</strong><br>负责管理服务的注册和发现。</p>\n<h2 id=\"服务调用\"><a href=\"#服务调用\" class=\"headerlink\" title=\"服务调用\"></a>服务调用</h2><p><strong>调用端断路器：Hystrix</strong><br>当某个服务出问题时，设置快速失败机制，再多次失败后再次调用直接返回失败，避免出现雪崩现象（指由于前面的服务调用失败导致后面的服务调用全部失败导致调用端    持续等待影响了整体服务；服务雪崩效应是一种因 “服务提供者” 的不可用导致 “服务消费者” 的不可用，并将不可用逐渐放大的过程。）。</p>\n<p><strong>调用端负载均衡：Ribbon</strong><br>对有多个实例的同一服务（集群），当调用服务时，进行负载均衡来让各个实例合理地分配到请求。</p>\n<p><strong>调用端代码封装与抽象：Feign</strong><br>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。Feign默认集成了Ribbon与Hystrix，具有熔断的能力，与Eureka结合，默认实现了负载均衡的效果。</p>\n<h2 id=\"服务路由和过滤\"><a href=\"#服务路由和过滤\" class=\"headerlink\" title=\"服务路由和过滤\"></a>服务路由和过滤</h2><p><strong>服务路由和过滤：Zuul</strong><br>1可以过滤cookie和httpHeader<br>2路径映射<br>3可实现动态路由，根据请求路径动态映射到不同服务，如下图<br><img src=\"https://s1.ax1x.com/2020/07/05/Up9r7V.png\" alt=\"Up9r7V.png\"></p>\n<h2 id=\"监控数据收集\"><a href=\"#监控数据收集\" class=\"headerlink\" title=\"监控数据收集\"></a>监控数据收集</h2><p><strong>Hystrix Dashboard 和 Turbine</strong><br>对服务熔断情况进行监控。<br>只使用 Hystrix Dashboard 的话，你只能看到单个应用内的服务信息。<br>Turbine能让我们汇总系统内多个服务的数据并显示到 Hystrix Dashboard 上。</p>\n<p><strong>Spring Cloud Sleuth 和 Zipkin</strong><br>通过 Sleuth 可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。</p>\n<p>Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口</p>\n<p>分布式链路跟踪需要 Sleuth+Zipkin 结合来实现</p>\n<h2 id=\"其它工具\"><a href=\"#其它工具\" class=\"headerlink\" title=\"其它工具\"></a>其它工具</h2><p><strong>Spring Cloud Config</strong><br>分布式系统的配置管理方案。</p>\n<p><strong>Spring Cloud Bus</strong><br>用 AMQP 消息代理作为通道，通过分布式的启动器对 Spring Boot 应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。可用于对分布式配置变化进行广播，不用对每个服务端都进行refresh操作就能更新所有服务的配置。</p>\n<hr>\n<blockquote>\n<p>原文：<a href=\"https://windmt.com/2018/04/14/spring-cloud-0-microservices/\" target=\"_blank\" rel=\"noopener\">https://windmt.com/2018/04/14/spring-cloud-0-microservices/</a></p>\n</blockquote>\n","categories":["SpringCloud"],"tags":["SpringCloud"]},{"title":"【mybatis】与spring整合","url":"/2018/11/15/%E3%80%90mybatis%E3%80%91%E4%B8%8Espring%E6%95%B4%E5%90%88/","content":"<p><em>只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。</em></p>\n<hr>\n<p>导入相应的整合包后，首先将数据库的配置交给spring配置：</p>\n<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context-3.2.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;\n\n\n    &lt;!-- 加载配置文件 --&gt;\n    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;\n\n    &lt;!-- 数据源，使用dbcp --&gt;\n    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;\n          destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;\n        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;\n        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\n        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- sqlSessinFactory --&gt;\n    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n        &lt;!-- 加载mybatis的配置文件 --&gt;\n        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;\n        &lt;!-- 数据源 --&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre><p>使用mapper代理开发时，在spring容器中配置mapper的接口生成代理对象：</p>\n<pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;\n        //mapperInterface指定mapper接口\n        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;\n        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;\n&lt;/bean&gt;\n</code></pre><p>通过MapperScannerConfigurer进行mapper扫描可以实现批量配置：</p>\n<pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n    &lt;!-- 指定扫描的包名\n    如果扫描多个包，每个包中间使用半角逗号分隔\n    --&gt;\n    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;\n    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;\n&lt;/bean&gt;\n</code></pre><hr>\n<p>这样，要使用mapper时，只需要通过注解的方式：</p>\n<pre><code>@Autowired\nprivate UserMapper userMapper;\n</code></pre><p>或加载spring配置文件的方式（Test方法里使用）:</p>\n<pre><code>private ApplicationContext applicationContext;\napplicationContext = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);\nUserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);\n</code></pre>","categories":["mybatis"],"tags":["mybatis"]},{"title":"【mybatis】多对多关系","url":"/2018/11/05/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/","content":"<p><em>关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。</em></p>\n<hr>\n<ul>\n<li><strong>首先，创建表，建立连接关系。</strong><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwa2l7b67ej30ib0e8jrg.jpg\" alt=\"\"></li>\n</ul>\n<ul>\n<li><strong>然后，插入示例数据。</strong><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwa2mq19o5j30ib0e8q30.jpg\" alt=\"\"></li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwa2n7k9vwj30ib0e8glp.jpg\" alt=\"\"></p>\n<p>打印一下，记录<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwa2nxp4o4j30ib0kiaa1.jpg\" alt=\"\"></p>\n<p>分别为三张表，一张银行用户表，简单起见，只有id和name两列，一张银行卡表，有id和money两列，最后是一张关系维护表，有三列，id、对应用户的buserid、对应卡的bcardid。</p>\n<p>我设定的银行卡为家庭卡，可以多个人用一个账号，一个人可以用多张卡。</p>\n<h2 id=\"前提准备做完了，开始建立多对多关系映射。\"><a href=\"#前提准备做完了，开始建立多对多关系映射。\" class=\"headerlink\" title=\"前提准备做完了，开始建立多对多关系映射。\"></a>前提准备做完了，开始建立多对多关系映射。</h2><ol>\n<li>创建用户和卡的表对应的实体类，并设置对应的映射属性，分别加入一个list\\<t>属性。如下：</t></li>\n</ol>\n<pre><code>package com.test.domain;\n\nimport java.util.List;\n\npublic class Buser {\n    private int id;\n    private String name;\n    private List&lt;Bcard&gt; bcards;\n\n    public List&lt;Bcard&gt; getBcards() {\n        return bcards;\n    }\n    public void setBcards(List&lt;Bcard&gt; bcards) {\n        this.bcards = bcards;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n\n}\n</code></pre><ol start=\"2\">\n<li><p>创建并配置对应的mapper映射文件</p>\n<pre><code>&lt;mapper namespace=&quot;com.test.mapper.BuserMapper&quot;&gt;\n    &lt;resultMap type=&quot;buser&quot; id=&quot;resultUmap&quot;&gt;\n        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;\n        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;\n&lt;!--         &lt;collection property=&quot;uList&quot; ofType=&quot;com.test.domain.Ctou&quot;&gt;\n            &lt;id column=&quot;c_id&quot; property=&quot;id&quot; /&gt;\n            &lt;result column=&quot;buserid&quot; property=&quot;buserid&quot; /&gt;\n            &lt;result column=&quot;bcardid&quot; property=&quot;bcardid&quot; /&gt;\n        &lt;/collection&gt; --&gt;\n        &lt;collection property=&quot;bcards&quot; ofType=&quot;com.test.domain.Bcard&quot;&gt;\n                &lt;id column=&quot;b_id&quot; property=&quot;id&quot; /&gt;\n                &lt;result column=&quot;money&quot; property=&quot;money&quot; /&gt;\n        &lt;/collection&gt;\n    &lt;/resultMap&gt;\n\n    &lt;select id=&quot;selectMtoM&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;resultUmap&quot;&gt;\n        SELECT buser.*,bcard.id b_id,bcard.money from buser,ctou,bcard\n        where buser.id=#{value} and buser.id=ctou.buserid and ctou.bcardid=bcard.id\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li>创建对应接口和方法</li>\n</ol>\n<pre><code>public interface BuserMapper {\n    public Buser selectMtoM(Integer value) throws Exception;\n}\n</code></pre><ol start=\"4\">\n<li><p>记得在总配置文件里配置</p>\n<pre><code>&lt;typeAliases&gt;\n    &lt;package name=&quot;com.me.domain&quot;/&gt;\n    &lt;package name=&quot;com.test.domain&quot;/&gt;\n&lt;/typeAliases&gt;\n\n&lt;mappers&gt;\n    &lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; --&gt;    \n    &lt;package name=&quot;com.me.mapper&quot;/&gt;\n\n     &lt;package name=&quot;com.test.mapper&quot;/&gt;\n&lt;/mappers&gt;\n</code></pre></li>\n<li><p>测试</p>\n<pre><code>Buser buser=buserMapper.selectMtoM(111);\nSystem.out.println(buser.getName());\nfor (Bcard bcard : buser.getBcards()) {\n    System.out.println(bcard.getId()+&quot; &quot;+bcard.getMoney());\n}\n</code></pre></li>\n</ol>\n<ol start=\"6\">\n<li>结果输出：<br>胡歌<br>1002 0<br>1003 10000</li>\n</ol>\n<hr>\n<p>反过来从bcard来查buser也一样的步骤。</p>\n<p>over~</p>\n","categories":["mybatis"],"tags":["mybatis"]},{"title":"【Docker】docker基本使用","url":"/2020/01/06/%E3%80%90Docker%E3%80%91docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"三层概念\"><a href=\"#三层概念\" class=\"headerlink\" title=\"三层概念\"></a>三层概念</h2><ul>\n<li><strong>仓库</strong>：类似于Github或者Gitlab，不是保存代码，而是用来保存镜像。（Docker Hub）</li>\n<li><strong>镜像IMAGE</strong>：Docker镜像，相当于一个系统，容器基于镜像的环境运行，例如Ubuntu:14.04（冒号后面表示版本，可以自定义版本号名，如dev、test、prod）</li>\n<li><strong>容器CONTAINER</strong>：容器是镜像运行的实体，可以被创建、启动、停止、删除、暂停等。</li>\n</ul>\n<hr>\n<h2 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h2><p>Docker一般都在Linux系统上运行，实际在windows系统上安装时也是虚拟出一个Linux系统环境运行。安装只需要几行命令即可，可见官网文档。<br>需要注意的是windows家庭版安装docker会报错，需要升级到专业版，打开Hype-V功能。</p>\n<h2 id=\"Docker基本使用\"><a href=\"#Docker基本使用\" class=\"headerlink\" title=\"Docker基本使用\"></a>Docker基本使用</h2><pre><code>docker run ubuntu:14.04  /bin/echo &quot;Hello world&quot;\n</code></pre><p>以上命令表示使用ubuntu14.04的镜像创建一个容器，运行/bin/echo “hello world”的命令，当本地找不到该镜像时，会自动去Docker-Hub下载对应的镜像。</p>\n<p>使用</p>\n<pre><code>docker image ls\ndocker ps -a\n</code></pre><p>分别查看docker镜像和容器，不加-a可以查看正在运行的容器。</p>\n<pre><code>docker run -d ubuntu:15.10  /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n</code></pre><p>该行命令创建了一个容器运行后面的shell命令，-d表示在后台运行，此时该容器一只在每隔一秒打印hello world的信息。使用</p>\n<pre><code>docker logs &lt;容器名或者容器id&gt;\n</code></pre><p>可以查看对应容器打印的信息。</p>\n<pre><code>docker start &lt;容器名或者容器id&gt;\ndocker stop &lt;容器名或者容器id&gt;\n</code></pre><p>上面两条命令可以启动或者停止容器。</p>\n<pre><code>docker exec -it &lt;容器名或者容器id&gt; /bin/bash\n</code></pre><p>使用上面的命令可以进入容器查看容器内的文件结构，可以把容器看成是一个单独的操作系统，<strong>cat /proc/version</strong>和<strong>ls</strong>分别查看当前系统的版本信息和当前目录下的文件列表.<br>除了exec进入容器还可以使用attach，但attach进入容器使用exit退出后会自动停止容器，所以建议使用exec进入容器。</p>\n<pre><code>docker pull &lt;镜像&gt;\n</code></pre><p>我们可以使用该命令从远程下载一个镜像。</p>\n<pre><code>docker export &lt;容器id或者容器名&gt; &gt; xxxx.tar\n</code></pre><p>上面命令可以把容器导出到本地文件xxxx.tar</p>\n<pre><code>cat docker/ubuntu.tar | docker import  - test/ubuntu:v1\n</code></pre><p>该命令用于把本地文件导入到test/ubuntu:v1镜像中。</p>\n<pre><code>docker rm &lt;容器id或者容器名&gt;\n</code></pre><p>该命令用于删除一个容器</p>\n<pre><code>docker rmi &lt;镜像名&gt;\n</code></pre><p>该命令用于删除一个镜像，删除镜像前需要删除建立在该镜像下的所有容器。</p>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>在宿主机一个空文件夹下创建一个<strong>Dockerfile</strong>文件（非空目录会把目录下的所有文件一起打包到镜像，造成不必要的时间空间的浪费）<br>首先创建一个c语言程序，编译一个打印helloworld的可执行文件。<br><img src=\"https://s2.ax1x.com/2020/01/06/lsIMIU.png\" alt=\"lsIMIU.png\"><br>使用gcc编译后得到hello可执行文件，然后对Dockerfile进行编辑输入</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/06/lsIyQA.png\" alt=\"lsIyQA.png\"></p>\n<p>FROM表示使用ubuntu:14.04的镜像，ADD表示将当前目录下的hello文件复制到容器内的/mydir/目录下，CMD则表示执行容器内该目录下的程序。</p>\n<p>使用该Dockerfile创建镜像并运行如下：</p>\n<p><img src=\"https://s2.ax1x.com/2020/01/06/lsoEFO.png\" alt=\"lsoEFO.png\"><br>上面的ADD可以替换成COPY，CMD可以替换成RUN，COPY表示复制文件但是不解压，而ADD会自动对压缩文件进行解压然后复制，CMD运行时机为Docker run，而RUN则为docker build。<br>此外，还有很多Dockerfile的命令，可见:</p>\n<blockquote>\n<p><a href=\"https://www.runoob.com/docker/docker-dockerfile.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/docker/docker-dockerfile.html</a></p>\n</blockquote>\n","categories":["docker"],"tags":["linux","docker"]},{"title":"【kettle】简单常用场景使用","url":"/2020/04/30/%E3%80%90kettle%E3%80%91%E7%AE%80%E5%8D%95%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8/","content":"<ol>\n<li><p>新建一个转换<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/b0506729e57c43fc.png\" alt=\"\"></p>\n</li>\n<li><p>设置数据库连接<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/9288f6dd415cc07f.png\" alt=\"\"></p>\n</li>\n<li><p>添加表输入结点<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/182daad8bc0eecdc.png\" alt=\"\"></p>\n</li>\n<li><p>表输入设置<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/f0b9a268877dd8cd.png\" alt=\"\"></p>\n</li>\n<li><p>新增脚本结点并设置（连线按住shift拖拉）<br><img src=\"https://s1.ax1x.com/2020/04/29/JTXMC9.png\" alt=\"JTXMC9.png\"></p>\n</li>\n<li><p>新增输出（表插入）结点并设置<br><img src=\"https://s1.ax1x.com/2020/04/29/JTjKZ8.png\" alt=\"JTjKZ8.png\"><br>其中上面的表格要设置输入表和输出表的字段校验，左边是目标输出表的字段，右边可以选流程中设置的变量或者输入表的字段，当字段数据相同时会更新其它字段，当字段数据不同时会插入新数据；<br>下面是更新字段的设置，需要设置更新目标表的什么字段，同样是左边是目标输出表的字段，右边是变量或者输入表的字段。</p>\n</li>\n<li><p>最后点击校验和运行<br><img src=\"https://s1.ax1x.com/2020/04/29/JTjTSA.png\" alt=\"JTjTSA.png\"></p>\n</li>\n</ol>\n","categories":["数据库"],"tags":["kettle"]},{"title":"【java】函数式接口","url":"/2020/04/29/%E3%80%90java%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","content":"<h2 id=\"Function-lt-A-B-gt\"><a href=\"#Function-lt-A-B-gt\" class=\"headerlink\" title=\"Function&lt;A,B&gt;\"></a>Function&lt;A,B&gt;</h2><p>Function接口可以通过实现其apply方法，然后为该接口传一段逻辑，以对象的形式保存，需要调用该段逻辑时，即可调出来使用。其中参数AB，是指传入一个A类型的参数返回一个B类型的参数。<br>见下面代码：</p>\n<pre><code>Function&lt;Integer, String&gt; function1 = i -&gt; String.valueOf(i+5);\nFunction&lt;Integer, Integer&gt; function2 = i -&gt; i*10;\nSystem.out.println(function1.apply(3));\nSystem.out.println(&quot;f2.andThen(f1):&quot; + function2.andThen(function1).apply(4));\nSystem.out.println(&quot;f1.compose(f2):&quot; + function1.compose(function2).apply(4));\n</code></pre><p>由于java8提供的这些函数式接口都加了@FunctionalInterface注解，让我们可以直接使用lambda表达式来实现这些接口方法，让代码看起来更干净。</p>\n<ul>\n<li>andThen：是指先执行前面的方法，然后执行后面括号的方法</li>\n<li>compose：先执行后面括号里的方法，然后执行前面的方法</li>\n</ul>\n<p>来看看上面代码的返回输出：<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/afea961524cbe735.png\" alt=\"\"></p>\n<h2 id=\"Predicate\"><a href=\"#Predicate\" class=\"headerlink\" title=\"Predicate\"></a>Predicate<t></t></h2><p>断言类接口，返回一个boolean值，可传入一个T类型的参数。可以使用lambda表达式实现，或者实现接口方法test。<br>见下方代码：</p>\n<pre><code>Predicate&lt;Integer&gt; predicate1 = i -&gt; i&lt;10;\nSystem.out.println(predicate1.test(5));\nSystem.out.println(predicate1.test(20));\n//反向\nPredicate predicate2 = predicate1.negate();\nSystem.out.println(&quot;predi2:&quot; + predicate2.test(5));\nPredicate predicate3 = predicate1.and(new Predicate&lt;Integer&gt;() {\n    @Override\n    public boolean test(Integer integer) {\n        return false;\n    }\n});\nSystem.out.println(&quot;predi3:&quot; + predicate3.test(5) + &quot; +++ &quot; + predicate3.test(20));\n</code></pre><p>该接口的or和and方法则是将两个断言式接口的判断结果进行与或操作返回一个能得出最终结果的函数方法。<br>因此上方代码的返回结果为：</p>\n<pre><code>true\nfalse\npredi2:false\npredi3:false +++ false\n</code></pre><h2 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer<t></t></h2><p>消费类接口，该类型接口不返回数据，仅仅将传入的信息进行消费，其需要实现的方法为accept。<br>代码：</p>\n<pre><code>int [] myArr = new int[5];\nArrays.fill(myArr, 1);\nConsumer&lt;int[]&gt; consumer1 = arr -&gt; arr[1]=0;\nconsumer1.accept(myArr);\nSystem.out.println(&quot;Array:&quot; + Arrays.toString(myArr));\n</code></pre><p>输出结果为：</p>\n<pre><code>Array:[1, 0, 1, 1, 1]\n</code></pre><hr>\n<p>…</p>\n<p>综上，其实函数式接口就是为了让我们可以将方法定义为一个对象使用，能更方便使用函数方法块，而@FunctionalInterface注解让我们可以使用lambda的形式来实现这些接口，算是简化代码吧。</p>\n","categories":["java"],"tags":["java8"]},{"title":"【mybatis】学习总结(三)","url":"/2018/11/10/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89/","content":"<hr>\n<h2 id=\"延迟加载\"><a href=\"#延迟加载\" class=\"headerlink\" title=\"延迟加载\"></a>延迟加载</h2><p>为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查询的语句，然后在之后才对这个数据进行使用（比如输出），那么在输出的时候，数据库才会真正去运行这条语句返回查询的对象。</p>\n<p>开启延迟加载的方式：</p>\n<ul>\n<li><strong>使用association实现延迟加载</strong></li>\n</ul>\n<p>在association标签里加入select和column属性，select指向查询关联数据的方法，column指向在主表中关联的列（外键那列）。</p>\n<ul>\n<li><p><strong>在全局配置文件中配置</strong></p>\n<pre><code>&lt;settings&gt;\n    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\n    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;\n    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;\n&lt;/settings&gt;\n</code></pre></li>\n</ul>\n<p>settings标签配置在property下面，typeAlias上面。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">延迟加载开关</th>\n<th style=\"text-align:left\">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</th>\n<th style=\"text-align:right\">lazyLoadingEnabled</th>\n<th style=\"text-align:center\">默认为false</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">消极加载</td>\n<td style=\"text-align:left\">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td>\n<td style=\"text-align:right\">aggressiveLazyLoading</td>\n<td style=\"text-align:center\">默认为true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二级缓存</td>\n<td style=\"text-align:left\"><a href=\"#a\">CLICK</a></td>\n<td style=\"text-align:right\">cacheEnabled</td>\n<td style=\"text-align:center\">默认为false</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>一级缓存</strong></li>\n</ul>\n<p>Mybatis默认开启一级缓存，在同一个SqlSession中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则SqlSession的缓存清空。<br>SqlSession关闭也清空，比如一个service调用的结束，会关闭一个sqlsession，则缓存结束。</p>\n<p><span id=\"a\"></span></p>\n<ul>\n<li><strong>二级缓存</strong></li>\n</ul>\n<p>Mybatis需要手动设置启动二级缓存，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存,添加：</p>\n<pre><code>&lt;cache/&gt;\n</code></pre><p>二级缓存的作用域是同一个namespace下的mapper映射文件内容（HashMap），多个SqlSession共享。<br>在同一个namespace下的mapper文件中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则二级缓存清空。<br>一个SqlSession关闭不会导致二级缓存清空，如果设置了二级缓存，service重复被调用查询同一条记录，只会一直从二级缓存中查询。</p>\n<p><strong>实现序列化</strong></p>\n<p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。</p>\n<p>如果该类存在父类，那么父类也要实现序列化。</p>\n<p><strong>设置禁用二级缓存</strong></p>\n<p>在select中添加属性useCache=”false”默认为true。</p>\n<p><strong>设置刷新二级缓存</strong></p>\n<p>在select中添加属性flushCache=”true”。</p>\n<h2 id=\"mybatis整合ehcache\"><a href=\"#mybatis整合ehcache\" class=\"headerlink\" title=\"mybatis整合ehcache\"></a>mybatis整合ehcache</h2><p>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。</p>\n<p>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。</p>\n<p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p>\n<ul>\n<li><strong>整合方法：</strong></li>\n</ul>\n<p>整合ehcache所需包：</p>\n<ul>\n<li>ehcache-core-2.6.11.jar</li>\n<li>mybatis-ehcache-1.1.0.jar</li>\n</ul>\n<p>设置mapper配置文件中</p>\n<pre><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;\n</code></pre><p>加入ehcache的配置文件ehcache.xml（classpath下）：</p>\n<pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;\n    &lt;diskStore path=&quot;F:\\develop\\ehcache&quot; /&gt;\n    &lt;defaultCache \n        maxElementsInMemory=&quot;1000&quot; \n        maxElementsOnDisk=&quot;10000000&quot;\n        eternal=&quot;false&quot; \n        overflowToDisk=&quot;false&quot; \n        timeToIdleSeconds=&quot;120&quot;\n        timeToLiveSeconds=&quot;120&quot; \n        diskExpiryThreadIntervalSeconds=&quot;120&quot;\n        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;\n    &lt;/defaultCache&gt;\n&lt;/ehcache&gt;\n</code></pre><hr>\n","categories":["mybatis"],"tags":["mybatis"]},{"title":"【flvjs】使用flvjs实现h5控件播放视频、直播流","url":"/2020/05/29/%E3%80%90flvjs%E3%80%91%E4%BD%BF%E7%94%A8flvjs%E5%AE%9E%E7%8E%B0h5%E6%8E%A7%E4%BB%B6%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E3%80%81%E7%9B%B4%E6%92%AD%E6%B5%81/","content":"<blockquote>\n<p>flvjs源码地址：<a href=\"https://github.com/bilibili/flv.js\" target=\"_blank\" rel=\"noopener\">https://github.com/bilibili/flv.js</a></p>\n</blockquote>\n<p>下载下来后，使用进入项目根目录运行</p>\n<pre><code>npm install          # install dev-dependences\nnpm install -g gulp  # install build tool\ngulp release         # packaged &amp; minimized js will be emitted in dist folder\n</code></pre><p>如果遇到flvjs本身的问题需要修改源码，可以去issues里找解决方案，比如我遇到的一个，<a href=\"https://github.com/bilibili/flv.js/pull/448/files#diff-2236408d6aad747aed1a901e3aac73feR120-R125\" target=\"_blank\" rel=\"noopener\"># 播放器在destroy后仍然会下载数据</a>，这个时候就需要修改源码然后运行上面的命令（运行过程中可能会遇到报错，是由于本机的nodejs版本太高，重装旧版本覆盖后即可）。<br>运行完成在根目录会有一个dist文件夹，里面有flv.js、flv.min.js，可以直接丢到项目下使用。</p>\n<p>简单的使用方式，就是先在页面中添加一个video标签，</p>\n<pre><code>&lt;video id=&quot;video1&quot;  style=&quot;object-fit: fill;&quot; muted&gt;&lt;/video&gt;\n</code></pre><p>muted表示静音，且会自动播放。<br>object-fit：fill可以让视频自动填充容器（有浏览器版本限制，部分浏览器不识别）。</p>\n<p>然后新建一个方法</p>\n<pre><code>function videoInit(id, src){\n    var self=this;\n    self.src=src;\n    self.id=id;\n    // 设置属性 type播放类型 url播放链接 isLive是否为直播流 hasAudio是否播放声音 hasVideo是否播放视频 enableStashBuffer开启播放器端缓存\n    // enableWorker浏览器端开启flvjs的worker，多进程运行flvjs\n    self.flvPlayer = flvjs.createPlayer({type: &apos;flv&apos;,url:src,isLive: true,hasAudio: false,hasVideo: true,enableWorker: true, enableStashBuffer: false},{});\n    self.flvPlayer.attachMediaElement(document.getElementById(id));\n    self.flvPlayer.load();\n    self.flvPlayer.play();\n    return self.flvPlayer;\n}\n</code></pre><p>只需要调用该方法，传入id（video控件的id）以及src（播放链接，可以是一个具体的视频链接，也可以是对后台的长连接请求地址，后台实时写流给前台播放）。<br>然后调用时赋值给一个变量<br>flvjs的api文档：<a href=\"https://github.com/bilibili/flv.js/blob/master/docs/api.md\" target=\"_blank\" rel=\"noopener\">https://github.com/bilibili/flv.js/blob/master/docs/api.md</a></p>\n<pre><code>var player = videoInit(&quot;video1&quot;,&quot;xxx&quot;);\n</code></pre><p>想要销毁该播放器，就调用该播放器实例的unload、destroy方法。</p>\n<pre><code>if(null != player){\n    player.unload();\n    player.destroy();\n    player = null;\n}\n</code></pre><hr>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>当一个页面需要播放多个视频时，如果这些视频全部来自同一域名地址，保持长连接时需要注意总请求数不能超过6个。因为大部分浏览器限制对同一域名的请求同时只能保持6个，具体可见：</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/erhei0317/article/details/52614679\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/erhei0317/article/details/52614679</a></p>\n</blockquote>\n<p>火狐浏览器可以自定义该值：</p>\n<ol>\n<li>地址栏输入about:config</li>\n<li>搜索max-persistent-connections-per-server</li>\n<li>显示6，表示每个服务器域名最多保持的长连接数为6，可以自定义修改<br><del>万能的chrome居然硬编码了该值</del></li>\n</ol>\n<p>当请求数超过6个时，后面所有的请求都会被阻塞，等待前面的请求响应结束后才会被服务器接收。</p>\n<hr>\n<p><strong>控件样式调整</strong><br>被公司要求调样式，对我来说比较头疼233，记录下</p>\n<p>需要4个分屏，每个边框为2px，2×2的形式摆放，此外还有选中时的样式（边框颜色）<br>样式设置如下</p>\n<pre><code>.videoPlay4{width:calc(50% - 4px);height:calc(50% - 4px);float:left; border: 2px solid transparent;}\n.videoSelect{border: 2px solid #ffde5c;}\n</code></pre><hr>\n<p>部分浏览器不支持flvjs，可以使用<br><strong>flvjs.isSupported()</strong><br>判断</p>\n<hr>\n<p>return 0；</p>\n","categories":["前端"],"tags":["视频","flvjs"]},{"title":"【mybatis】学习总结(二)","url":"/2018/11/07/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)/","content":"<hr>\n<h2 id=\"动态Sql\"><a href=\"#动态Sql\" class=\"headerlink\" title=\"动态Sql\"></a>动态Sql</h2><p>mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。</p>\n<ul>\n<li><strong>if语句</strong></li>\n</ul>\n<p>在mapper映射文件中可以使用\\<if>标签来对语句接收的参数进行判断，从而动态改变sql语句。</if></p>\n<p>为了避免多次遇到同一段判断代码时的累赘，可以使用<strong>SQL片段</strong>来重复利用代码。<br>如下：</p>\n<pre><code>&lt;sql id=&quot;thereissqlblock&quot;&gt;\n        &lt;if test=&quot;goods!=null and user!=null&quot;&gt;\n            &lt;if test=&quot;user.name!=null and user.name!=&apos;&apos; &quot;&gt;\n                AND user.password=#{goods.price}\n            &lt;/if&gt;\n        &lt;/if&gt;\n&lt;/sql&gt;\n\n&lt;select id=&quot;selectUseIf&quot; parameterType=&quot;userQuery&quot; resultType=&quot;user&quot;&gt;\n    SELECT * FROM USER\n    &lt;where&gt;\n        &lt;include refid=&quot;thereissqlblock&quot;&gt;&lt;/include&gt;\n    &lt;/where&gt;\n&lt;/select&gt;\n</code></pre><p><strong>具体分析：</strong><br>if标签\\&lt;&gt;里的test判断的是输入的参数的值，而\\&lt;&gt;外则是相应的sql语句块（另外，#表示占位符,$为匹配符）。若不符合if test里的条件，则会执行select * from user，及不设置条件会查询出所有记录，若符合，则会把sql片段拼接到原语句。</p>\n<ul>\n<li><strong>foreach语句</strong></li>\n</ul>\n<p>foreach对应sql语句为：</p>\n<pre><code>SELECT * FROM USER WHERE userid=1 OR userid=2 OR userid=3\nSELECT * FROM USER WHERE userid IN(1,2,3)\n</code></pre><p>对于多个对象的输入查询，foreach可以解决遍历参数数组的问题。首先在参数对象中定义一个list集合并生成set和get方法，</p>\n<pre><code>private    List&lt;T&gt; list;\n//set和get方法 \n</code></pre><p>在mapper参数类型parameterType设置为list存放对象类型，接着：</p>\n<pre><code>&lt;if test=&quot;users!=null&quot;&gt;\n    &lt;foreach collection=&quot;users&quot; item=&quot;theuser&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;\n        userid=#{theuser.userid}\n    &lt;/foreach&gt;\n&lt;/if&gt;\n</code></pre><p>使用：</p>\n<pre><code>User user1=new User();\nUser user2=new User();\nuser1.setUserid(1111);\nuser2.setUserid(1112);\nList&lt;User&gt; users=new ArrayList&lt;&gt;();\nusers.add(user1);\nusers.add(user2);\nuserQuery.setUsers(users);\nuserMapper.selectForeach(userQuery).stream().forEach(System.out::println);\n</code></pre><p>即可查出id为1111,1112的俩条记录。</p>\n<hr>\n<h2 id=\"sql的一对一、一对多\"><a href=\"#sql的一对一、一对多\" class=\"headerlink\" title=\"sql的一对一、一对多\"></a>sql的一对一、一对多</h2><p>定义表，orders：订单，custom：用户。外键关联<br>一个用户可发起多个订单，一个订单对应一个用户。<br>在对应类里添加属性。<br>orders:private Custom custom；<br>custom:private List\\<orders> orders;</orders></p>\n<ul>\n<li><strong>一对一：</strong></li>\n</ul>\n<pre><code>订单对用户为一对一关系，则根据订单查用户有如下几种方法：\n</code></pre><ol>\n<li><p>创建一个新类继承Orders,在该类里添加custom的属性并生成set和get方法。然后直接使用该类查询即可，实际应用中应该加上一个输入的参数ordersid<del>这里我懒没加</del></p>\n<pre><code>&lt;mapper namespace=&quot;com.me.mapper.OrdersMapper&quot;&gt;\n    &lt;select id=&quot;findCO&quot; resultType=&quot;customOrders&quot;&gt;\n        SELECT custom.*,orders.* FROM custom,orders WHERE orders.customid=custom.id\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre></li>\n<li>上面方法是在没有设置private Custom custom属性时候用的，所以其实可以直接把resultType改成orders，但得不到custom对象，不会把写在mapper里的custom.*映射到orders里的custom属性。</li>\n<li><p>怎么解决2的问题呢？使用resultMap添加association标签关联即可解决</p>\n<pre><code>&lt;resultMap type=&quot;orders&quot; id=&quot;resultmap1&quot;&gt;\n    &lt;id column=&quot;orderid&quot; property=&quot;orderid&quot; /&gt;\n    &lt;result column=&quot;thing&quot; property=&quot;thing&quot;/&gt;\n    &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;\n    &lt;association property=&quot;custom&quot; javaType=&quot;com.me.domain.Custom&quot;&gt;\n        &lt;id column=&quot;customid&quot; property=&quot;id&quot;/&gt;\n        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;\n        &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;\n        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;\n    &lt;/association&gt;\n&lt;/resultMap&gt;\n&lt;select id=&quot;findCCO&quot; resultMap=&quot;resultmap1&quot;&gt;\n    SELECT orders.*,custom.* FROM custom,orders WHERE orders.customid=custom.id\n&lt;/select&gt;\n</code></pre><p>这里，在resultMap里少添加或者在select后面少写一项属性，得到的对象属性就会少一项属性的值（<del>所以不要偷懒少写属性</del>）。</p>\n</li>\n</ol>\n<hr>\n<ul>\n<li><strong>一对多：</strong></li>\n</ul>\n<p>上面的一对一反过来，问题就变成了一对多，即一个custom对应多个orders。<br>对于一对多关系，我直接介绍最有效率的方法：<br>使用resultMap：</p>\n<pre><code>&lt;resultMap type=&quot;custom&quot; id=&quot;ccus&quot;&gt;\n    &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;\n    &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;\n    &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;\n    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;\n    &lt;collection property=&quot;orders&quot; ofType=&quot;com.me.domain.Orders&quot;&gt;\n        &lt;id column=&quot;order_id&quot; property=&quot;orderid&quot;/&gt;\n        &lt;result column=&quot;thing&quot; property=&quot;thing&quot; /&gt;\n        &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;\n    &lt;/collection&gt;\n&lt;/resultMap&gt;\n&lt;select id=&quot;selectCus&quot; resultMap=&quot;ccus&quot;&gt;\n    SELECT c.*,o.orderid order_id,o.thing,o.customid FROM custom c,orders o WHERE c.id=o.customid\n&lt;/select&gt;\n</code></pre><p>注意这里是collection，执行后会把符合条件的orders一条一条映射到custom的list\\<orders>属性。</orders></p>\n<p><strong>注意事项：</strong>如果关联表中有列名和主表列名相同，必须要设置别名，否则查询结果会有问题。</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/xzm_rainbow/article/details/15336933\" target=\"_blank\" rel=\"noopener\">具体可以看这里</a></p>\n</blockquote>\n<hr>\n<ul>\n<li><strong>多对多：</strong></li>\n</ul>\n<p><a href=\"http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/\">具体看这篇</a></p>\n","categories":["mybatis"],"tags":["mybatis"]},{"title":"【mybatis】逆向工程及详解","url":"/2018/11/17/%E3%80%90mybatis%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8F%8A%E8%AF%A6%E8%A7%A3/","content":"<p>逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理<a href=\"https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433?fr=aladdin\" target=\"_blank\" rel=\"noopener\">^1</a>。</p>\n<hr>\n<ol>\n<li><p>最好先创建一个新的空项目</p>\n</li>\n<li><p>引入Maven依赖</p>\n</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwaecl9jgvj308w038dfr.jpg\" alt=\"\"></p>\n<ol start=\"3\">\n<li>创建逆向工程配置文件</li>\n<li><p>文件配置内容</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;\n  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;\n\n&lt;generatorConfiguration&gt;\n    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;\n        &lt;commentGenerator&gt;\n            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;\n            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;\n        &lt;/commentGenerator&gt;\n        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;\n        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;\n            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatist&quot; \n            userId=&quot;root&quot;\n            password=&quot;olonn&quot;&gt;\n        &lt;/jdbcConnection&gt;\n        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;\n            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; \n            userId=&quot;yycg&quot;\n            password=&quot;yycg&quot;&gt;\n        &lt;/jdbcConnection&gt; --&gt;\n\n        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n            NUMERIC 类型解析为java.math.BigDecimal --&gt;\n        &lt;javaTypeResolver&gt;\n            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;\n        &lt;/javaTypeResolver&gt;\n\n        &lt;!-- targetProject:生成PO类的位置 --&gt;\n        &lt;javaModelGenerator targetPackage=&quot;com.me&quot;\n            targetProject=&quot;.\\src&quot;&gt;\n            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;\n            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;\n        &lt;/javaModelGenerator&gt;\n        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;\n        &lt;sqlMapGenerator targetPackage=&quot;com.mapper&quot; \n            targetProject=&quot;.\\src&quot;&gt;\n            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n        &lt;/sqlMapGenerator&gt;\n        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;\n        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;\n            targetPackage=&quot;com.mapper&quot; \n            targetProject=&quot;.\\src&quot;&gt;\n            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;\n            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;\n        &lt;/javaClientGenerator&gt;\n        &lt;!-- 指定数据库表 --&gt;\n        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;\n        &lt;table tableName=&quot;buser&quot;&gt;&lt;/table&gt;\n        &lt;table tableName=&quot;bcard&quot;&gt;&lt;/table&gt;\n        &lt;table tableName=&quot;ctou&quot;&gt;&lt;/table&gt;\n        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;\n        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;\n        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;\n        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;\n        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;\n\n        &lt;!-- 有些表的字段需要指定java类型\n         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;\n            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;\n        &lt;/table&gt; --&gt;\n    &lt;/context&gt;\n&lt;/generatorConfiguration&gt;\n</code></pre></li>\n<li><p>创建一个类用来运行生成文件</p>\n<pre><code>package com.mapper;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\n\npublic class Zzz {\n\n    public void generate() throws Exception {\n        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();\n        boolean overwrite = true;\n        File configFile = new File(&quot;src/main/resources/GeneratorConfig.xml&quot;);\n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\n        myBatisGenerator.generate(null);\n    }\n\n    public static void main(String[] args) throws Exception {\n        try {\n            Zzz zzz=new Zzz();\n            zzz.generate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre></li>\n</ol>\n<p>注意配置文件的目录，相对根路径是从项目根目录开始的。运行即可。</p>\n<p>运行完刷新目录，见：<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwael724nzj306s0av0sx.jpg\" alt=\"\"></p>\n<p>我们就得到了想要的Mapper接口、配置文件和pojo类。</p>\n<hr>\n<hr>\n<p>select主要通过criteria对象<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwafj73fpkj30ds02jdfu.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwafimt96uj305n06hglo.jpg\" alt=\"\"></p>\n<hr>\n<p>总的来说，还是非常方便的。</p>\n","categories":["mybatis"],"tags":["mybatis","逆向工程"]},{"title":"【redis】windows环境和linux环境下的安装使用","url":"/2019/01/24/%E3%80%90redis%E3%80%91windows%E7%8E%AF%E5%A2%83%E5%92%8Clinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>首先，贴上官方网站地址，可以在这查询官方文档、命令等等。</p>\n<blockquote>\n<p><a href=\"https://redis.io/\" target=\"_blank\" rel=\"noopener\">https://redis.io/</a><br>中文版<br><a href=\"http://redis.cn/\" target=\"_blank\" rel=\"noopener\">http://redis.cn/</a></p>\n</blockquote>\n<p>redis是非关系型数据库，运行于内存中，当项目需要请求数据库时会先查询redis数据库，以减轻主库的访问压力。</p>\n<p>属于非关系型数据库NOSQL的redis没有固定的列与值的表形式。<br>NOSQL=NOT ONLY SQL</p>\n<hr>\n<h2 id=\"windows下安装redis\"><a href=\"#windows下安装redis\" class=\"headerlink\" title=\"windows下安装redis\"></a>windows下安装redis</h2><p>redis的作者并没有写适合在windows下运行的redis数据库，微软为了让更多的用户使用windows系统，自己对redis进行了修改，建造了适合在windows下运行的redis。而平时使用在服务器端的都是在linux下运行的redis，所以windows下的redis仅适合用来开发学习。</p>\n<p>下载网站：</p>\n<blockquote>\n<p><a href=\"https://github.com/MicrosoftArchive/redis/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/MicrosoftArchive/redis/releases</a></p>\n</blockquote>\n<p>下载后解压到自选目录，运行<br>redis-server.exe文件见下图即表示运行成功<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhhrts2c9j30qu0b90t2.jpg\" alt=\"\"></p>\n<hr>\n<p>双击redis-cli.exe运行客户端工具</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhhtpdn8uj30hr0670ss.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"Linux下安装redis\"><a href=\"#Linux下安装redis\" class=\"headerlink\" title=\"Linux下安装redis\"></a>Linux下安装redis</h2><p>打开官网下载压缩包</p>\n<p>安装gcc编译器，可以用来编译运行c语言文件</p>\n<pre><code>yum -y install gcc\n</code></pre><p>？好像不是这样装的，我以前装过所以不用再装</p>\n<p>把下好的压缩包解压</p>\n<pre><code>tar -zxvf 压缩包\n</code></pre><p>进入解压后的目录<br>运行make命令<br>这个时候会把目录下的C程序全部编译运行，等待运行结束出现下图<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhoh6e39xj31ue0lc1kx.jpg\" alt=\"\"></p>\n<p>这个时候就能进入src目录，里面有和上面windows名字差不多的可执行命令文件</p>\n<p>如redis-server和redis-cli等</p>\n<hr>\n<p>若想在任意目录运行这些命令<br>要么运行时前面加上路径<br>要么<br>进入src目录<br>运行</p>\n<pre><code>sudo make install\n</code></pre><p>命令</p>\n<p>相当于把redis的命令配置在环境变量中，在任何目录都可使用</p>\n<hr>\n","categories":["数据库"],"tags":["redis"]},{"title":"【maven】maven使用中遇到的问题记录","url":"/2020/04/09/%E3%80%90maven%E3%80%91maven%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"<p>依赖冲突<br>如下图<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/c2452a216212113b.png\" alt=\"\"><br>解决，去除该依赖下冲突的包</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.flowable&lt;/groupId&gt;\n    &lt;artifactId&gt;flowable-spring-boot-starter-process&lt;/artifactId&gt;\n    &lt;version&gt;${flowable.version}&lt;/version&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.flowable&lt;/groupId&gt;\n            &lt;artifactId&gt;flowable-dmn-api&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><hr>\n<p>子模块的引入</p>\n<pre><code>&lt;modules&gt;\n    &lt;module&gt;ssm-service&lt;/module&gt;\n    &lt;module&gt;ssm-web&lt;/module&gt;\n&lt;/modules&gt;\n</code></pre><p>子模块有父模块定义的依赖，无需重复导入<br>依赖版本管理</p>\n<pre><code>&lt;properties&gt;\n    &lt;springframework.version&gt;5.1.9.RELEASE&lt;/springframework.version&gt;\n&lt;/properties&gt;\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n        &lt;version&gt;${springframework.version}&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><p>使用变量统一管理多个依赖</p>\n<p>可以使用一个子模块依赖另一个子模块</p>\n<pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;xff&lt;/groupId&gt;\n        &lt;artifactId&gt;ssm-service&lt;/artifactId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><p>如若项目运行报错，找不到依赖的子模块的bean，需要做下图操作<br><img src=\"https://ftp.bmp.ovh/imgs/2020/04/c70f14a8fdea9188.png\" alt=\"\"></p>\n","categories":["errors"],"tags":["maven"]},{"title":"【redis】jedis使用","url":"/2019/01/25/%E3%80%90redis%E3%80%91jedis%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"使用jedis访问redis数据库\"><a href=\"#使用jedis访问redis数据库\" class=\"headerlink\" title=\"使用jedis访问redis数据库\"></a>使用jedis访问redis数据库</h2><p>创建个maven项目JedisDemo</p>\n<p>引入依赖</p>\n<pre><code>&lt;dependencies&gt;  \n     &lt;dependency&gt; \n        &lt;groupId&gt;redis.clients&lt;/groupId&gt;  \n         &lt;artifactId&gt;jedis&lt;/artifactId&gt;  \n         &lt;version&gt;2.9.0&lt;/version&gt;  \n     &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><p>创建个类连接</p>\n<pre><code>import redis.clients.jedis.Jedis;  \n\nimport java.util.HashMap;  \nimport java.util.List;  \nimport java.util.Set;  \n\npublic class DemoTest {  \n\n    public static void main(String[] args) {  \n        String host=&quot;127.0.0.1&quot;;  \n     int port=6379;  \n  Jedis jedis=new Jedis(host,port);  \n  //jedis.auth(&quot;password&quot;);  \n\n //字符串类型  System.out.println(&quot;字符串&quot;);  \n  System.out.println(jedis.get(&quot;haha&quot;));  \n\n  //hash类型  \n  System.out.println(&quot;hashmap&quot;);  \n  HashMap&lt;String,String&gt; map= (HashMap&lt;String, String&gt;) jedis.hgetAll(&quot;mymap&quot;);  \n  System.out.println(map.get(&quot;name&quot;)+&quot; &quot;+map.get(&quot;age&quot;));  \n\n  //list类型  \n  System.out.println(&quot;List类型&quot;);  \n  List alist=jedis.lrange(&quot;mylist&quot;,0,-1);  \n  alist.stream().forEach(System.out::println);  \n\n  //set类型  \n  System.out.println(&quot;set类型&quot;);  \n  Set myset=jedis.smembers(&quot;myset&quot;);  \n  myset.stream().forEach(System.out::println);  \n\n  //zset类型  \n  System.out.println(&quot;zset类型&quot;);  \n  Set myzset=jedis.zrangeByScore(&quot;myzset&quot;,&quot;30&quot;,&quot;50&quot;);  \n  myzset.stream().forEach(System.out::println);  \n  }  \n}\n</code></pre><p>输出</p>\n<pre><code>字符串\nllxizayyyy\nhashmap\nlili 5\nList类型\na\na\nk\nj\ni\nh\ng\nf\nzzz\ne\nd\nc\nb\na\nset类型\nj\nl\ng\nn\na\nd\nh\nzset类型\ntom\nxiaoming\nhuhu\n</code></pre><p>访问redis成功，可以看到方法名和我们在redis控制台使用的命令一致。</p>\n<hr>\n<hr>\n<h2 id=\"使用RedisPool\"><a href=\"#使用RedisPool\" class=\"headerlink\" title=\"使用RedisPool\"></a>使用RedisPool</h2><pre><code>import redis.clients.jedis.JedisPool;  \nimport redis.clients.jedis.JedisPoolConfig;  \n\npublic class JedisUtils {  \n\n    private static JedisPool jedisPool;  \n\n public static JedisPool open(String ip,int port){  \n        JedisPoolConfig config=new JedisPoolConfig();  \n\n  //设置最大线程数  \n  config.setMaxTotal(20);  \n\n  //设置最大空闲数  \n  config.setMaxIdle(2);  \n\n  //设置检查项为true  \n  config.setTestOnBorrow(true);  \n\n  //  \n  jedisPool=new JedisPool(config,ip,port,5000,&quot;password&quot;);  \n\n return jedisPool;  \n  }  \n\n    public static void close(){  \n        if(jedisPool!=null){  \n            jedisPool.close();  \n  }  \n    }  \n}\n</code></pre><p>使用</p>\n<pre><code>JedisPool pool = null;  \nJedis myjedis=null;  \ntry{  \n    pool=JedisUtils.open(host,port);  \n  myjedis=pool.getResource();  \n  //使用jedis操作  \n}finally {  \n    if(jedis!=null){  \n        jedis.close();  \n  }  \n}\n</code></pre><hr>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>只需要声明一个<br>Transaction类<br>Transaction trans=jedis.multi();<br>xxxx<br>xxx<br>xx<br>xxxx<br>xx<br>然后trans.exec()返回一个list集合，里面是事务语句的结果</p>\n","categories":["数据库"],"tags":["jedis","java"]},{"title":"【redis】可视化工具以及一些基本命令对5种类型操作","url":"/2019/01/25/%E3%80%90redis%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%AF%B95%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C/","content":"<ol>\n<li><a href=\"#id1\">redis可视化工具安装</a></li>\n<li><a href=\"#id2\">redis-cli命令</a></li>\n<li><a href=\"#id3\">Key的五种数据类型</a></li>\n<li><p>基本命令</p>\n<ul>\n<li><p><a href=\"#id4\">字符串类型</a></p>\n</li>\n<li><p><a href=\"#id5\">哈希类型hash</a></p>\n</li>\n<li><p><a href=\"#id6\">列表list</a></p>\n</li>\n<li><p><a href=\"#id7\">集合类型set</a></p>\n</li>\n<li><p><a href=\"#id8\">有序集合zset</a></p>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>redis关闭<br>./redis-cli shutdown<br>kill 进程</p>\n<p>连接指定地址的redis<br>./redis-cli -h 127.0.0.1 -p 6379</p>\n<p><span id=\"id1\"></span></p>\n<h2 id=\"redis-desktop-manager\"><a href=\"#redis-desktop-manager\" class=\"headerlink\" title=\"redis desktop manager\"></a>redis desktop manager</h2><p>redis的可视化管理工具<br>download</p>\n<blockquote>\n<p><a href=\"https://pan.baidu.com/s/1kU8sY3P\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1kU8sY3P</a><br>官网<br><a href=\"https://redisdesktop.com/download\" target=\"_blank\" rel=\"noopener\">https://redisdesktop.com/download</a><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhprjmfjgj30ue0hyjsn.jpg\" alt=\"\"></p>\n</blockquote>\n<hr>\n<p>需要连接网络上的redis时，需要修改服务器上的redis.conf配置文件，首先注释<br>bind 127.0.0.1<br>这行<br>然后将下面的protocol保护yes改为no<br>启动时命令后面加上conf属性作为参数</p>\n<hr>\n<hr>\n<p><span id=\"id2\"></span></p>\n<h2 id=\"redis-cli命令\"><a href=\"#redis-cli命令\" class=\"headerlink\" title=\"redis-cli命令\"></a>redis-cli命令</h2><p><strong>ping</strong>查看redis服务是否正常运行，返回PONG代表正常</p>\n<p><strong>DBSIZE</strong>查看当前数据库的key数量</p>\n<p>redis默认使用16个库，可以通过修改配置文件修改数量</p>\n<p>通过<strong>select</strong> db切换库</p>\n<p><strong>flushdb</strong>清空库里的内容</p>\n<p>退出client工具：<strong>exit</strong></p>\n<p><strong>keys</strong> pattern查找符合pattern匹配的key（尽量不使用key *，redis单线程接收请求，若key过多，会给redis造成很大压力）</p>\n<p>exists key [keys…]<br>判断该key是否存在</p>\n<p>expire key seconds<br>设置key的存活时间，超过时间就删除<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhr6o7r3hj30bg048t8l.jpg\" alt=\"\"></p>\n<p>ttl key<br>查看该key存活剩余时间（”验证码超时作废”）</p>\n<p>type key<br>返回key类型</p>\n<p>del key [keys]<br>删除对应的key，并返回删除成功的个数</p>\n<hr>\n<p><span id=\"id3\"></span></p>\n<h2 id=\"Key的五种数据类型\"><a href=\"#Key的五种数据类型\" class=\"headerlink\" title=\"Key的五种数据类型\"></a>Key的五种数据类型</h2><ol>\n<li><p>字符串类型<br>k1 value</p>\n</li>\n<li><p>hash类型map<br> HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;();<br> k1 data</p>\n<p> 其中k1称为key，data里的key称为field</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>列表类型list<br> k1 [value1，value2，value3]<br> 下标012     </li>\n</ol>\n<ol start=\"4\">\n<li><p>集合类型set<br> 无序，元素不重复</p>\n</li>\n<li><p>有序集合类型zset<br> 有序set集合</p>\n</li>\n</ol>\n<hr>\n<h1 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h1><p><span id=\"id4\"></span></p>\n<h2 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h2><p>set key value<br>相当于sql里的saveorupdate</p>\n<p>get key<br>获取key对应的value</p>\n<p>incr key<br>对key的value值加1，只能对数字类型，如果key不存在，则创建该key初始化key值为0再加1</p>\n<p>decr key<br>减一，其他同上</p>\n<p>append key value<br>如果key存在，则将value追加到原值末尾<br>否则新建该key</p>\n<p>strlen key<br>求key对应的字符串长度</p>\n<p>getrange key start end<br>取字符串子串，下标从0开始，从右往左的话最右边是-1<br>取的时候小的下标在左</p>\n<p>setrange key start value<br>从start开始用value去替换key的value值，替换长度为value 的长度</p>\n<p>mset k1 v1 k2 v2 k3 v3…<br>复数个keyvalue的定义</p>\n<p>mget k1 k2 k3…<br>复数个key 的获取</p>\n<hr>\n<hr>\n<p><span id=\"id5\"></span></p>\n<h2 id=\"哈希类型hash\"><a href=\"#哈希类型hash\" class=\"headerlink\" title=\"哈希类型hash\"></a>哈希类型hash</h2><p>hset key field value<br>存入值<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzht5aei1kj30ak02xt8k.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzht5t6jr9j30dg02pwea.jpg\" alt=\"\"></p>\n<p>hget key field<br>获取该key下的field对应的值</p>\n<p>hmset<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzht77o10aj30dc00qwe9.jpg\" alt=\"\"></p>\n<p>hmget key field1 field2….<br>获取多个field值</p>\n<p>hgetall<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzht8tmz26j307c02fa9u.jpg\" alt=\"\"></p>\n<p>hkeys key<br>获取该key下的所有field</p>\n<p>hvals key<br>获取该key下的所有value</p>\n<p>hexists key field<br>查询key下是否存在该field</p>\n<hr>\n<p><span id=\"id6\"></span></p>\n<h2 id=\"列表list\"><a href=\"#列表list\" class=\"headerlink\" title=\"列表list\"></a>列表list</h2><p>lpush key value1 value2 …<br>将value一个一个插入到key表头的头部</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhtcfpyvcj309v0180si.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhtcwb9okj30bu03pt8i.jpg\" alt=\"\"></p>\n<p>rpush key value…<br>从尾部插入</p>\n<p>lrange key start end<br>查询下标从start到end结束的元素</p>\n<p>lindex key index<br>查询下标为index 的元素</p>\n<p>llen key<br>查询key对应的list 的长度</p>\n<p>lrem key count value<br>若count&gt;0则从表左到右进行删除，删除count个与value相同的值。count若为负则相反。count=0则删除全部value值。</p>\n<p>lset key index value<br>将index下标的值替换为value，下标超出范围就报错</p>\n<p>linsert key BEFORE|AFTER pivot value<br>在pivot参考值前或者后面插入value值</p>\n<hr>\n<p><span id=\"id7\"></span></p>\n<h2 id=\"集合类型set\"><a href=\"#集合类型set\" class=\"headerlink\" title=\"集合类型set\"></a>集合类型set</h2><p>sadd key member…<br>将一个或多个元素添加到set集合中</p>\n<p>smembers key<br>获取key里的所有成员元素</p>\n<p>sismember key member<br>检查key对应集合里有无member元素</p>\n<p>scard key<br>查询该set集合里有多少元素</p>\n<p>srem key members…<br>删除该set集合里的member</p>\n<p>srandmember key count<br>随机显示count个元素，不指定count默认1</p>\n<p>spop key count<br>随机删除count个元素，不指定默认1</p>\n<hr>\n<p><span id=\"id8\"></span></p>\n<h2 id=\"有序集合zset\"><a href=\"#有序集合zset\" class=\"headerlink\" title=\"有序集合zset\"></a>有序集合zset</h2><p>zadd key score member…<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzhu85lwg5j30i500l3ya.jpg\" alt=\"\"><br>score表示分数，member表示value，分数是用来排序的<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzikrg9cnkj30gs06faa3.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzikrwmxu4j30dt04rt8k.jpg\" alt=\"\"></p>\n<p>zrange key start end [withscores]<br>显示下标从start到end的值，从小到大显示，若加上withscores会连分数一起显示<br>（同样可以从后往前用负值查询）</p>\n<p>zrevrange key start end [withscores]<br>同上，但是是按分数从大到小显示<br>0下标对应最大的分数</p>\n<p>zrem key member …<br>删除key里对应的member</p>\n<p>zcard key<br>获取key元素个数</p>\n<p>zrangebyscore key min max [withscores] [LIMIT offset count]<br>通过分数范围获取key里的值，offset表示从第几个结果开始，count表示输出几项数据</p>\n<p>zrevrangebyscore<br>和上面相反顺序</p>\n<p>zcount key min max<br>返回分数在min和max之间的结果有几个</p>\n<hr>\n","categories":["数据库"],"tags":["redis"]},{"title":"【redis】高级话题","url":"/2019/01/25/%E3%80%90redis%E3%80%91%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/","content":"<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><p>multi<br>标记一个事务的开始，多条命令会按照先后顺序放进一个队列中，总返回OK</p>\n<p>exec<br>执行所有事务块的命令<br>事务内的所有执行语句内容，事务被打断返回nil</p>\n<p>discard<br>（当事务队列内的语句写到一半不想写了）取消事务，放弃事务内的所有命令，总返回OK</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzimisoa19j309b09t74c.jpg\" alt=\"\"></p>\n<p>当遇到语法错误时，事务就会被放弃</p>\n<p>当语法没错，但执行会出错时，redis不会回滚，前面正确的命令会正常执行</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzimsqu0h8j30fi094t8v.jpg\" alt=\"\"></h2><p>watch key…<br>监视一个或多个key，如果在事务执行前这些key被其他命令所改动，那么事务将会被打断。总是返回OK</p>\n<p>unwatch<br>取消watch命令对所有key的监视</p>\n<p>比如这里我对k5这个key添加监视，然后在可视化工具里修改k5的值<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzin0nu83hj30es043jr8.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzimzllvzxj309305mjra.jpg\" alt=\"\"></p>\n<p>可以看到事务执行失败。</p>\n<hr>\n<h1 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h1><p>单保存在内存中，若突然系统问题出现关机，会导致数据丢失，所以保存在硬盘中能保证数据安全。</p>\n<h2 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h2><p>Redis Database（RDB），数据快照写入磁盘。<br>保存数据是在单独的进程中写文件，不会影响Redis的正常使用。RDB恢复数据比其他AOF（将命令写入日志）速度快</p>\n<p>在配置文件redis.conf中搜索SNAPSHOTTING可以看到关于RDB的配置说明。配置Redis生成快照文件的时间策略，格式如下</p>\n<pre><code>save &lt;seconds&gt; &lt;changes&gt;\n</code></pre><p>表示在seconds秒内至少发生了changes个key的改动这一条件被满足时，就会启动生成保存</p>\n<p>在配置文件中有如下三列默认配置</p>\n<pre><code>save 900 1\nsave 300 10\nsave 60 10000\n</code></pre><p>另外，<br>dbfilename属性对应RDB的文件名，默认为dump.rdb<br>dir指定RDB文件的存储位置，默认为./，当前目录<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzinigak8wj30f609pwfi.jpg\" alt=\"\"></p>\n<p>缺点：会丢失未满足条件而发生保存的数据。<br>优点：性能高。</p>\n<h2 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h2><p>如果不想有丢失数据的风险，采用AOF方式<br>每次接收到一条改变数据的命令时，就会把该命令写到一个AOF文件中，当redis重启时，可以通过执行AOF中的所有命令恢复数据</p>\n<p>AOF功能默认为关闭状态，需要在redis.conf文件中配置</p>\n<ul>\n<li>appendonly：默认是no，改成yes即为开启</li>\n<li>appendfilename：指定AOF文件名，默认为appendonly.aof</li>\n<li>dir：指定RDB和AOF文件存放的目录</li>\n<li>appendfsync：配置向aof文件写命令数据的策略<ul>\n<li>no：不主动进行同步，而是完全交由操作系统来做（30秒一次），比较快但是不安全</li>\n<li>always：每次执行写入都会执行同步，慢一点，安全</li>\n<li>everysec：每秒执行一次，比较平衡，默认为这个</li>\n</ul>\n</li>\n<li>auto-aof-rewrite-min-size：允许重写的最小AOF文件大小，默认为64M，当超过此大小时整理aof文件，去掉无用的命令（比如说重复赋值）</li>\n<li></li>\n</ul>\n<p>若因某条命令让redis关闭，重启前可以对aof文件修改，删除这条命令，重启redis会自动执行该文件中的命令恢复数据</p>\n<hr>\n<h1 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h1><p>为了避免单点故障，需要将数据复制多份到多台不同的服务器上，当有一台服务器上的数据更新后，自动将更新的数据同步到其他的服务器上。</p>\n<h2 id=\"读写分离\"><a href=\"#读写分离\" class=\"headerlink\" title=\"读写分离\"></a>读写分离</h2><p>将redis服务器集群分为一个主服务器和一些从服务器，主服务器复制进行写操作并把写入的数据实时同步到从服务器，从服务器负责用于读操作。</p>\n<p>实现</p>\n<p>复制三份配置文件，修改不同的端口号，运行redis-server时带上配置文件的参数，即可模拟多台redis服务器的环境。</p>\n<p>配置主redis服务器（Master）<br>在空文件中加入下面内容</p>\n<ul>\n<li>include 原来的配置文件路径   //表示引入之前的配置</li>\n<li>daemonize yes //让redis后台启动</li>\n<li>port XXXx //指定端口号</li>\n<li>pidfile /var/run/redis_xxxx.pid //linux下给进程分配id</li>\n<li>logfile xxxx.log //日志文件</li>\n<li>dbfilename xxxxxx.rdb //rdb文件</li>\n</ul>\n<p>配置从redis服务器（Slave）<br>加入如下内容</p>\n<ul>\n<li>include 原来的配置文件路径 //表示引入之前的配置</li>\n<li>daemonize yes //让redis后台启动</li>\n<li>port XXXx //指定端口号</li>\n<li>pidfile /var/run/redis_xxxx.pid //linux下给进程分配id</li>\n<li>logfile xxxx.log //日志文件</li>\n<li>dbfilename xxxxxx.rdb //rdb文件</li>\n<li><strong>slaveof ipaddress port  //ipaddress指向主服务器的IP地址，port指定端口号</strong></li>\n</ul>\n<p><strong>info replication命令可以查看当前的服务器的状态信息</strong></p>\n<p>不能在从服务器Slave上进行写操作，会提示操作失败。</p>\n<h2 id=\"容灾处理\"><a href=\"#容灾处理\" class=\"headerlink\" title=\"容灾处理\"></a>容灾处理</h2><p>当Master服务出现故障，需手动将slave中的一个提升为master，剩下的slave挂至新的master上</p>\n<p>步骤</p>\n<ol>\n<li>停掉故障的master服务</li>\n<li>选一台slave升级到master，运行命令    </li>\n</ol>\n<pre><code>slaveof no one\n</code></pre><ol start=\"3\">\n<li>切换到其他slave服务器的客户端，运行命令</li>\n</ol>\n<pre><code>    slaveof ipaddress port\n\n指定新的master服务地址\n</code></pre><hr>\n<p>redis官方提供了解决问题的高可用方案</p>\n<h2 id=\"Sentinel\"><a href=\"#Sentinel\" class=\"headerlink\" title=\"Sentinel\"></a><strong>Sentinel</strong></h2><p>哨兵（多个单独运行）<br>它有三个主要任务</p>\n<ul>\n<li>监控：心跳检测主服务器是否正常工作</li>\n<li>提醒：提醒管理员</li>\n<li>自动故障转移 ：转换master</li>\n<li>当检测到主redis服务器master出现故障，会在哨兵中（总共奇数个）产生一次投票，半数以上检测到故障时就会运行后面两个任务。</li>\n</ul>\n<p>配置：<br>同样是改配置文件，ip地址什么的，大同小异</p>\n<hr>\n<h1 id=\"安全设置\"><a href=\"#安全设置\" class=\"headerlink\" title=\"安全设置\"></a>安全设置</h1><p><strong>访问Redis默认没有密码，这样不安全，可以通过修改redis.conf配置文件设置密码</strong><br><strong>requirepass</strong>对应的就是密码<br>设置密码后用客户端工具cli登陆</p>\n<p>需要在后面添加<br>-a password<br>参数登陆<br>或者使用auth password</p>\n<p><strong>绑定ip</strong><br>同样是配置文件<br>bind这项对应的就是允许访问你redis的ip地址，默认bind 127.0.0.1，只允许本机访问。若想允许多个ip地址可以用空格分隔。</p>\n<p><strong>修改端口</strong><br>使用默认的端口比较危险，在配置文件中把<br>port xxxx<br>这行端口修改为自己可以指定的端口，范围是1024-65535</p>\n<p>使用<br>./redis-cli -p xxxx<br>指定端口号启动</p>\n","categories":["数据库"],"tags":["redis"]},{"title":"【java】使用jsonp请求并解析网页元素内容，爬取网站热点数据","url":"/2020/05/09/%E3%80%90java%E3%80%91%E4%BD%BF%E7%94%A8jsonp%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%92%8C%E5%86%85%E5%AE%B9%EF%BC%8C%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/","content":"<p>org.jsonp这个包里的类可以用来对网页请求，然后获取请求返回的网页或者是json字符串。</p>\n<pre><code>Document doc = null;  \nConnection connection = Jsoup.connect(url);  \nconnection.header(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);  \nconnection.header(&quot;Accept-Encoding&quot;, &quot;gzip, deflate, br&quot;);  \nconnection.header(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.5&quot;);  \nconnection.header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0&quot;);\nif (headers != null)  \n{  \n    connection.headers(headers);  \n}  \ntry  \n{  \n    doc = connection.timeout(10 * 1000).get();  \n}  \ncatch (IOException e)  \n{  \n    log.error(&quot;Fail to connect!&quot;, e);  \n}  \nreturn doc;\n</code></pre><hr>\n<p>如果网页返回的为json字符串：</p>\n<pre><code>String json = null;\ntry\n{\n    json = Jsoup.connect(url).ignoreContentType(true).execute().body();\n}\ncatch (IOException e)\n{\n    log.error(&quot;Fail to connect the website!&quot;, e);\n}\nreturn json;\n</code></pre><hr>\n<pre><code>import com.jayway.jsonpath.JsonPath;\nList&lt;String&gt; titles = JsonPath.read(jsonStr, &quot;$.rankList.[*].title&quot;);\n</code></pre><p>使用该JsonPath工具类可以读取json字符串<br>如上的使用方法为读取jsonStr该json字符串下的，rankList数组里所有元素的title值，然后放到一个list里面。</p>\n<hr>\n<h2 id=\"实例演示\"><a href=\"#实例演示\" class=\"headerlink\" title=\"实例演示\"></a>实例演示</h2><p>获取ACFUN的排行榜视频标题以及链接，放到一个列表里去：</p>\n<p>首先去acfun官网排行榜页面找获取排行榜数据的请求，<br><img src=\"https://s1.ax1x.com/2020/05/09/YQvTYT.png\" alt=\"YQvTYT.png\"><br>得知该请求方式返回一个很长的json数据。<br>复制下来使用notepad++格式化后可以看到这样的数据层次：</p>\n<pre><code>{\n    &quot;result&quot;: 0,\n    &quot;host-name&quot;: &quot;hb2-acfun-kcs085.aliyun&quot;,\n    &quot;rankList&quot;: [\n        {\n            &quot;groupId&quot;: &quot;Ml8wXzE1ODkwMTEyMjQ0NTVfNTY_1&quot;,\n            &quot;userId&quot;: 233486,\n            &quot;dougaId&quot;: &quot;15402363&quot;,\n            &quot;channelId&quot;: 86,\n            &quot;videoCover&quot;: &quot;https://tx-free-imgs.acfun.cn/content/2020_05_08/1588922111122.JPG?imageslim&quot;,\n            &quot;userImg&quot;: &quot;https://tx-free-imgs.acfun.cn/style/image/201907/tXEU6GKinPO0cygwHbmOU7DAsfw1iPvU.jpg?imageslim&quot;,\n            &quot;fansCount&quot;: 15747,\n            &quot;channelName&quot;: &quot;生活日常&quot;,\n            &quot;contentId&quot;: 15402363,\n            &quot;isFollowing&quot;: false,\n            &quot;contributionCount&quot;: 50,\n            &quot;danmuCount&quot;: 993,\n            &quot;contentTitle&quot;: &quot;MC石头：成年人的悲哀&quot;,\n            &quot;contentDesc&quot;: &quot;生活中总有那么一些成年后的烦恼，慢慢的就习惯了。Vx：mcfanjian QQ：337845818&quot;,\n            &quot;userSignature&quot;: &quot;Vx号mcfanjian，扣扣337845818，粉丝q群138836999，网易云：MC石头&quot;,\n            &quot;contributeTime&quot;: 1588924233279,\n            &quot;userName&quot;: &quot;MC石头&quot;,\n            &quot;contentType&quot;: 2,\n            &quot;duration&quot;: 62920,\n            &quot;durationMillis&quot;: 62920,\n            &quot;likeCount&quot;: 1641,\n            &quot;createTime&quot;: &quot;24小时前&quot;,\n            &quot;title&quot;: &quot;MC石头：成年人的悲哀&quot;,\n            ......\n</code></pre><p>于是我们的解析思路就有了：<br>首先通过Jsonp根据该请求url获取排行榜的json数据</p>\n<pre><code>String hotJsonStr = Jsoup.connect(url).ignoreContentType(true).execute().body();\n</code></pre><p>根据上面的json格式，使用JsonPath对该数据进行解析，获取出所有排行榜视频的标题和链接</p>\n<pre><code>List&lt;String&gt; titles = JsonPath.read(hotJsonStr, &quot;$.rankList.[*].title&quot;);  \nList&lt;String&gt; urlList = JsonPath.read(hotJsonStr, &quot;$.rankList.[*].shareUrl&quot;);\n</code></pre><p>然后根据自己的喜好将标题绑定链接显示在页面制成列表就可以了</p>\n","categories":["java"],"tags":["jsonp"]},{"title":"【quartz】spring配置形式使用quartz实现定时任务","url":"/2020/06/10/%E3%80%90quartz%E3%80%91spring%E9%85%8D%E7%BD%AE%E5%BD%A2%E5%BC%8F%E4%BD%BF%E7%94%A8quartz%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"<p>quartz定时器配置实现：<br>假如有一个RedisTask类有一个myFunc方法，配置其为定时执行的方法:</p>\n<pre><code>&lt;!--首先是配置要定时加载的目标类--&gt;\n&lt;bean id=&quot;redisTaskAction&quot; class=&quot;com.me.RedisTask&quot;/&gt;\n\n&lt;!--配置定时执行的方法参数--&gt;\n&lt;bean id=&quot;redisTaskMethod&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;  \n &lt;property name=&quot;targetObject&quot; ref=&quot;redisTaskAction&quot; /&gt;  \n &lt;property name=&quot;targetMethod&quot; value=&quot;myFunc&quot; /&gt;  \n &lt;property name=&quot;concurrent&quot; value=&quot;false&quot;/&gt;  \n&lt;/bean&gt;\n\n&lt;!--配置触发器，每5分钟触发一次--&gt;  \n&lt;bean id=&quot;redisTaskTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;  \n &lt;property name=&quot;jobDetail&quot; ref=&quot;redisTaskMethod&quot; /&gt;  \n &lt;property name=&quot;cronExpression&quot; value=&quot;0 0/5 * * * ?&quot; /&gt;  \n&lt;/bean&gt;\n\n&lt;!--最后配置启动定时器--&gt;\n&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;\n    &lt;property name=&quot;triggers&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean=&quot;redisTaskTrigger&quot;/&gt;\n            ...\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><hr>\n<p>依赖        </p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n    &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;\n    &lt;artifactId&gt;quartz&lt;/artifactId&gt;\n    &lt;version&gt;2.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>","categories":["spring"],"tags":["quartz"]},{"title":"【mybatis】利用动态语句动态创建表和列","url":"/2019/02/27/%E3%80%90mybatis%E3%80%91%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E5%88%97/","content":"<h1 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h1><p>为了动态从数据库中生成表以及定义属性</p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><h2 id=\"创建新的xml文件以及mapper接口类\"><a href=\"#创建新的xml文件以及mapper接口类\" class=\"headerlink\" title=\"创建新的xml文件以及mapper接口类\"></a>创建新的xml文件以及mapper接口类</h2><p>TabelControllerMapper.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  \n&lt;mapper namespace=&quot;com.me.mapper.TableControllerMapper&quot;&gt;  \n\n\n &lt;update id=&quot;createNewTable&quot;&gt;  \n  CREATE TABLE ${myMap.theTableName}(  \n          id int(10) PRIMARY KEY AUTO_INCREMENT NOT NULL  \n          &lt;foreach collection=&quot;myMap&quot; index=&quot;key&quot; item=&quot;value&quot;&gt;  \n &lt;if test=&quot;key.toString() != &apos;theTableName&apos;.toString()&quot;&gt;  \n  ,${key} ${value}  \n &lt;/if&gt;  \n &lt;/foreach&gt;  );  \n    &lt;/update&gt;  \n&lt;/mapper&gt;\n</code></pre><p>注意第一句定义id后面不加逗号，在foreach循环里前面加上逗号是为了语句最后一次执行后面没有逗号，否则会报错</p>\n<hr>\n<p>TableControllerMapper接口</p>\n<pre><code>package com.me.mapper;  \n\nimport org.apache.ibatis.annotations.Mapper;  \nimport org.apache.ibatis.annotations.Param;  \n\nimport java.util.HashMap;  \n\n/**  \n * @author fenghere  \n */@Mapper  \npublic interface TableControllerMapper {  \n    /**  \n     * fetch data by rule id * * @param map mymap  \n     * @return Result&lt;XxxxDO&gt;  \n     */  \n\n  void createNewTable(@Param(value = &quot;myMap&quot;) HashMap map);  \n}\n</code></pre><p>输入的参数为hashmap类型，关于这种引入参数的方法另一篇博客有写</p>\n<blockquote>\n<p><a href=\"http://xfff.xyz/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/\">http://xfff.xyz/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/</a></p>\n</blockquote>\n<hr>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>写一个测试类</p>\n<pre><code>package com.me.demo;  \n\nimport com.me.beans.User;  \nimport com.me.mapper.TableControllerMapper;  \nimport com.me.mapper.UserMapper;  \nimport com.me.security.Md5Utils;  \nimport com.me.service.UserService;  \nimport org.junit.Test;  \nimport org.springframework.beans.factory.annotation.Autowired;  \n\nimport java.io.UnsupportedEncodingException;  \nimport java.security.NoSuchAlgorithmException;  \nimport java.util.HashMap;  \n\n/**  \n * @ClassName MyTest  \n * @Description TODO  \n * @Author xufeng  \n * @Data 2019/2/22 13:46  \n * @Version 1.0  \n **/\n public class MyTest extends DemoApplicationTests{  \n\n\n  @Autowired  \n  TableControllerMapper tableControllerMapper;  \n\n  @Test  \n  public void myTest(){  \n          HashMap&lt;String,String&gt; mymap = new HashMap&lt;&gt;();  \n          mymap.put(&quot;theTableName&quot;,&quot;dsafakshfdksahlfhdashdfh&quot;);  \n          mymap.put(&quot;text&quot;,&quot;text&quot;);  \n          mymap.put(&quot;username&quot;,&quot;varchar(10)&quot;);  \n          mymap.put(&quot;ididiid&quot;,&quot;int&quot;);  \n          tableControllerMapper.createNewTable(mymap);  \n\n  }  \n}\n</code></pre><p>MyTest类继承DemoApplicationTests是为了引入springboot项目的数据库和mapper配置</p>\n<p>执行完成，进入数据库查看</p>\n<p>如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0l4xp6jr3j30vm03mq32.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0l4yi56qfj30od05naab.jpg\" alt=\"\"></p>\n<hr>\n<p>另外，删除表等操作应为类似的操作.</p>\n<pre><code>&lt;select id=&quot;existTable&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;java.lang.Integer&quot;&gt;\n    select count(*)\n    from information_schema.TABLES\n    where LCASE(table_name) = #{tableName}\n&lt;/select&gt;\n\n\n&lt;update id=&quot;dropTable&quot;&gt;\n    DROP TABLE ${tablename}\n&lt;/update&gt;\n</code></pre>","categories":["mybatis"],"tags":["动态sql"]},{"title":"【springmvc】工作流程理解（一）","url":"/2018/12/10/%E3%80%90springmvc%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/","content":"<ol>\n<li>用户通过URL发送请求，到达<strong>DispatcherServlet-前端(核心)控制器</strong>(通过在web.xml中配置)</li>\n<li><strong>DispatcherServlet</strong>把请求转发给<strong>HandlerMapper-处理器映射器</strong>（在springmvc配置文件中注册）</li>\n<li><strong>HandlerMapper</strong>根据请求返回映射的<strong>controller控制器对象链</strong>给<strong>DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet</strong>把<strong>controller</strong>对象处理链转发给<strong>HandlerAdapter处理器适配器（在springmvc配置文件中注册）</strong></li>\n<li><strong>HandlerAdapter</strong>根据请求通知<strong>controller处理器</strong>应该实现的方法（配置扫描、注解）</li>\n<li><strong>controller</strong>调用对应的方法，返回<strong>ModelAndView</strong>对象（配置注解）</li>\n<li>经<strong>HandlerAdapter</strong>又发送回<strong>DispatcherServlet</strong></li>\n<li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>对象发送给<strong>ViewResolver</strong>视图解析器（在springmvc配置文件中配置）</li>\n<li><strong>ViewResolver</strong>对传来的<strong>Model</strong>（数据..）和<strong>View</strong>（对应的页面..）进行渲染返回给<strong>DispatcherServlet</strong></li>\n<li><strong>Response</strong> 响应给用户</li>\n</ol>\n<hr>\n<p>上诉为自己总结，可能有些错误，是我初学理解不够深刻。</p>\n<hr>\n<p><strong><em>网图:</em></strong><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw4bmgbq81j30pj09h75h.jpg\" alt=\"\"></p>\n","categories":["springmvc"],"tags":["springmvc"]},{"title":"【springmvc】注解开发的详细使用","url":"/2018/10/18/%E3%80%90springmvc%E3%80%91%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/","content":"<p><strong>首先，所有注解都要提前在配置文件中开启扫描。</strong><br><strong>&lt; context:component-scan base-package = “” /&gt;</strong><br>\\<a href=\"context:include-filter\" target=\"_blank\" rel=\"noopener\">context:include-filter</a> //指定扫描的路径<br>\\<a href=\"context:exclude-filter\" target=\"_blank\" rel=\"noopener\">context:exclude-filter</a> //排除扫描的路径</p>\n<p>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:include-filter type=”regex” expression=”.controller.<em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.service.</em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.dao.*”/&gt;<br>&lt;/context:component-scan&gt;</p>\n<p>=<br>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:exclude-filter type=”regex” expression=”.model.*”/&gt;<br>&lt;/context:component-scan&gt;</p>\n<p>无论哪种情况\\<a href=\"context:include-filter\" target=\"_blank\" rel=\"noopener\">context:include-filter</a>和\\<a href=\"context:exclude-filter\" target=\"_blank\" rel=\"noopener\">context:exclude-filter</a>都不能同时存在</p>\n<hr>\n<p><strong>@Controller</strong><br>注册一个bean到spring，标记一个类为controller，这样才能被外界访问到</p>\n<p><strong>@RequestMapping(“/xxx”)</strong><br>注册xxx请求绑定注解下面的类或方法.<br>该注解一共有六个属性，分别为value、method、consumes、produces、 params、headers。<br><strong>value</strong>：指定请求的实际地址，指定的地址可以是URI Template 模式，即请求的URI中可以包含变量，如<br>/test/{variable}/log.jsp,当请求/test/haha/log.jsp时，variable1对应为’haha’，配合@PathVariable使用。<br>另外，该注解还支持通配符</p>\n<p><strong>method</strong>：指定请求的method类型， GET、POST、PUT、DELETE等</p>\n<pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })\npublic String testMethod() {\n        return &quot;method&quot; ;\n    }\n</code></pre><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法</p>\n<p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html<br><strong>produces</strong>：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br><strong>params</strong>：指定request中必须包含某些参数值时，才让该方法处理</p>\n<pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })\npublic String testParams() {\n       System. out .println( &quot;test Params...........&quot; ); return &quot;testParams&quot; ;\n    }\n</code></pre><p>上面代码表面当/aa.action?后面有param1=value&amp;param2={something}且无param3时才能成功访问下面的方法</p>\n<p><strong>headers</strong>：指定request中必须包含某些指定的header值，才能让该方法处理请求<br>与params类似</p>\n<pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; }) \npublic String testHeaders() { \n        return &quot;headers&quot; ;\n    }\n</code></pre><p>在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法</p>\n<hr>\n<p><strong>@Resource和@Autowired</strong><br>两者都用来注入bean，@Resource其实并不是spring的注解，仔细看import部分可以看到是javax.annotation.*下的包。<br>共同点：可以写在bean的声明或者setter方法上，如果写在字段上，就不用写setter方法。<br>不同点：<br>@Autowired是按照类型装配对象，默认要求依赖对象必须存在，如果允许存在，设置required属性为false。按名称装配时要加@Qualifier(“xxx”)<br>@Resource默认按名称装配，需要配置name属性@Resource(name=”xxx”)，也可以设置type属性来按类型装配。</p>\n<hr>\n<p><strong>attribute类型{</strong><br><strong>@ModelAttribute</strong><br>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p>\n<pre><code>@ModelAttribute ( &quot;hello&quot; ) \npublic String getModel() {\n      System. out .println( &quot;-------------Hello---------&quot; );\n      return &quot;world&quot; ;\n   }\n</code></pre><p>上面代码会在访问方法执行前执行，打印，并把字符串”world”存入model对象中，对应关键字为”hello”<br>也可以在另外的方法参数前加上@ModelAttribute(“xxx”)即可把model里的xxx值映射到这个参数里</p>\n<p><strong>@SessionAttributes</strong><br>将值放到session作用域中，写在class上面。</p>\n<pre><code>@SessionAttributes(value={&quot;name&quot;,&quot;theid&quot;},type={User.class})\npublic class MyController{\n    //xxxxxx....\n}\n</code></pre><p>上面的代码指定了遇到属性name或者theid或者User类型使用modelattribute注解存放的时候，都会存放到session对象里。当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称<br><strong>}</strong></p>\n<hr>\n<p><strong>request uri部分</strong>(variable/)<br><strong>@PathVariable</strong><br>用来将URL中的变量映射到方法的参数里</p>\n<pre><code>@RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET) \npublic String getLogin(@PathVariable(&quot;userId&quot;) String userId,  \n    @PathVariable(&quot;roleId&quot;) String roleId){  \n    System.out.println(&quot;User Id : &quot; + userId);  \n    System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;;  \n}\n</code></pre><hr>\n<p><strong>request body部分</strong>{</p>\n<p><strong>@RequestParam</strong><br>主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型</p>\n<pre><code>public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {  \n    //xxx \n }    \n</code></pre><p><strong>@ResponseBody</strong><br>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>\n<pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT) \npublic void handle(@RequestBody String body, Writer writer) throws IOException {  \n  writer.write(body);  \n}\n</code></pre><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>\n<p><strong>}</strong></p>\n<hr>\n<p><strong>request header部分{</strong><br><strong>@RequestHeader</strong></p>\n<pre><code>public  void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,\n@RequestHeader(&quot;Keep-Alive&quot;)   long  keepAlive) {\n}\n</code></pre><p>这段代码把request header部分的Accept-Encoding和Keep-Alive值映射到对应的参数里。</p>\n<p><strong>@CookieValue</strong></p>\n<pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  \n}\n</code></pre><p>上面代码把cookie里的JSESSIONID值映射到对应的参数里。</p>\n<p><strong>}</strong></p>\n<hr>\n<p>@Component<br>通用的注解，当不知道一个类归于哪层时，使用。不推荐使用。</p>\n<p>@Repository<br>注解dao层，在daoImpl类上注解</p>\n","categories":["springmvc"],"tags":["springmvc","注解"]},{"title":"【springmvc】配置和使用(二)","url":"/2018/10/18/%E3%80%90springmvc%E3%80%91%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C/","content":"<p>根据前面描述的工作流程，现在来对springmvc进行配置。</p>\n<ul>\n<li>首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。</li>\n</ul>\n<pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n      &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n  &lt;/dependency&gt;\n  &lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n      &lt;version&gt;3.1.0&lt;/version&gt;\n  &lt;/dependency&gt;\n</code></pre><hr>\n<ul>\n<li><p>创建springmvc的配置文件springmvc.xml (<del>可以任意，最好规范</del>)</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans \n         http://www.springframework.org/schema/beans/spring-beans.xsd \n         http://www.springframework.org/schema/context \n         http://www.springframework.org/schema/context/spring-context.xsd \n         http://www.springframework.org/schema/tx         \n         http://www.springframework.org/schema/tx/spring-tx.xsd\n         http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n&lt;/beans&gt;\n</code></pre></li>\n</ul>\n<hr>\n<ul>\n<li><p>在web.xml中配置前端控制器。</p>\n<pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre></li>\n</ul>\n<p>注意param-value中的路径无误，<br>在url-pattern中有两种配置方式：<br>第一种:  *.action  ,访问以.action结尾，由DispatcherServlet进行解析<br><strong>第二种:  \\/  ,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方式实现RESTful风格的url</strong></p>\n<p> 错误配置:  \\/*  ,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错404</p>\n<hr>\n<ul>\n<li><p>配置处理器映射器</p>\n<pre><code>&lt;bean  class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>配置处理器适配器</p>\n<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;\n</code></pre></li>\n<li><p><strong>注解方式配置</strong></p>\n<pre><code>&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;\n&lt;mvc:annotation-driven /&gt;\n</code></pre></li>\n</ul>\n<hr>\n<ul>\n<li>配置处理器Handler(controller)</li>\n</ul>\n<pre><code>&lt;bean  name=&quot;/xxx.action&quot;  class=&quot;com.iot.ssm.controller.xxx&quot;/&gt;\n</code></pre><ul>\n<li><p><strong>注解批量扫描法</strong></p>\n<pre><code>&lt;!-- 配置扫描的包 --&gt;\n&lt;context:component-scan base-package=&quot;com.springdemo.*&quot; /&gt;\n</code></pre></li>\n</ul>\n<hr>\n<ul>\n<li><p><strong>配置视图解析器</strong></p>\n<pre><code>&lt;!-- 视图解析器 --&gt;\n&lt;bean\n    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre></li>\n</ul>\n<p>property中prefix对应要查找的目录，suffix对应自动添加的后缀</p>\n<hr>\n<hr>\n<p>测试：</p>\n<p>controller:</p>\n<pre><code>package com.springdemo.controller;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.swing.text.View;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport com.springdemo.domain.User;\n\n@Controller\n@RequestMapping(&quot;/demo&quot;)\npublic class TestController implements org.springframework.web.servlet.mvc.Controller{\n\n    @RequestMapping(&quot;/demo&quot;)\n    public String index() {\n        return &quot;index&quot;;\n    }\n\n    @Override\n    @RequestMapping(&quot;/test&quot;)\n    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception {\n        Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;(); \n        User user=new User();\n        user.setName(&quot;梁非凡&quot;);\n        user.setId(&quot;123&quot;);\n        map.put(&quot;user&quot;, user);\n        String str=&quot;刘醒&quot;;\n        map.put(&quot;str&quot;, str);\n        ModelAndView modelAndView=new ModelAndView();\n        modelAndView.addAllObjects(map);\n        modelAndView.setViewName(&quot;test&quot;);\n        return modelAndView;\n    }\n\n}\n</code></pre><p>test.jsp :</p>\n<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;\n    pageEncoding=&quot;utf-8&quot;%&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n${user.name}Hbbbbbbbbb\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>配置到tomcat上，启动tomcat，打开浏览器，输入地址<br><a href=\"http://localhost:8888/SpringMVCTest/demo/test\" target=\"_blank\" rel=\"noopener\">http://localhost:8888/SpringMVCTest/demo/test</a></p>\n<p>得到：<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwce2yvwflj311n0a7aan.jpg\" alt=\"\"></p>\n<p>成功…</p>\n","categories":["springmvc"],"tags":["springmvc","springmvc配置"]},{"title":"【vue】整合surveyjs工具生成在线问卷或考试","url":"/2019/01/31/%E3%80%90vue%E3%80%91%E6%95%B4%E5%90%88surveyjs%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%9C%A8%E7%BA%BF%E9%97%AE%E5%8D%B7%E6%88%96%E8%80%83%E8%AF%95/","content":"<p>本想做个问卷系统，在github上找到一个叫做surveyjs的项目，正好是我需要的东西。</p>\n<hr>\n<p>官网</p>\n<blockquote>\n<p><a href=\"https://surveyjs.io/\" target=\"_blank\" rel=\"noopener\">https://surveyjs.io/</a></p>\n</blockquote>\n<p>vue项目,surveyjseditor例子</p>\n<blockquote>\n<p><a href=\"https://github.com/surveyjs/surveyjs_vue_quickstart\" target=\"_blank\" rel=\"noopener\">surveyjs_vue_quickstart</a></p>\n</blockquote>\n<hr>\n<p>可以只用单个survey页面或者把编辑器导入也行。</p>\n<p>这里我的是问卷生成，所以俩部分都需要使用</p>\n<hr>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>本地找个空文件夹<br>打开gitbash命令行窗口<br>git clone <a href=\"https://github.com/surveyjs/surveyjs_vue_quickstart.git\" target=\"_blank\" rel=\"noopener\">https://github.com/surveyjs/surveyjs_vue_quickstart.git</a><br>项目克隆下来后<br>直接运行肯定不行<br>显然根目录下少了nodejs的node_modules<br>在该目录下打开命令行窗口<br>运行</p>\n<pre><code>npm install\n</code></pre><p>（可能需要翻墙）</p>\n<p>装好对应的依赖和库<br>就可以</p>\n<pre><code>npm run dev\n</code></pre><p>运行了</p>\n<hr>\n<p>打开项目目录<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzprfbs08cj309k0f10t3.jpg\" alt=\"\"></p>\n<p>直接打开上面的components组件目录，里面SurveyEditor.vue是我们引用需要写的组件代码。</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n&lt;div id=&quot;surveyEditorContainer&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport * as SurveyEditor from &apos;surveyjs-editor&apos;\nimport &apos;surveyjs-editor/surveyeditor.css&apos;;\n\nimport * as SurveyKo from &quot;survey-knockout&quot;;\nimport * as widgets from &quot;surveyjs-widgets&quot;;\n\nimport &quot;inputmask/dist/inputmask/phone-codes/phone.js&quot;;\n\nwidgets.icheck(SurveyKo);\nwidgets.select2(SurveyKo);\nwidgets.inputmask(SurveyKo);\nwidgets.jquerybarrating(SurveyKo);\nwidgets.jqueryuidatepicker(SurveyKo);\nwidgets.nouislider(SurveyKo);\nwidgets.select2tagbox(SurveyKo);\nwidgets.signaturepad(SurveyKo);\nwidgets.sortablejs(SurveyKo);\nwidgets.ckeditor(SurveyKo);\nwidgets.autocomplete(SurveyKo);\nwidgets.bootstrapslider(SurveyKo);\n\nexport default {\n  name: &apos;survey-editor&apos;,\n  data () {\n    return {\n    }\n  },\n  mounted () {\n    let editorOptions = { showEmbededSurveyTab: true };\n    this.editor = new SurveyEditor.SurveyEditor(&apos;surveyEditorContainer&apos;, editorOptions);\n    this.editor.saveSurveyFunc = function() {\n      console.log(JSON.stringify(this.text));\n    };\n  }\n}\n&lt;/script&gt;\n\n&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;\n&lt;style scoped&gt;\n&lt;/style&gt;\n</code></pre><p>大部分代码都很容易理解，showEmbededSurveyTab是用来选择是否显示应用在不同项目中需要写的代码的子页面，我改为false</p>\n<hr>\n<p>如何把该组件引入自己的项目中–</p>\n<p>新建项目</p>\n<p>按上次<a href=\"http://xfff.xyz/2019/01/29/vuejs%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/\">vue总体结构学习</a>这节配置好vue项目结构之后。<br>把该加入的SurveyEditor.vue放入component目录</p>\n<p>把该vue里用到的比如surveyjs-editor、survey-konckout、surveyjs-widgets、phone一一用</p>\n<pre><code>npm install xxxx -D\n</code></pre><p>安装好</p>\n<p>然后在页面里需要使用到该组件时只需要</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzpscuh94ij30hu08yaaj.jpg\" alt=\"\"></p>\n<p>如上导入即可</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fzpsdp938rj311y0kiq5g.jpg\" alt=\"\"></p>\n<hr>\n<p>另外，生成的页面导入，该页面创建完问卷后点击save survey会产生一个关于该问卷的格式信息，在saveSurveyFunc方法里我们可以对该数据进行处理提交给数据库。</p>\n<p>当获取到该数据后要对新的问卷页面进行渲染，则可以这样：</p>\n<p>新建页面</p>\n<pre><code>&lt;template&gt;\n    &lt;div id=&quot;surveyContainer&quot;&gt;\n\n&lt;!-- &lt;link href=&quot;https://surveyjs.azureedge.net/1.0.66/survey.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; --&gt;\n        &lt;survey :survey=&quot;survey&quot;&gt;&lt;/survey&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\nimport * as Survey from &apos;survey-vue&apos;\nimport &apos;bootstrap/dist/css/bootstrap.css&apos;;\n\nSurvey.Survey.cssType = &quot;bootstrap&quot;;\n\nvar surveyJSON = {&quot;pages&quot;:[{&quot;name&quot;:&quot;page1&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;comment&quot;,&quot;name&quot;:&quot;question1&quot;,&quot;title&quot;:&quot;aaa&quot;},{&quot;type&quot;:&quot;dropdown&quot;,&quot;name&quot;:&quot;question2&quot;,&quot;choices&quot;:[&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;]}]},{&quot;name&quot;:&quot;page2&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;radiogroup&quot;,&quot;name&quot;:&quot;question3&quot;,&quot;choices&quot;:[&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;]}]},{&quot;name&quot;:&quot;page3&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;matrix&quot;,&quot;name&quot;:&quot;question4&quot;,&quot;columns&quot;:[&quot;Column 1&quot;,&quot;Column 2&quot;,&quot;Column 3&quot;],&quot;rows&quot;:[&quot;Row 1&quot;,&quot;Row 2&quot;]}]}],&quot;maxTimeToFinishPage&quot;:10,&quot;showTimerPanel&quot;:&quot;top&quot;}\n\nvar mysurvey = new Survey.Model(surveyJSON);\n\n\nexport default{\n    data(){\n        return{\n            survey:mysurvey\n        }\n    },\n    methods:{\n          sendDataToServer:function(survey){\n            alert(&quot;The results are:&quot; + JSON.stringify(survey.data));\n        }\n    },\n    created(){\n        mysurvey.onComplete.add(this.sendDataToServer);\n    }\n\n}\n&lt;/script&gt;\n</code></pre><p>（这里要用安装bootstrap和survey-vue）<br>这样就能渲染出对应的问卷或考试页面（考试可以设置提交限定时间），上面的surveyJSON是我现导入的数据，一般使用要从服务器获取。</p>\n<hr>\n<p><strong>关于created和mounted的区别</strong><br>created是在页面创建的时候，mounted是页面渲染结束后，上面的created应做修改<br>参考</p>\n<blockquote>\n<p><a href=\"https://www.jianshu.com/p/f99d3e3d2256\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/f99d3e3d2256</a></p>\n</blockquote>\n<hr>\n","categories":["前端"],"tags":["vue","surveyjs"]},{"title":"【swagger-ui】通过注解生成api文档","url":"/2020/04/09/%E3%80%90swagger-ui%E3%80%91%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E7%94%9F%E6%88%90api%E6%96%87%E6%A1%A3/","content":"<h2 id=\"swagger-ui\"><a href=\"#swagger-ui\" class=\"headerlink\" title=\"swagger-ui\"></a>swagger-ui</h2><p>添加依赖</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n    &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><p>增加配置类：SwaggerConfig.java</p>\n<pre><code>package com.me.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\n/**\n * @author xufeng\n * @version 1.0\n * @date 2020/4/8 16:20\n **/\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n\n    //api接口包扫描路径\n    private static final String SWAGGER_SCAN_BASE_PACKAGE = &quot;com.me.controller&quot;;\n\n    private static final String VERSION = &quot;1.0.0&quot;;\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(SWAGGER_SCAN_BASE_PACKAGE))\n                .paths(PathSelectors.any()) // 可以根据url路径设置哪些请求加入文档，忽略哪些请求\n                .build();\n    }\n\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(&quot;问卷设计分析服务API&quot;) //设置文档的标题\n                .description(&quot;问卷设计分析服务 API 接口文档&quot;) // 设置文档的描述\n                .version(VERSION) // 设置文档的版本信息-&gt; 1.0.0 Version information\n                .termsOfServiceUrl(&quot;http://www.baidu.com&quot;) // 设置文档的License信息-&gt;1.3 License information\n                .build();\n    }\n}\n</code></pre><p>@Configuration标记让spring加载该配置类，@EnableSwagger2启用swagger</p>\n<p>最后在api接口的controller类上加各种注解就可以生成api文档了<br>类似于</p>\n<pre><code>@Api(description = &quot;登录API接口&quot;)\n@RestController\n@Slf4j\npublic class LoginController {\n\n    @Autowired\n    private UserService userService;\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @ApiOperation(value = &quot;登录&quot;, notes = &quot;登录接口信息&quot;)\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = &quot;email&quot;, value = &quot;邮箱&quot;, required = true, dataType = &quot;String&quot;)\n    })\n    @RequestMapping(&quot;/login&quot;)\n    @ResponseBody\n    public HashMap forLogin(...){\n        ......\n    }\n}\n</code></pre><p>然后启动项目，在项目端口后面加/swagger-ui.html就可以看到在线的接口文档了。</p>\n","categories":["swagger"],"tags":["api文档"]},{"title":"【好用的工具合集】","url":"/2018/10/10/%E3%80%90%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86%E3%80%91/","content":"<hr>\n<h2 id=\"项目开发类：\"><a href=\"#项目开发类：\" class=\"headerlink\" title=\"项目开发类：\"></a>项目开发类：</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xdp-gacl/p/4233289.html\" target=\"_blank\" rel=\"noopener\">maven &gt;&gt;struts项目示例及插件</a></li>\n<li><a href=\"#\">git</a></li>\n<li><a href=\"http://www.w3school.com.cn/tiy/t.asp?f=ajax_xml\" target=\"_blank\" rel=\"noopener\">ajax普通请求示例</a></li>\n<li><a href=\"https://blog.csdn.net/thinkscape/article/details/7467153\" target=\"_blank\" rel=\"noopener\">ajax规范请求示例</a></li>\n<li><a href=\"https://www.cnblogs.com/fjsnail/p/3491033.html\" target=\"_blank\" rel=\"noopener\">springmvc上传文件</a>+<a href=\"https://www.cnblogs.com/hahaxiaoyu/p/5102900.html\" target=\"_blank\" rel=\"noopener\">读取</a></li>\n<li><a href=\"https://www.cnblogs.com/sunniest/p/4555801.html\" target=\"_blank\" rel=\"noopener\">springmvc操作集合</a></li>\n</ul>\n<hr>\n<h2 id=\"图形设计类\"><a href=\"#图形设计类\" class=\"headerlink\" title=\"图形设计类:\"></a>图形设计类:</h2><ul>\n<li><a href=\"https://www.runoob.com/try/bootstrap/layoutit/#\" target=\"_blank\" rel=\"noopener\">bootstrapHtml简易设计工具</a></li>\n<li><a href=\"http://color.oulu.me/\" target=\"_blank\" rel=\"noopener\">颜色渐变</a></li>\n<li><a href=\"https://pan.baidu.com/s/1eQiXZKu\" target=\"_blank\" rel=\"noopener\">截图工具FastStone Capture</a></li>\n<li><a href=\"http://www.jq22.com/webide/\" target=\"_blank\" rel=\"noopener\">jquery在线编辑器</a></li>\n<li><a href=\"http://www.dmanywhere.cn/\" target=\"_blank\" rel=\"noopener\">sql数据模型pdm文件在线解析</a></li>\n</ul>\n<hr>\n<h2 id=\"github：\"><a href=\"#github：\" class=\"headerlink\" title=\"github：\"></a>github：</h2><ul>\n<li><a href=\"http://blog.sunnyxx.com/2014/02/27/hexo_startup/\" target=\"_blank\" rel=\"noopener\">hexo</a>+<a href=\"https://blog.csdn.net/Hoshea_chx/article/details/78826689\" target=\"_blank\" rel=\"noopener\">hexo</a></li>\n<li><a href=\"https://www.cnblogs.com/YingYue/p/5894680.html\" target=\"_blank\" rel=\"noopener\">git命令集合</a></li>\n</ul>\n<hr>\n<h2 id=\"Markdown设计：\"><a href=\"#Markdown设计：\" class=\"headerlink\" title=\"Markdown设计：\"></a>Markdown设计：</h2><ul>\n<li><a href=\"https://stackedit.io/app#\" target=\"_blank\" rel=\"noopener\">Stackedit编辑器</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf\" target=\"_blank\" rel=\"noopener\">图床-用来插入图片</a></li>\n</ul>\n<hr>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具:\"></a>其他工具:</h2><ul>\n<li><a href=\"https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo\" target=\"_blank\" rel=\"noopener\">油猴 Tampermonkey</a>+<a href=\"https://greasyfork.org/zh-CN/scripts\" target=\"_blank\" rel=\"noopener\">脚本资源</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/isearch/jmalocgcmlilelcdekhigpadlhfbjpnp\" target=\"_blank\" rel=\"noopener\">搜索引擎相关</a></li>\n<li><a href=\"https://blog.csdn.net/wanwuguicang/article/details/80716178\" target=\"_blank\" rel=\"noopener\">chrome插件伴侣</a></li>\n<li><a href=\"https://pan.baidu.com/s/1XII8zxn5HAAcW2-4dLWGAg\" target=\"_blank\" rel=\"noopener\">google学术搜索</a><br><del>这些链接咋不发光啊？？</del></li>\n</ul>\n<hr>\n<p>持续更新……..<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw3kxn6swfj31hc0u0wgk.jpg\" alt=\"\"></p>\n","categories":["tools"],"tags":["tools"]},{"title":"【单元测试】加载配置文件实现单元测试","url":"/2020/06/07/%E3%80%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%91%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"<p>首先引入JUnit依赖，注意版本，很容易报错</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre><p>找到web.xml，找到项目启动时加载的所有配置文件，复制路径，如下<br><img src=\"https://s1.ax1x.com/2020/06/04/tBibdI.png\" alt=\"tBibdI.png\"></p>\n<p>然后添加一个test类，加上注解如下</p>\n<pre><code>@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {&quot;classpath*:/config/application-context.xml&quot;,\n        &quot;classpath*:/config/application-context-sevice-mybatisPlus.xml&quot;,\n        &quot;classpath*:/config/spring-tuogangmq.xml&quot;,\n        &quot;classpath*:/config/kafka-consumer.xml&quot;,\n        &quot;classpath*:/config/kafka-producer.xml&quot;})\n</code></pre><p>接下来在该类里任意创建方法加上@Test即可愉快地测试了，也可以用注解任意引入项目中配置文件扫描到的组件，如下<br><img src=\"https://s1.ax1x.com/2020/06/04/tBFamd.png\" alt=\"tBFamd.png\"></p>\n<hr>\n<p>关于SpringBoot的单元测试比较容易，SpringBoot默认会创建一个DemoApplicationTests类，只要新建测试类继承该类即可在测试中使用Spring容器组件</p>\n","categories":["spring"],"tags":["单元测试"]},{"title":"【rpc】RPC理解与实现","url":"/2020/06/14/%E3%80%90rpc%E3%80%91RPC%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"<p><strong>rpc</strong>：<strong>远程过程调用</strong>（Remote Procedure Call）的缩写形式。不同于本地调用，函数与函数之间同属于同一块内存空间，如需调用某个函数，只需要找到所在内存地址即可。远程调用，通俗地说，便是有两台服务器 A，B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数/方法，需要通过网络来表达调用的语义和传达调用的数据。</p>\n<p>应用：分布式框架<strong>dubbo</strong>等。</p>\n<p>本地通过定义一个接口，动态代理一个请求返回的远程服务对象。</p>\n<p>三个要点：Call ID映射、序列化与反序列化、网络传输。<br>RPC调用过程：<br>1、客户端通过调用本地服务的方式调用服务<br>2、客户端将方法、入参等信息序列化后，找到服务端的远程服务地址，将消息通过网络发送给服务端<br>3、服务端收到消息进行解码（反序列化<br>4、服务端调用本地服务进行相关处理，将执行结果序列化后发送给客户端<br>5、客户端解码反序列化获取最后结果</p>\n<h2 id=\"使用技术：\"><a href=\"#使用技术：\" class=\"headerlink\" title=\"使用技术：\"></a>使用技术：</h2><ul>\n<li><strong>动态代理</strong><br>客户端使用动态代理代理服务端的服务对象，对消费方的请求进行处理。</li>\n<li><strong>序列化与反序列化</strong><br>为了使参数对象可以在网络中传输，需要用到序列化技术。常见的序列化方式有 JDK 自带序列化（Serializable 接口），HESSIAN 序列化，Kryo 序列化等。</li>\n<li><strong>NIO</strong><br>为了支持高并发，确保客户端与服务端的可靠通信，一般会使用到NIO技术，常用Netty作为网络应用框架实现。</li>\n<li><strong>服务注册中心</strong><br>为了便于客户端找到远程服务的地址，使用类似Zookeeper这种注册中心提供服务端注册服务，并支持分布式部署集群。</li>\n</ul>\n<blockquote>\n<p>参考文档<br><a href=\"https://www.jianshu.com/p/29d75a25eeaf\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/29d75a25eeaf</a><br><a href=\"https://www.jianshu.com/p/78f72ccf0377\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/78f72ccf0377</a><br>具体实现<br><a href=\"https://my.oschina.net/huangyong/blog/361751\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/huangyong/blog/361751</a></p>\n</blockquote>\n<h2 id=\"tips-of-动态代理\"><a href=\"#tips-of-动态代理\" class=\"headerlink\" title=\"tips of 动态代理\"></a>tips of 动态代理</h2><p>动态代理与事务的冲突：<strong>在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务。</strong><br>动态代理最终都是要调用原始对象的，而原始对象在去调用方法时，是不会再触发代理了！（触发的是代理类实例的方法，而非原对象的方法）</p>\n<p>代理模式：使用代理对象来完成对另一对象方法、接口的调用，然后可以在此基础上增加自定义逻辑。<br>动态代理：<a href=\"https://www.cnblogs.com/gonjan-blog/p/6685611.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/gonjan-blog/p/6685611.html</a></p>\n<p>创建一个InvocationHandler对象<br>&nbsp;&nbsp;&nbsp;&nbsp;InvocationHandler\\&lt;interfaceA><br>interfaceA指一个接口，为了动态代理该接口的所有实现类</p>\n<p>动态创建一个代理对象</p>\n<pre><code>Proxy.newProxyInstance(xx.class.getClassLoader(), new Class&lt;?&gt;[]{xxx.class}, invocationHandler);\n</code></pre>","categories":["分布式"],"tags":["rpc","动态代理"]},{"title":"【vue】与springboot后台项目数据交互","url":"/2019/02/16/%E3%80%90vue%E3%80%91%E4%B8%8Espringboot%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/","content":"<p>最近在使用vue和springboot前后端分离的方式开发项目<br>遇到了很多问题</p>\n<h2 id=\"身份认证\"><a href=\"#身份认证\" class=\"headerlink\" title=\"身份认证\"></a>身份认证</h2><p>这里本可以用vuex，但是由于偏轻量级，用vuex会比较复杂，于是我在main.js里定义了一个全局变量，以达到控制身份的效果</p>\n<pre><code>var state={\n    islogin:false,\n    manager:false,\n    identify:{\n        name:&apos;null&apos;,\n        email:&apos;null&apos;,\n    },\n    login(name,manager,email){\n        this.islogin=true;\n        this.identify.name=name;\n        this.manager=manager;\n        this.identify.email=email;\n    },\n    logout(){\n        this.islogin=false;\n        this.identify.name=&apos;null&apos;;\n        this.manager=false;\n        this.identify.email=&apos;null&apos;;\n    }\n}\n\nVue.prototype.state=state\n</code></pre><p>在用户请求路径的时候，在create函数里判断身份信息，然后选择是否成功访问</p>\n<hr>\n<h2 id=\"表单绑定\"><a href=\"#表单绑定\" class=\"headerlink\" title=\"表单绑定\"></a>表单绑定</h2><p>为了将表单数据提交，可以把表单数据通过v-model绑定到一个数组里</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class=&quot;login&quot;&gt;\n    &lt;myHeader/&gt;  \n    &lt;form class=&quot;theform&quot; id=&quot;demo_11&quot; autocomplete=&quot;off&quot;&gt;\n        &lt;div class=&quot;form-group&quot;&gt;\n            &lt;input class=&quot;form-control&quot; v-model=&quot;theform.email&quot; placeholder=&quot;email&quot; type=&quot;email&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;form-group&quot;&gt;\n            &lt;input @change=&quot;changePw&quot; v-model=&quot;theform.password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; maxlength=&quot;8&quot;&gt;\n\n        &lt;/div&gt;\n        &lt;p style=&quot;color:red&quot; v-show=&quot;pflag&quot;&gt;{{message}}&lt;/p&gt;\n        &lt;button class=&quot;btn btn-success&quot; @click.prevent=&quot;login&quot; type=&quot;submit&quot;&gt;{{loginmessage}}&lt;/button&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;button type=&quot;reset&quot; class=&quot;btn btn-danger&quot;&gt;{{reset}}&lt;/button&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;button type=&quot;button&quot; @click=&quot;toRegister&quot; class=&quot;btn btn-primary&quot;&gt;{{register}}&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;/div&gt;\n    &lt;myFooter/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport myHeader from &apos;../components/header.vue&apos;\nimport myFooter from &apos;../components/footer.vue&apos;\nimport qs from &apos;qs&apos;\nexport default {\n  components: { myHeader, myFooter },\n  data() {\n    return {\n       loginmessage:&quot;登陆&quot;,\n       reset:&quot;重置&quot;,\n       register:&quot;注册&quot;,\n       message:&quot;密码为3-8位字母或数字&quot;,\n       theform:{\n          email:&quot;&quot;,\n          password:&quot;&quot;,\n       },\n       pflag:false\n    }\n  },\n  created() {\n\n  },\n  methods: {\n      changePw:function(){\n        var reg=/[a-zA-Z0-9]{3,8}$/;\n        if(!reg.test(this.theform.password)){\n          this.pflag=true;\n          return;\n        }\n        this.pflag=false;\n      },\n      toRegister:function(){\n        this.$router.push({path:&apos;/register&apos;});\n      },\n      login:function(){\n          let me=this;\n          let params=qs.stringify(this.theform);\n          this.$axios.post(&apos;login&apos;,params,function(r){\n            if(!r.islogin){\n              alert(&quot;邮箱或密码错误&quot;);\n              me.$router.push({path:&apos;/&apos;});\n            }else{\n              me.state.login(r.name,r.manager,r.email);\n              if(r.manager){\n                me.$router.push({path:&apos;&apos;});\n              }else{\n                me.$router.push({path:&apos;&apos;});\n              }\n            }\n          });\n      } \n  }\n}\n&lt;/script&gt;\n\n&lt;style type=&quot;text/css&quot; src=&quot;@/style/login.css&quot;&gt;&lt;/style&gt;\n</code></pre><h2 id=\"axios请求\"><a href=\"#axios请求\" class=\"headerlink\" title=\"axios请求\"></a>axios请求</h2><p>在使用axios发送请求时，我使用的在另一篇博客里用到的axios接口函数，在处理字符串时会报错，怎么也无法解决，最终我只能把下面这行注释</p>\n<pre><code>/*      o[key] = o[key].trim()*/\n</code></pre><p>通过看接口代码，发现我们在后台需要返回数据里有success属性，否则会弹框打印信息。</p>\n<pre><code>package com.me.controller;  \n\nimport com.me.beans.ReturnMessage;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.RequestParam;  \nimport org.springframework.web.bind.annotation.ResponseBody;  \nimport org.springframework.web.bind.annotation.RestController;  \n\nimport java.util.HashMap;  \n\n@RestController  \npublic class LoginController {  \n\n    @RequestMapping(&quot;/login&quot;)  \n    @ResponseBody  \n  public HashMap login(@RequestParam(&quot;email&quot;)String email, @RequestParam(&quot;password&quot;)String password){  \n        System.out.println(&quot;I AM COMING!============&quot;);  \n  System.out.println(email);  \n  System.out.println(password);  \n\n  HashMap&lt;String,Object&gt; hashMap=new HashMap&lt;&gt;();  \n  hashMap.put(&quot;success&quot;,true);  \n  hashMap.put(&quot;islogin&quot;,false);  \n  hashMap.put(&quot;ismanager&quot;,true);  \n  hashMap.put(&quot;email&quot;,&quot;&quot;);  \n  hashMap.put(&quot;name&quot;,&quot;&quot;);  \n\n return hashMap;  \n  /*writer.write(&quot;success!!&quot;);*/  \n  }  \n\n    @RequestMapping(&quot;/sendcode&quot;)  \n    @ResponseBody  \n  public ReturnMessage sendcode(@RequestParam(&quot;email&quot;)String email){  \n        System.out.println(email);  \n return new ReturnMessage(true);  \n  }  \n}\n</code></pre><p>后台需要返回json格式的数据，使用@ResponseBody会帮我们自动把返回的数据转换为json格式。使用时还遇到了这个错误</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/gyjx2016/p/5896138.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/gyjx2016/p/5896138.html</a><br>只需要把@Controller改为@RestController注解即可（由于前后端分离，@controller注解并没有什么用）</p>\n</blockquote>\n<p>前台在提取的时候只需要把success函数里的r提出来用r.属性名就可以了</p>\n<p>另外，get请求会把参数放在url后面<br>所以请求时参数应写为{xxx:”xxx”}的格式<br>而post请求类型时，不能直接按上面的格式，或者用JSON.stringify()的格式，实际使用时，需要导入axios里的qs工具</p>\n<pre><code>import qs from &apos;qs&apos;\n</code></pre><p>然后对参数进行qs.stringify的操作<br>比如上面的表单里的数据，就用了</p>\n<pre><code>qs.stringify(this.theform)\n</code></pre><hr>\n<p>实际使用时，要注意this的含义，可以在刚开始用一个变量来存储this，防止后面使用的时候丢失。</p>\n<hr>\n<h2 id=\"获取验证码\"><a href=\"#获取验证码\" class=\"headerlink\" title=\"获取验证码\"></a>获取验证码</h2><p>实现验证码60秒内禁止重新发送</p>\n<pre><code>  var num=60;\n  var me=this;\nme.$axios.get(&apos;sendcode&apos;,{email:me.rform.email});\n  this.sflag=true;\n  var timer=setInterval(function(){\n      num--;\n      me.send=num+&apos;秒后刷新&apos;;\n    if(num == 0){\n       me.sflag=false;\n       me.send=&apos;发送验证码&apos;;\n       clearInterval(timer);\n       timer=null;\n    }\n  },1000);\n</code></pre><p>控制按钮能否点击上用了属性</p>\n<pre><code>:disabled=&quot;sflag&quot;\n</code></pre><p>通过变量sflag控制</p>\n<hr>\n<p>大概功能都差不多</p>\n","categories":["前端"],"tags":["springboot","axios"]},{"title":"【vue】关于push、replace、和go的使用问题","url":"/2019/03/09/%E3%80%90vue%E3%80%91%E5%85%B3%E4%BA%8Epush%E3%80%81replace%E3%80%81%E5%92%8Cgo%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/","content":"<p>在vue方法中跳转到另一个页面有以下三种方式</p>\n<pre><code>this.$router.push({path:&apos;/&apos;,query.....})\n\nthis.$router.replace({path:&apos;/&apos;,query.....})\n\nthis.$router.go(n)\n</code></pre><p>其中push和replace类似，可以指定在路由里指定的路径path跳转到指定页面，可以附带query和一些参数，实际跳转后query里的参数是附带在url后面以<br>？参数名=参数值<br>的形式传递。</p>\n<p>而go则是携带一个n值，相对于当前页面往前或者往后跳转多少个页面</p>\n<hr>\n<p>在push和replace的使用中，我发现push跳转会带着当前页面的缓存跳转，网上是这样解释的</p>\n<p><strong>描述：跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面</strong></p>\n<p><strong>当我实际使用时，发现跳转后有些控件的css样式异常，后来发现，原来是上一页面的css样式应用到了当前页面，当我改成replace之后就能显示正常。</strong></p>\n<p>而replace网上是这么解释的</p>\n<p><strong>同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</strong></p>\n<hr>\n<p>另外顺便记录一下如何用CSS画简单的箭头，再也不用图片当箭头按钮啦</p>\n<pre><code>width: 70px;\nheight: 70px;\nborder-top: 20px solid #041011;\nborder-left: 20px solid #041011;\ntransform: rotate(-45deg);\n</code></pre><p>transform里的是旋转角度，可以自定义方向</p>\n<p>显示如下</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0woo0oouej305z03j3yn.jpg\" alt=\"\"></p>\n","categories":["前端"],"tags":["vue","error"]},{"title":"关于热部署和切面方法的问题解决","url":"/2019/03/02/%E5%85%B3%E4%BA%8E%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E5%88%87%E9%9D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"<p>今天在使用AOP切面方法对指定方法进行增强的时候有个异常问题，折腾了很久，网上找了很多博客和解答，都找不到有用的，终于，凭着自己的第六感，找到了问题所在。</p>\n<p>原因就是 我使用JRebel热部署，然后对切面方法进行了修改，修改了方法的返回类型（不知道修改方法内容会不会，应该不会），然后运行时就会抛出以下异常：<img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0ods9stgtj30ts0fk0xx.jpg\" alt=\"\"></p>\n<p>具体代码如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g0odrojeh1j30fy0fxgmm.jpg\" alt=\"\"></p>\n<p>我把项目停止重新运行后，成功解决</p>\n<hr>\n<p>这里就顺便写一下springboot使用aop的方法叭</p>\n<h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><pre><code>&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;  \n&lt;/dependency&gt;\n</code></pre><h2 id=\"创建增强类\"><a href=\"#创建增强类\" class=\"headerlink\" title=\"创建增强类\"></a>创建增强类</h2><p>直接粘代码叭</p>\n<pre><code>package com.me.aspectj;  \n\nimport com.me.beans.ReturnMessage;  \nimport com.me.security.TokenCreater;  \nimport com.me.utils.RedisUtil;  \nimport org.aspectj.lang.ProceedingJoinPoint;  \nimport org.aspectj.lang.annotation.Around;  \nimport org.aspectj.lang.annotation.Aspect;  \nimport org.aspectj.lang.annotation.Pointcut;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.stereotype.Component;  \n\n/**  \n * @ClassName TokenAspectJ  \n * @Description 在用户或管理员的请求前对token进行验证  \n * @Author xufeng  \n * @Data 2019/3/1 18:05  \n * @Version 1.0  \n **/\n @Aspect  \n@Component  \npublic class TokenAspectJ {  \n\n    @Pointcut(&quot;execution(public * com.me.controller.UserController.*(..))&quot;)  \n    private void aop1(){}  \n\n    @Pointcut(&quot;execution(public * com.me.controller.ManagerController.*(..))&quot;)  \n    private void aop2(){}  \n\n    @Autowired  \n  private RedisUtil redisUtil;  \n\n  @Around(&quot;aop1() || aop2()&quot;)  \n    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {  \n        Object[] obj = joinPoint.getArgs();  \n  Object result;  \n  String token = (String) obj[obj.length-1];  \n if (redisUtil.get((String) TokenCreater.parseJWT(token).get(&quot;id&quot;)).equals(token)){  \n        result = joinPoint.proceed();  \n        return result;  \n  }  \n        return new ReturnMessage(true,401);  \n  }  \n\n}\n</code></pre><p><del>代码格式不知道怎么总是乱</del></p>\n<p>pointcut注解里，可以用多种参数<br>除了最常用的execution，还有args等可以指定添加了那些注解的方法作为增强对象<br>参照</p>\n<blockquote>\n<p><a href=\"https://www.cnblogs.com/liaojie970/p/7883687.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/liaojie970/p/7883687.html</a></p>\n</blockquote>\n<p>5种注解使用方式</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/u010502101/article/details/78823056\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010502101/article/details/78823056</a></p>\n</blockquote>\n<p>不进入增强方法用around</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/zhanglf02/article/details/78132304\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhanglf02/article/details/78132304</a></p>\n</blockquote>\n","categories":["errors"],"tags":["springboot"]},{"title":"使用StackEdit为markdown格式画图","url":"/2019/01/07/%E4%BD%BF%E7%94%A8StackEdit%E4%B8%BAmarkdown%E6%A0%BC%E5%BC%8F%E7%94%BB%E5%9B%BE/","content":"<h2 id=\"SmartyPants\"><a href=\"#SmartyPants\" class=\"headerlink\" title=\"SmartyPants\"></a>SmartyPants</h2><p>SmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>ASCII</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Single backticks</td>\n<td><code>&#39;Isn&#39;t this fun?&#39;</code></td>\n<td>‘Isn’t this fun?’</td>\n</tr>\n<tr>\n<td>Quotes</td>\n<td><code>&quot;Isn&#39;t this fun?&quot;</code></td>\n<td>“Isn’t this fun?”</td>\n</tr>\n<tr>\n<td>Dashes</td>\n<td><code>-- is en-dash, --- is em-dash</code></td>\n<td>– is en-dash, — is em-dash</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"KaTeX\"><a href=\"#KaTeX\" class=\"headerlink\" title=\"KaTeX\"></a>KaTeX</h2><p>You can render LaTeX mathematical expressions using <a href=\"https://khan.github.io/KaTeX/\" target=\"_blank\" rel=\"noopener\">KaTeX</a>:</p>\n<p>The <em>Gamma function</em> satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral</p>\n<p>$$<br>\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.<br>$$</p>\n<blockquote>\n<p>You can find more information about <strong>LaTeX</strong> mathematical expressions <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n</blockquote>\n<h2 id=\"UML-diagrams\"><a href=\"#UML-diagrams\" class=\"headerlink\" title=\"UML diagrams\"></a>UML diagrams</h2><p>You can render UML diagrams using <a href=\"https://mermaidjs.github.io/\" target=\"_blank\" rel=\"noopener\">Mermaid</a>. For example, this will produce a sequence diagram:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\">Alice -&gt;&gt; Bob: Hello Bob, how are you?</span><br><span class=\"line\">Bob--&gt;&gt;John: How about you John?</span><br><span class=\"line\">Bob--x Alice: I am good thanks!</span><br><span class=\"line\">Bob-x John: I am good thanks!</span><br><span class=\"line\">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.</span><br><span class=\"line\"></span><br><span class=\"line\">Bob--&gt;Alice: Checking with John...</span><br><span class=\"line\">Alice-&gt;John: Yes... John, how are you?</span><br></pre></td></tr></table></figure>\n<p>And this will produce a flow chart:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[Square Rect] -- Link text --&gt; B((Circle))</span><br><span class=\"line\">A --&gt; C(Rod Rect)</span><br><span class=\"line\">B --&gt; D&#123;Rhombus&#125;</span><br><span class=\"line\">C --&gt; D</span><br></pre></td></tr></table></figure>\n<hr>\n<hr>\n<pre><code>## SmartyPants  \n\n\nSmartyPants converts ASCII punctuation characters into &quot;smart&quot; typographic punctuation HTML entities. For example:  \n\n\n|  |ASCII |HTML |  \n|----------------|-------------------------------|-----------------------------|  \n|Single backticks|`&apos;Isn&apos;t this fun?&apos;`  |&apos;Isn&apos;t this fun?&apos; |  \n|Quotes |`&quot;Isn&apos;t this fun?&quot;`  |&quot;Isn&apos;t this fun?&quot; |  \n|Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|  \n\n\n\n## KaTeX  \n\n\nYou can render LaTeX mathematical expressions using [KaTeX](https://khan.github.io/KaTeX/):  \n\n\nThe *Gamma function* satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral  \n\n\n$$  \n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.  \n$$  \n\n\n&gt; You can find more information about **LaTeX** mathematical expressions [here](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference).  \n\n\n\n## UML diagrams  \n\n\nYou can render UML diagrams using [Mermaid](https://mermaidjs.github.io/). For example, this will produce a sequence diagram:  \n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sequenceDiagram  </span><br><span class=\"line\">Alice -&gt;&gt; Bob: Hello Bob, how are you?  </span><br><span class=\"line\">Bob--&gt;&gt;John: How about you John?  </span><br><span class=\"line\">Bob--x Alice: I am good thanks!  </span><br><span class=\"line\">Bob-x John: I am good thanks!  </span><br><span class=\"line\">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.  </span><br><span class=\"line\">  </span><br><span class=\"line\">Bob--&gt;Alice: Checking with John...  </span><br><span class=\"line\">Alice-&gt;John: Yes... John, how are you?  </span><br><span class=\"line\">```  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">And this will produce a flow chart:  </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">```mermaid  </span><br><span class=\"line\">graph LR  </span><br><span class=\"line\">A[Square Rect] -- Link text --&gt; B((Circle))  </span><br><span class=\"line\">A --&gt; C(Rod Rect)  </span><br><span class=\"line\">B --&gt; D&#123;Rhombus&#125;  </span><br><span class=\"line\">C --&gt; D</span><br></pre></td></tr></table></figure>\n</code></pre>","categories":["tools"],"tags":["Markdown","StackEdit"]},{"title":"图片的上传和下载以及存入数据库","url":"/2018/10/22/%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"<hr>\n<h2 id=\"首先添加jar包\"><a href=\"#首先添加jar包\" class=\"headerlink\" title=\"首先添加jar包\"></a>首先添加jar包</h2><p>这里我直接写maven依赖<br><span id=\"a\"></span></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n    &lt;version&gt;3.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\n    &lt;version&gt;1.3.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-io&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n    &lt;version&gt;2.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n    &lt;version&gt;1.2&lt;/version&gt;\n    &lt;type&gt;pom.lastUpdated&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre><hr>\n<h2 id=\"表单：\"><a href=\"#表单：\" class=\"headerlink\" title=\"表单：\"></a>表单：</h2><pre><code>&lt;form action=&quot;Aservlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;tname&quot; /&gt;\n    &lt;input type=&quot;file&quot; name=&quot;tfile&quot; /&gt;\n    &lt;button type=&quot;submit&quot;&gt;SSSS&lt;/button&gt;\n&lt;/form&gt;\n</code></pre><p>这里注意enctype的值</p>\n<hr>\n<h2 id=\"创建一个Servlet处理接收数据\"><a href=\"#创建一个Servlet处理接收数据\" class=\"headerlink\" title=\"创建一个Servlet处理接收数据\"></a>创建一个Servlet处理接收数据</h2><pre><code>PrintWriter out=response.getWriter();\nresponse.setContentType(&quot;text/html&quot;);\n\ntry {\n    DiskFileItemFactory factory=new DiskFileItemFactory();\n    ServletFileUpload upload=new ServletFileUpload(factory);\n    upload.setHeaderEncoding(&quot;utf-8&quot;);\n    if(!ServletFileUpload.isMultipartContent(request)) {\n        return;\n    }\n    List&lt;FileItem&gt; list=upload.parseRequest(request);\n    for (FileItem fileItem : list) {\n        if(fileItem.isFormField()) {\n            //处理表单内非文件内容\n            String name=fileItem.getFieldName();\n            String value=fileItem.getString(&quot;UTF-8&quot;);\n\n        }else {\n            String filename=fileItem.getName();\n            if(filename.endsWith(&quot;.png&quot;)) {\n                //这里只接收以png结尾的文件\n                filename=filename.substring(filename.lastIndexOf(&quot;\\\\&quot;)+1);\n                //得到文件输入流\n                InputStream inputStream=fileItem.getInputStream();        \n                //创建一个新数组存放内容\n                byte data[]=new byte[inputStream.available()];\n                //写入数组\n                inputStream.read(data);\n                /*byte buffer[]=new byte[1024];\n                int len=0;\n                while((len=inputStream.read(buffer))&gt;0) {\n                    outputStream.write(buffer, 0, len);\n                }*/\n                inputStream.close();\n                //用base64编码为字符串，接下来就能存入数据库（未写）\n                String str=Base64.getEncoder().encodeToString(data);\n                request.getSession().setAttribute(&quot;img&quot;, str);\n\n                fileItem.delete();\n            }\n            else {\n                continue;\n            }\n        }\n    }\n\n\n}catch (Exception e) {\n    // TODO: handle exception\n}\nrequest.getRequestDispatcher(&quot;img.jsp&quot;).forward(request, response);\n</code></pre><p>这里是doget()里的内容</p>\n<hr>\n<h2 id=\"创建输出图片的servlet\"><a href=\"#创建输出图片的servlet\" class=\"headerlink\" title=\"创建输出图片的servlet\"></a>创建输出图片的servlet</h2><pre><code>//禁止缓存\nresponse.setDateHeader(&quot;Expires&quot;, -1);\nresponse.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);\nresponse.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);\n// 通知jsp以图片方式打开发送过去的数据\nresponse.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);\nString str=(String) request.getSession().getAttribute(&quot;img&quot;);\nOutputStream outputStream=response.getOutputStream();\nbyte data[]=Base64.getDecoder().decode(str);\noutputStream.write(data);\noutputStream.close();\n</code></pre><p>base64解码，用response的输出流输出</p>\n<hr>\n<h2 id=\"显示图片的jsp\"><a href=\"#显示图片的jsp\" class=\"headerlink\" title=\"显示图片的jsp\"></a>显示图片的jsp</h2><pre><code>&lt;label&gt;图片:&lt;/label&gt;\n&lt;img width=&quot;200&quot; height=&quot;200&quot; src=&quot;${pageContext.request.contextPath}/Imgg&quot;/&gt;\n&lt;a href=&quot;${pageContext.request.contextPath}/DownS&quot;&gt;hahah&lt;/a&gt;\n</code></pre><p>可以设置图片的高和宽</p>\n<hr>\n<h2 id=\"下载图片\"><a href=\"#下载图片\" class=\"headerlink\" title=\"下载图片\"></a>下载图片</h2><p>通过上面的超链接请求downs这个servlet下载图片<br>doget()内容</p>\n<pre><code>response.setDateHeader(&quot;Expires&quot;, -1);\nresponse.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);\nresponse.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);\nresponse.setHeader(&quot;content-disposition&quot;, &quot;attachment;&quot;);\nString str=(String) request.getSession().getAttribute(&quot;img&quot;);\nOutputStream outputStream=response.getOutputStream();\nbyte data[]=Base64.getDecoder().decode(str);\noutputStream.write(data);\noutputStream.close();\n</code></pre><hr>\n<p>遇到的错误或异常：<br><a href=\"https://blog.csdn.net/xiaoye142034/article/details/78852661\" target=\"_blank\" rel=\"noopener\">使用EL表达式标红</a><br><a href=\"#a\">缺少commons-logging</a></p>\n<hr>\n","categories":["java"],"tags":["数据库","javaweb","图片的上传下载"]},{"title":"工作第一天","url":"/2018/12/19/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%A4%A9/","content":"<hr>\n<p>经过大半个月的折腾，我找到了自己的第一份IT工作。</p>\n<p>今天是第一天，负责带我的导师，出差了……</p>\n<p>是的，没错，出差了。</p>\n<p>干坐了一天，看看这个看看那个，刷刷这个刷刷那个，无聊呀…</p>\n<p>说到无聊，我就想起了《西游记》里的无花果树。今年下半年…开拍…文体两开花…</p>\n<p>咳咳，由于昨天一天的搬家折腾，晚上也没睡好，感冒（类似）鼻塞了，很难受，而且还很困，希望今晚能好好睡一觉，鼻塞快点好吧，明天也要元气满满。</p>\n<p>这里就随便记一下皮一下—–</p>\n<p>加油吧。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fyc25phdx5j30xc0sqx6p.jpg\" alt=\"\"></p>\n","categories":["杂记"],"tags":["日常生活"]},{"title":"比较器Comparator和Comparable的使用","url":"/2018/11/23/%E6%AF%94%E8%BE%83%E5%99%A8Comparator%E5%92%8CComparable%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"<p>当我们需要对一些数组和集合进行排序的时候，经常会用到Arrays.sort和Collections.sort方法。<br>但当sort里的数组或集合里的对象不适合用默认的比较方法时，我们就需要手动对排序方式重新定义。</p>\n<hr>\n<p>比如，现在定义一个Person对象：</p>\n<pre><code>public class Person {\n\n    private int id;\n    private int age;\n\n    public Person(int id,int age) {\n        this.age=age;\n        this.id=id;\n    }\n\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }    \n\n    @Override\n    public String toString() \n        return &quot;Person&quot;+id+&quot;-&gt;age:&quot;+age;\n    }\n}\n</code></pre><p>现在我们要对一堆person集合进行按年龄从小到大的排序或者年龄和id的和的大小的排序，这个时候默认的方法就无法实现我们的要求。</p>\n<hr>\n<p>一般我们有两种方法来实现：</p>\n<h2 id=\"1-实现Comparable接口\"><a href=\"#1-实现Comparable接口\" class=\"headerlink\" title=\"1.实现Comparable接口\"></a>1.实现Comparable接口</h2><p>让需要进行特殊排序的对象实现Comparable接口，并重写其中的compareTo方法</p>\n<pre><code>public class Person implements Comparable&lt;Person&gt;\n</code></pre><p>compareTo中，如果想按从小到大的顺序排列，当符合小于规定时就返回-1。否则可以反向排序返回1。</p>\n<pre><code>@Override\npublic int compareTo(Person o) {\n    if (age&lt;o.age) {\n        return -1;\n    }else {\n        return 1;\n    }\n}\n</code></pre><p>测试：</p>\n<pre><code>public class ComparaTest {\n    public static void main(String[] args) {\n        List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();\n        aList.add(new Person(1,13));\n        aList.add(new Person(2, 42));\n        aList.add(new Person(3, 5));\n        aList.add(new Person(45, 32));\n        aList.add(new Person(42, 88));\n        aList.add(new Person(4, 5));\n        System.out.println(&quot;排序前:&quot;);\n        aList.stream().forEach(System.out::println);\n        Collections.sort(aList);\n        System.out.println(&quot;排序后:&quot;);\n        aList.stream().forEach(System.out::println);\n    }\n}\n</code></pre><p>输出</p>\n<pre><code>排序前:\nPerson1-&gt;age:13\nPerson2-&gt;age:42\nPerson3-&gt;age:5\nPerson45-&gt;age:32\nPerson42-&gt;age:88\nPerson4-&gt;age:5\n排序后:\nPerson3-&gt;age:5\nPerson4-&gt;age:5\nPerson1-&gt;age:13\nPerson45-&gt;age:32\nPerson2-&gt;age:42\nPerson42-&gt;age:88\n</code></pre><h2 id=\"2-创建比较类继承Comparator\"><a href=\"#2-创建比较类继承Comparator\" class=\"headerlink\" title=\"2.创建比较类继承Comparator\"></a>2.创建比较类继承Comparator</h2><p>Comparator位于包java.util下，而Comparable位于包java.lang下。</p>\n<p>创建一个比较类MyComparator：<br>这里我直接创建一个静态内部类用来比较，并定义为倒序</p>\n<pre><code>static class MyComparator implements Comparator&lt;Person&gt;{\n\n    @Override\n    public int compare(Person o1, Person o2) {\n        if (o1.getAge()&lt;o2.getAge()) {\n            return 1;\n        }else {\n            return -1;\n        }\n    }\n}\n</code></pre><p>测试：</p>\n<pre><code>public static void main(String[] args) {\n    List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();\n    aList.add(new Person(1,13));\n    aList.add(new Person(2, 42));\n    aList.add(new Person(3, 5));\n    aList.add(new Person(45, 32));\n    aList.add(new Person(42, 88));\n    aList.add(new Person(4, 5));\n    System.out.println(&quot;排序前:&quot;);\n    aList.stream().forEach(System.out::println);\n    Collections.sort(aList,new MyComparator());\n    System.out.println(&quot;排序后:&quot;);\n    aList.stream().forEach(System.out::println);\n}\n</code></pre><p>输出：</p>\n<pre><code>排序前:\nPerson1-&gt;age:13\nPerson2-&gt;age:42\nPerson3-&gt;age:5\nPerson45-&gt;age:32\nPerson42-&gt;age:88\nPerson4-&gt;age:5\n排序后:\nPerson42-&gt;age:88\nPerson2-&gt;age:42\nPerson45-&gt;age:32\nPerson1-&gt;age:13\nPerson4-&gt;age:5\nPerson3-&gt;age:5\n</code></pre><hr>\n<p>另外，在leetcode第23题有配合优先级队列使用。</p>\n","categories":["java"],"tags":["比较器"]},{"title":"文件上传解析冲突问题","url":"/2018/10/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","content":"<p>由于在上一篇写ajax提交表单时，在springmvc.xml里配置了<strong>MultipartResolver</strong>，导致我引入的图片上传插件失效（上传显示成功，但是后台没有接收到），在利用各种搜索引擎查找问题之后，终于找到了原因。</p>\n<hr>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>文件上传有两种方式，spring框架里的<strong>MultipartResolver</strong>解析以及传统的<strong>ServletFileUpload</strong>。<br>由于我引入的图片上传插件是第二种方式，而上篇写到的ajax提交表单需要MultipartResolver解析，<strong>两种方式一起使用会产生冲突</strong>。传统方式上传文件的请求会被multipartResolver拦截，导致没有解析出文件。</p>\n<hr>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>统一使用同一种方式上传请求</li>\n<li>继承MultipartResolver，并重写其中的方法，当遇到某些url请求的时候跳过</li>\n</ol>\n<p>由于我引入的插件代码稍微封装的有点麻烦，改起来肯定不方便，而另一边虽然可以改成传统方式发送表单数据，但是需要更多js代码来解析表单数据发送，所以我选择第二种方法。</p>\n<p>事实证明第二种方法确实也更方便。</p>\n<hr>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><ul>\n<li><p>创建一个类MyMultipartResolver并让它继承MultipartResolver，下面代码贴出：</p>\n<pre><code>package com.me.resolver;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\n\npublic class MyMultipartResolver extends CommonsMultipartResolver {\n    //单url过滤以及多url过滤\n    private String excludeUrls;\n    private String[] excludeUrlArray;\n\n    public String getExcludeUrls() {\n        return excludeUrls;\n    }\n\n    //以逗号分隔\n    public void setExcludeUrls(String excludeUrls) {\n        this.excludeUrls=excludeUrls;\n        this.excludeUrlArray=excludeUrls.split(&quot;,&quot;);\n    }\n\n    //重写的方法，判断url是否需要multipartResolver解析\n    @Override\n    public boolean isMultipart(HttpServletRequest request) {\n        for(String url:excludeUrlArray) {\n            if(request.getRequestURI().contains(url)) {\n                return false;\n            }\n        }\n\n        return super.isMultipart(request);\n    }\n}\n</code></pre></li>\n</ul>\n<p>关键在于isMultipart里的判断</p>\n<ul>\n<li><p>接下来在springmvc.xml配置，删除之前MultipartResolver 的配置内容，修改为</p>\n<pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;com.me.resolver.MyMultipartResolver&quot;&gt;\n     &lt;property name=&quot;excludeUrls&quot; value=&quot;update&quot; /&gt;\n   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;\n   &lt;property name=&quot;maxUploadSize&quot; value=&quot;2097152&quot;&gt;&lt;/property&gt;\n   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre></li>\n</ul>\n<hr>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;由此，两种方法就能和睦相处啦~</p>\n","categories":["errors"],"tags":["error","resolver","文件上传"]},{"title":"【杂记】码云gitee禁止外链访问txt、zip等文件导致hexo搜索失效","url":"/2020/07/23/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91%E7%A0%81%E4%BA%91gitee%E7%A6%81%E6%AD%A2%E5%A4%96%E9%93%BE%E8%AE%BF%E9%97%AEtxt%E3%80%81zip%E7%AD%89%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4hexo%E6%90%9C%E7%B4%A2%E5%A4%B1%E6%95%88/","content":"<p>由于github page国内访问太慢,于是在码云(gitee.com)同步了一份相同的博客.</p>\n<p>本来想把码云博客地址绑定到我的域名<a href=\"xfff.xyz\">xfff.xyz</a>的,发现国内的域名都要备案才能成功解析CNAME….备案又要买个服务器…算了,不整了</p>\n<p>最近发现gitee的博客又用不了搜索功能了,莫名其妙…</p>\n<p>打开F12喵一眼,发现是搜索文件的版本号文件取不到,报404<br>大概是这么个文件:<strong>searchVersion.txt</strong><br>打开仓库看一眼发现仓库里是有的,然后试着打开同目录下的html文件以及CNAME(无后缀),都成功了,搜索了下,果然发现近两个月gitee把txt外链禁止了.</p>\n<p>后来想了想,既然禁止txt,那我换个样子不就行了嘛,然后去主题里找搜索文件的命名,然后修改.</p>\n<p>修改后倒是成功了,可以访问到searchVersion文件了,问题又来了,又找不到search.zip文件了…啊啊</p>\n<p>故技重施,去掉后缀试试,还真可以了…</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>hexo配置文件中找到以下内容,修改</p>\n<pre><code>#search\nsearch:\n  path: search.json\n  zipPath: search.zip\n  versionPath: searchVersion.txt\n  field: post\n</code></pre><p>修改后:</p>\n<pre><code>#search\nsearch:\n  path: search.json\n  zipPath: search\n  versionPath: searchVersion\n  field: post\n</code></pre><p>重新hexo g打包生成后,部署上去(gitee不能自动部署…得去页面自己点),再试试搜索功能,终于解决了</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/23/ULj6TU.png\" alt=\"ULj6TU.png\"></p>\n","categories":["杂记"]},{"title":"线程池的基本使用","url":"/2018/10/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"<p>要用到线程池，就要先介绍一个类：<strong>ThreadPoolExecutor</strong>.</p>\n<p>通过查看源码发现继承及实现关系为<br><img src=\"http://www.plantuml.com/plantuml/png/SoWkIImgAStDuGh9A4fDJ0d8pyznhKXDBYt9BrBGjLDmJ2ekAKfCBe691QSMbMKcfreff5QKfEQb57FXK03IYw4dCxSW9pKtDQ-ac0kFSYkOqGv04kWo0000\" alt=\"\"></p>\n<hr>\n<p>在ThreadPoolExecutor类中，发现有四种构造方法，需要传入很多参数。</p>\n<pre><code>public ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize &lt; 0 ||\n        maximumPoolSize &lt;= 0 ||\n        maximumPoolSize &lt; corePoolSize ||\n        keepAliveTime &lt; 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n</code></pre><h2 id=\"这里对常见的参数进行解释：\"><a href=\"#这里对常见的参数进行解释：\" class=\"headerlink\" title=\"这里对常见的参数进行解释：\"></a>这里对常见的参数进行解释：</h2><ul>\n<li><strong>corePoolSize</strong>：核心池的大小</li>\n<li><strong>maximumPoolSize</strong>：线程池大小（最大能容纳线程数）</li>\n<li>keepAliveTime：允许线程空闲时间。当线程池中线程数大于核心池大小时，当有线程空闲时间超过keepAliveTime就会终止。如果调用了allowCoreThreadTimeOut(boolean)方法，则核心池中的空闲线程也会被终止。</li>\n<li>unit：keepAliveTime的时间单位，格式TimeUnit.XXXX(XXXX用HOURS、MILLISECONDS等替代)</li>\n<li><strong>workQueue</strong>：阻塞队列，一般可选三种类型<ul>\n<li>ArrayBlockingQueue数组类型，指定大小</li>\n<li>LinkedBlockingQueue链表类型，不用指定大小</li>\n<li>SynchronousQueue：<a href=\"https://www.cnblogs.com/duanxz/p/3252267.html\" target=\"_blank\" rel=\"noopener\">CLICK</a></li>\n<li>PriorityBlockingQueue</li>\n</ul>\n</li>\n<li>threadFactory：线程工厂，主要用来创建线程</li>\n<li>handler：指定拒绝处理任务时的策略</li>\n</ul>\n<hr>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>实例化一个ThreadPoolExecutor类</p>\n<pre><code>ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;,5));\n</code></pre><p>核心池大小为5，线程池大小为10，线程允许空闲200ms，阻塞队列大小5.</p>\n<p>然后，创建20个线程并每次打印线程池中的状态</p>\n<pre><code>for(int a=0;a&lt;20;a++) {\n    executor.execute(new ThreadPoolT(a));\n    System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());\n}\n</code></pre><p>其中线程的run方法为</p>\n<pre><code>    @Override\npublic void run() {\n    // TODO Auto-generated method stub\n    System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);\n}\n</code></pre><p>关闭线程池</p>\n<pre><code>executor.shutdown();\n</code></pre><p>总代码</p>\n<pre><code>package com.test;\n\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolT implements Runnable{\n\n    private int id;\n\n\n    public ThreadPoolT(int id) {\n        super();\n        this.id = id;\n    }\n\n    public static void main(String[] args) {\n\n        ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5));\n        for(int a=0;a&lt;20;a++) {\n            executor.execute(new ThreadPoolT(a));\n            System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());\n        }\n        System.out.println(executor.getLargestPoolSize());\n        System.out.println(executor.getPoolSize());\n        executor.shutdown();\n    }\n\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);\n    }\n\n}\n</code></pre><hr>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwqbapglbpj30xw0ezgnm.jpg\" alt=\"\"></p>\n<p>可见</p>\n<ol>\n<li>线程池会先创建核心池大小量的线程数，并加入需运行的线程</li>\n<li>然后再往线程池中加线程时，就会往阻塞队列里添加，等待执行</li>\n<li>当阻塞队列满了，再往线程池里添加线程，这个时候线程池就会再创建新线程来弥补不足</li>\n<li>当线程池满了（达到了maximumPoolSize ），再往线程池里添加线程时，线程池就会拒绝任务，而拒绝策略和之前参数的设置有关，这里是抛出RejectedExecutionException异常，并停止添加更多线程执行。</li>\n<li>等待线程运行完</li>\n</ol>\n<hr>\n<p>如果把前面的队列里的参数5去掉，并在线程池结束前加下列代码：</p>\n<pre><code>Thread.sleep(10000);\nSystem.out.println(executor.getPoolSize()+&quot;AAAAAAAAAAAAAAA&quot;);\nexecutor.shutdown();\n</code></pre><p>则运行结果为：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwqbr9olgfj30rn0hwgnk.jpg\" alt=\"\"></p>\n<p>可见线程全部运行结束后核心池仍有5个线程，这便是线程池使用的优点，不用频繁开线程关线程，而是提供一些线程代理运行需要运行的线程，提高了程序效率。</p>\n<hr>\n<p>另外，其实一般使用线程池不用我们每次指定那么多参数。一般使用Executors类中提供的静态方法来创建线程池：</p>\n<pre><code>//corePoolSize和maximumPoolSize值相等，它使用LinkedBlockingQueue\npublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;(),\n                                  threadFactory);\n}\n\n\n//corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable&gt;()));\n}\n\n\n//corePoolSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n}\n</code></pre><hr>\n<h2 id=\"合理设置线程池大小\"><a href=\"#合理设置线程池大小\" class=\"headerlink\" title=\"合理设置线程池大小\"></a>合理设置线程池大小</h2><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看：<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务 （2*cpu核心）<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>\n","categories":["java"],"tags":["线程池","java","多线程"]},{"title":"【shiro】shiro整合redis保存session以及RememberMe探索","url":"/2019/03/20/%E3%80%90shiro%E3%80%91shiro%E6%95%B4%E5%90%88redis%E4%BF%9D%E5%AD%98session%E4%BB%A5%E5%8F%8ARememberMe%E6%8E%A2%E7%B4%A2/","content":"<p>在上一节的项目中<br>增加改进</p>\n<h2 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h2><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;\n    &lt;version&gt;2.4.2.1-RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n    &lt;version&gt;1.2.46&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><hr>\n<h2 id=\"增加如下配置\"><a href=\"#增加如下配置\" class=\"headerlink\" title=\"增加如下配置\"></a>增加如下配置</h2><p>shiroConfig中</p>\n<pre><code>public RedisManager redisManager(){\n    RedisManager redisManager = new RedisManager();\n    redisManager.setHost(&quot;localhost&quot;);\n    redisManager.setPort(6379);\n    //缓存过期时间\n    redisManager.setExpire(1800);\n    redisManager.setTimeout(0);\n    //redisManager.setPassword();\n    return redisManager;\n}\n\n@Bean\npublic RedisCacheManager cacheManager(){\n    //使用的是org.crazycake包下的rediscachemanager\n    RedisCacheManager redisCacheManager = new RedisCacheManager();\n    redisCacheManager.setRedisManager(redisManager());\n    return redisCacheManager;\n}\n\n@Bean\npublic RedisSessionDAO redisSessionDAO(){\n    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();\n    redisSessionDAO.setRedisManager(redisManager());\n    return redisSessionDAO;\n}\n\n@Bean\npublic DefaultWebSessionManager sessionManager(){\n    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n    sessionManager.setSessionDAO(redisSessionDAO());\n    return sessionManager;\n}\n</code></pre><h2 id=\"注入SecurityManager\"><a href=\"#注入SecurityManager\" class=\"headerlink\" title=\"注入SecurityManager\"></a>注入SecurityManager</h2><pre><code>@Bean(name = &quot;securityManager&quot;)\npublic SecurityManager securityManager(){\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    securityManager.setRealm(getRealm());\n    securityManager.setCacheManager(cacheManager());\n    securityManager.setSessionManager(sessionManager());\n\n    return securityManager;\n}\n</code></pre><hr>\n<p>启动redis服务测试</p>\n<p>登陆后能在redis库中看到新增的shirosession字段</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1921b2jsej30ag01emwz.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"Remember-Me功能探索\"><a href=\"#Remember-Me功能探索\" class=\"headerlink\" title=\"Remember Me功能探索\"></a>Remember Me功能探索</h2><p>默认情况下登陆时附带的Remember me值为false</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1923btxxyj30kq06it96.jpg\" alt=\"\"></p>\n<p>手动设置为true后，打开浏览器登陆后</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1924eviirj30cv01w745.jpg\" alt=\"\"></p>\n<p>能在cookie中看到多出了一个rememberMe字段</p>\n<p>实际上并没有发挥效果，需要更改其他的配置</p>\n<p>具体下面这篇博客讲的很清楚</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/nsrainbow/article/details/36945267/\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/nsrainbow/article/details/36945267/</a></p>\n</blockquote>\n","categories":["shiro"],"tags":["redis"]},{"title":"【vue】引入ECharts图表和组件","url":"/2019/03/21/%E3%80%90vue%E3%80%91%E5%BC%95%E5%85%A5ECharts%E5%9B%BE%E8%A1%A8%E5%92%8C%E7%BB%84%E4%BB%B6/","content":"<p><em>如何在Vue项目中画出优雅的图表？</em></p>\n<p><strong>ECharts</strong><br>文档如下</p>\n<blockquote>\n<p><a href=\"https://www.echartsjs.com/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts\" target=\"_blank\" rel=\"noopener\">https://www.echartsjs.com/tutorial.html#%E5%9C%A8%20webpack%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20ECharts</a></p>\n</blockquote>\n<h2 id=\"引入步骤\"><a href=\"#引入步骤\" class=\"headerlink\" title=\"引入步骤\"></a>引入步骤</h2><ul>\n<li><p>安装ECharts</p>\n<pre><code>npm install echarts --save\n</code></pre></li>\n<li><p>定义html容器用来渲染echarts图表</p>\n<pre><code>&lt;div class=&quot;chart&quot; id=&quot;myChart&quot; :style=&quot;{width: &apos;500px&apos;, height: &apos;500px&apos;}&quot;&gt;&lt;/div&gt;\n</code></pre></li>\n</ul>\n<pre><code>:style里可以设置图表大小\n</code></pre><ul>\n<li><p>引入echarts组件</p>\n<pre><code>// 引入基本模板\nlet echarts = require(&apos;echarts/lib/echarts&apos;)\n// 引入柱状图组件\nrequire(&apos;echarts/lib/chart/pie&apos;)\nrequire(&apos;echarts/lib/chart/bar&apos;)\nrequire(&apos;echarts-gl&apos;)\n\n// 组件\nrequire(&apos;echarts/lib/component/tooltip&apos;)\nrequire(&apos;echarts/lib/component/title&apos;)\nrequire(&quot;echarts/lib/component/dataset&quot;)\n</code></pre></li>\n<li><p>初始化页面容器</p>\n<p> 先设置一个页面变量mychart，在mounted函数或者created函数里</p>\n<pre><code>this.myChart = echarts.init(document.getElementById(&apos;myChart&apos;));\n</code></pre></li>\n<li><p>配置图表option(关键)</p>\n<p> 在画图的方法里（可以直接在mounted里或者点击事件之类的里面），定义一个option</p>\n<pre><code>let option = {\n    title:{ \n        text: me.title,\n        left:&apos;center&apos;,\n        top:&apos;5px&apos;,\n        textStyle:{\n            color:&apos;#ccc&apos;,\n            fontStyle:&apos;normal&apos;,\n            fontWeight:&apos;bold&apos;,\n            fontFamily:&apos;sans-serif&apos;,\n    　　　　 fontSize:30\n        }\n    },\n    tooltip:{},\n    backgroundColor: &apos;#2c343c&apos;,\n    visualMap: {\n        show: false,\n        inRange: {\n            colorLightness: [0.5, 1],\n        }\n    },\n    series : [\n        {\n            name: &apos;人数&apos;,\n            type: me.type,\n            radius: &apos;55%&apos;,\n            data: me.items,\n            roseType: &apos;angle&apos;,\n            label: {\n                normal: {\n                    textStyle: {\n                        color: &apos;rgba(255, 255, 255, 0.3)&apos;\n                    }\n                }\n            },\n            labelLine: {\n                normal: {\n                    lineStyle: {\n                        color: &apos;rgba(255, 255, 255, 0.3)&apos;\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    shadowBlur: 200,\n                    shadowColor: &apos;rgba(0, 200, 150, 0.5)&apos;\n                }\n            }\n        }\n    ]\n};\n</code></pre></li>\n<li><p>title是指图表名，可以设置样式</p>\n</li>\n<li><p>tooltip类似于小提示，鼠标放在目标上会有提示框</p>\n</li>\n<li><p>visualMap可以设置图表的变化范围，可以事让结果更加明显</p>\n</li>\n<li><p>series里主要设置数据，不同类型的图表有不同的配置，上面代码是南丁格尔饼图的示例，一般设置type，有下面这些类型</p>\n<ul>\n<li>bar 直方图</li>\n<li>pie 饼图</li>\n<li>bar3D 3D图（需要安装echarts-gl）</li>\n<li>scatter 散点图</li>\n<li>等等…可以去官网查看更多类型</li>\n<li>引入dataset可以更方便管理数据，数据通过异步请求获取，传入前台的变量注入series里</li>\n</ul>\n</li>\n</ul>\n<ol start=\"6\">\n<li><p>注入页面容器</p>\n<pre><code>me.myChart.setOption(option);\n</code></pre></li>\n</ol>\n<p>需要绘制3D图需要安装echats-gl，步骤和上面一致</p>\n<hr>\n<p>结果如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1agz50czvj30h60e7q5u.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1agzt0iyuj30ox0gowkp.jpg\" alt=\"\"></p>\n<p>左下的那个条就是visualMap的效果</p>\n<hr>\n<p>实际使用时并不需要引入echarts的所有组件，可以按需引入对应的模块列表</p>\n<blockquote>\n<p><a href=\"https://github.com/apache/incubator-echarts/blob/master/index.js\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-echarts/blob/master/index.js</a></p>\n</blockquote>\n<p>具体每种图表的配置都不太一样，讲起来太繁杂，需要时可以自行查阅</p>\n<blockquote>\n<p><a href=\"https://www.echartsjs.com/examples/\" target=\"_blank\" rel=\"noopener\">https://www.echartsjs.com/examples/</a></p>\n</blockquote>\n","categories":["前端"],"tags":["echarts"]},{"title":"我搬砖回来了~","url":"/2019/08/20/%E6%88%91%E6%90%AC%E7%A0%96%E5%9B%9E%E6%9D%A5%E4%BA%86/","content":"<p>这段时间忙于毕业和工作，很久都没写博客。习惯这种东西，一断就容易断很久很久。其实也有相当大的一部分原因是自己懒。</p>\n<p>毕业的这段时间，自己也没有花时间学习新东西，挺惭愧的，还沉迷于炉石传说[擦汗]不能自拔。</p>\n<p>毕业后6月3、4号拿到毕业证学位证，10号就出差到广州，然后正式进入工作状态。<br>第一天、第二天….都挺不安的，慢慢的自己摸、问，终于是熟悉了一些。</p>\n<p>很多时候觉得自己还是不要太胆小，敢做敢写，发现有问题了再改会印象深很多（当然熟悉了这样写不好）。</p>\n<hr>\n<p>正式工作后见识更多了、经验确实也丰富了许多。虽然没有正经学习新知识，但是对之前学过的技术在实际中的使用更容易理解了。<br>此外，对于代码的调试能力真的好了很多233（以前debug确实用不太熟），现在没事就得F7、F8、F9、Alt+F8等等测试。</p>\n<p>顺便热部署上的问题，使用JRebel发现热部署仍不生效？<br>配合Crtl+Shift+F9快捷键手动重新编译更改过的类，十分好用。</p>\n<p>SpringBoot测试类？加上</p>\n<pre><code>@RunWith(SpringRunner.class)  \n@SpringBootTest\n</code></pre><p>注解，轻轻松松测代码。</p>\n<p>报文格式太难看？<br>NotePad++安装JSON Viewer,Alt+L格式化，远离糟乱报文和代码！<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1g66a1h0qdwj30h906rmxc.jpg\" alt=\"\"></p>\n<p>此外还有很多分片表的问题，例如什么两个数据不在同一片上，联合查询查询不到，需要指定分片键或者分开执行，或者查询慢需要带上分片键条件一起执行。</p>\n<p>还遇到过很多奇奇怪怪的问题，例如navicat视图看不到表，只能通过sql语句查询（换个navicat版本就好了）。什么udal数据库不允许insert into…select…语法。<br>什么什么的。</p>\n<p>关于分布式这块，不同中心需要跨库查询或者操作数据时，不能直接执行，需要建微服务调来调去，配置服务提供者，在服务管理平台进行统一管理。</p>\n<p>缓存，远程服务器缓存老挂，于是配置成本地redis缓存用了很久。</p>\n<p>还有Nginx反向代理使用等等…</p>\n<hr>\n<p>总的来说，对自己提升来说还行，但是并没有学到太多新东西。</p>\n<p>这个xfff.xyz域名10月多貌似要过期了，续就不续了，买个新的吧，便宜一点233</p>\n<hr>\n<p>好吧，最后我还是续费了，不想再重新认证什么的了，闲时间太少了</p>\n","categories":["杂记"]},{"title":"SpringBoot学习使用(与mybatis plus整合)","url":"/2019/01/14/SpringBoot%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","content":"<p>以一个简单的Demo为例搭建一个简单的SpringBoot项目</p>\n<p>File–&gt;new–&gt;project</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz65o6go7mj30j10gfq3n.jpg\" alt=\"\"></p>\n<p>如上选择<br>若没有Spring Assistant选项要在plugins里安装该插件</p>\n<hr>\n<p>选择各种需要的选项后，next，选web项目，取名等等这里就不写了。。。</p>\n<p>项目建好了结构大概是这样的。（<del>这里我懒得创新的了，还有自己写的一些文件就忽略吧</del>）反正没有example里的那4个文件夹，还有resources里的mapper和static和templates。<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fz65uhufyfj30a10eh0t7.jpg\" alt=\"\"></p>\n<p>然后，打开pom文件加依赖–</p>\n<p>这个看起来很乱，不知道为什么粘贴过来就不排版了。</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  \n  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  \n &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  \n &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  \n &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;  \n &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;  \n  &lt;/parent&gt;  \n &lt;groupId&gt;com.example&lt;/groupId&gt;  \n &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt;  \n &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  \n &lt;name&gt;SpringBootDemo&lt;/name&gt;  \n &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;  \n\n &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;  \n &lt;/properties&gt;  \n &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  \n &lt;/dependency&gt;  \n &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt;  \n &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  \n &lt;scope&gt;runtime&lt;/scope&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  \n &lt;scope&gt;test&lt;/scope&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  \n &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;  \n &lt;version&gt;2.3&lt;/version&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;  \n &lt;artifactId&gt;velocity&lt;/artifactId&gt;  \n &lt;version&gt;1.7&lt;/version&gt;  \n &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  \n &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;  \n &lt;version&gt;2.3&lt;/version&gt;  \n &lt;/dependency&gt; &lt;/dependencies&gt;  \n &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  \n &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt;  \n &lt;filtering&gt;true&lt;/filtering&gt;  \n &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;  \n&lt;/project&gt;\n</code></pre><p>**这里有些包不配置的话后面会出错，像我就在mybatis—plus包上折腾了很久，网上很多人都说只引入mybatis-plus-boot-starter包就行，其实不对，一定要引入mybatis-plus的包。虽然你只使用mybatis-plus-boot-starter正常使用mybatis-plus封装好的mapper方法不会报错，但是当你想自定义xml文件，写语句时，使用时就会一直报如下错误</p>\n<p>#org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)<br>这个错误网上的解释大多都是xml文件名字或者namespace不匹配，但是这样是解决不了这个问题的。只有把mybatis plus包引入后，在springboot的application.properties里加入**</p>\n<pre><code>mybatis-plus.mapper-locations=classpath*:/mapper/*.xml\n</code></pre><p><strong>完美解决。</strong></p>\n<p>另外，对于mybatis plus的版本，也有很多问题，当我使用3.0以上版本的时候，很多类会找不到，比如自动生成器的AutoGenerator。这里我懒得去找新版本该怎么使用，下次再找吧。</p>\n<p>还有那个velocity的依赖是模版引擎的依赖，不添加后来运行也会报错</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_39609151/article/details/82855305\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_39609151/article/details/82855305</a></p>\n</blockquote>\n<hr>\n<p>利用mybatis plus的生成器生成（地址<a href=\"http://xfff.xyz/2019/01/10/mybatis-plus%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/\">CLICK</a>）各层代码后，我们把mapper的xml文件放入resource目录下（新建mapper目录放入）。</p>\n<p>在mapper接口类上加上注解@Mapper<br>或者在springBoot启动类上加上注解扫描mapper，如下</p>\n<pre><code>/*@ComponentScan  \n@EnableAutoConfiguration*/  \n@SpringBootApplication  \n@MapperScan(&quot;com.example.mapper&quot;)  \npublic class SpringBootDemoApplication {  \n\n   public static void main(String[] args) {  \n      SpringApplication.run(SpringBootDemoApplication.class, args);  \n  }  \n\n}\n</code></pre><p>在application.properties里配置数据库和其他的属性</p>\n<p>如下</p>\n<pre><code>server.port=8080  \n\nspring.datasource.url=jdbc:mysql://localhost:3306/mpdemo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;&amp;serverTimezone=GMT  \nspring.datasource.username=root  \nspring.datasource.password=olonn  \nspring.datasource.driverClassName=com.mysql.cj.jdbc.Driver  \n\nmybatis-plus.mapper-locations=classpath*:/mapper/*.xml  \n#mybatis-plus.type-aliases-package=com....\n</code></pre><p>这里我们用的mybatis plus就不需要别名了，另外前面引入了mybatis plus 的依赖，才能写成mybatis-plus…的形式，不然就用mybatis…（这样不能自定义xml内容）</p>\n<hr>\n<p>我们在xml里新写几条自定义方法语句</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  \n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  \n&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;  \n\n  &lt;!-- 开启二级缓存 --&gt;  \n&lt;!--    &lt;cache type=&quot;org.mybatis.caches.ehcache.LoggingEhcache&quot;/&gt;--&gt;  \n\n &lt;!-- 通用查询映射结果 --&gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.beans.User&quot;&gt;  \n &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;  \n &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;  \n &lt;result column=&quot;birth&quot; property=&quot;birth&quot; /&gt;  \n &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;  \n &lt;result column=&quot;dog&quot; property=&quot;dog&quot; /&gt;  \n &lt;/resultMap&gt;  \n  &lt;!-- 通用查询结果列 --&gt;  \n  &lt;sql id=&quot;Base_Column_List&quot;&gt;  \n  id, name, birth, age, dog  \n    &lt;/sql&gt;  \n\n &lt;sql id=&quot;My_Column_List&quot;&gt;  \n  name, birth, age, dog  \n    &lt;/sql&gt;  \n\n &lt;select id=&quot;selectFour&quot; resultType=&quot;com.example.beans.User&quot;&gt;  \n  SELECT * from USER where id=4  \n    &lt;/select&gt;  \n\n &lt;insert id=&quot;insertOneCo&quot;&gt;  \n  insert into USER(&lt;include refid=&quot;My_Column_List&quot;/&gt;)  \n          value(#{name},#{birth},#{age},#{dog})  \n    &lt;/insert&gt;  \n\n&lt;/mapper&gt;\n</code></pre><p>Mapper层</p>\n<pre><code>package com.example.mapper;  \n\nimport com.example.beans.User;  \nimport com.baomidou.mybatisplus.mapper.BaseMapper;  \nimport org.apache.ibatis.annotations.Mapper;  \n\n/**  \n * &lt;p&gt;  \n  *  Mapper 接口  \n * &lt;/p&gt;  \n  *  \n * @author xfff  \n * @since 2019-01-14  \n */  \n@Mapper  \npublic interface UserMapper extends BaseMapper&lt;User&gt; {  \n\n    User selectFour();  \n void insertOneCo(User user);  \n}\n</code></pre><p>Service层：</p>\n<pre><code>package com.example.service;  \n\nimport com.example.beans.User;  \nimport com.baomidou.mybatisplus.service.IService;  \n\n/**  \n * &lt;p&gt;  \n  *  服务类  \n * &lt;/p&gt;  \n  *  \n * @author xfff  \n * @since 2019-01-14  \n */public interface UserService extends IService&lt;User&gt; {  \n    User selectFour();  \n}\n</code></pre><p>实现类：</p>\n<pre><code>package com.example.service.impl;  \n\nimport com.example.beans.User;  \nimport com.example.mapper.UserMapper;  \nimport com.example.service.UserService;  \nimport com.baomidou.mybatisplus.service.impl.ServiceImpl;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.stereotype.Service;  \n\n/**  \n * &lt;p&gt;  \n  *  服务实现类  \n * &lt;/p&gt;  \n  *  \n * @author xfff  \n * @since 2019-01-14  \n */@Service  \npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {  \n    @Autowired  \n  private UserMapper userMapper;  \n\n\n  @Override  \n  public User selectFour() {  \n        User user=userMapper.selectFour();  \n return user;  \n  }  \n}\n</code></pre><p>Controller：</p>\n<pre><code>package com.example.controller;  \n\n\nimport com.example.beans.User;  \nimport com.example.mapper.UserMapper;  \nimport com.example.service.UserService;  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \n\nimport org.springframework.stereotype.Controller;  \nimport org.springframework.web.bind.annotation.ResponseBody;  \nimport org.springframework.web.bind.annotation.RestController;  \n\nimport java.util.Date;  \n\n/**  \n * &lt;p&gt;  \n  *  前端控制器  \n * &lt;/p&gt;  \n  *  \n * @author xfff  \n * @since 2019-01-14  \n */@RestController  \n@RequestMapping(&quot;/user&quot;)  \npublic class UserController {  \n\n    @Autowired  \n  private UserService userService;  \n\n  @Autowired  \n  private UserMapper userMapper;  \n\n  @RequestMapping(&quot;/getU&quot;)  \n    @ResponseBody  \n  public User user(){  \n        return userService.selectById(4);  \n  }  \n\n    @RequestMapping(&quot;/sf&quot;)  \n    @ResponseBody  \n  public User selectFour(){  \n        return userService.selectFour();  \n  }  \n\n    @RequestMapping(&quot;/haha&quot;)  \n    @ResponseBody  \n  public String haha(){  \n        User auser=new User();  \n  auser.setAge(14);  \n  auser.setBirth(new Date());  \n  auser.setName(&quot;HHAHAHA&quot;);  \n  auser.setDog(&quot;OTOT&quot;);  \n  userMapper.insertOneCo(auser);  \n return &quot;OKOK&quot;;  \n  }  \n\n}\n</code></pre><p>运行SpringBoot启动类，该类要放在和其他包同级或上级下。</p>\n<p>相比于SSM框架，搭建一个项目springboot快很多<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fz66r08nilj30p4047t8x.jpg\" alt=\"\"><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fz66qhds83j30or04faaa.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sgy1fz66rkxsq0j30i106mdg7.jpg\" alt=\"\"></p>\n<hr>\n<p>另外，Controller上的注解若为RestController的话，返回的就是像json和普通类型数据，Controller可以返回页面。<br>具体参考</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/wuzengwen18914044177/article/details/78342517\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/wuzengwen18914044177/article/details/78342517</a></p>\n</blockquote>\n<p>另外在springboot项目中，resource下的static目录为静态目录，可以直接在地址栏输入对应的地址访问。</p>\n<hr>\n<p>继续学习深入吧~</p>\n","categories":["SpringBoot"],"tags":["mybatis_plus","mybatis","springboot"]},{"title":"mybatis plus简单使用","url":"/2019/01/09/mybatis-plus%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"<p>首先，贴上官网</p>\n<blockquote>\n<p><a href=\"https://mp.baomidou.com/\" target=\"_blank\" rel=\"noopener\">https://mp.baomidou.com/</a></p>\n</blockquote>\n<p><a href=\"https://github.com/baomidou/mybatis-plus\" target=\"_blank\" rel=\"noopener\">MyBatis-Plus</a>（简称 MP）是一个 <a href=\"http://www.mybatis.org/mybatis-3/\" target=\"_blank\" rel=\"noopener\">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>\n<hr>\n<h2 id=\"引入依赖\"><a href=\"#引入依赖\" class=\"headerlink\" title=\"引入依赖\"></a>引入依赖</h2><pre><code>&lt;dependency&gt;  \n &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  \n &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;  \n &lt;version&gt;2.3&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;junit&lt;/groupId&gt;  \n &lt;artifactId&gt;junit&lt;/artifactId&gt;  \n &lt;version&gt;4.12&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;  \n &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;  \n &lt;version&gt;1.1.11&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;mysql&lt;/groupId&gt;  \n &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  \n &lt;version&gt;5.1.47&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;com.mchange&lt;/groupId&gt;  \n &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  \n &lt;version&gt;0.9.5.2&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;!--spring--&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  \n &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  \n &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  \n &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  \n &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  \n&lt;/dependency&gt;  \n&lt;dependency&gt;  \n &lt;groupId&gt;org.springframework&lt;/groupId&gt;  \n &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  \n &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  \n&lt;/dependency&gt;\n</code></pre><hr>\n<p><strong>新建一个pojo类，对应表的字段</strong></p>\n<pre><code>package com.xff.pojo;  \n\n\nimport com.baomidou.mybatisplus.annotations.TableId;  \nimport com.baomidou.mybatisplus.enums.IdType;  \n\nimport java.util.Date;  \n\n/**  \n * * 这里可以使用@TableName()指定映射的表名 */public class User {  \n\n    @TableId(value = &quot;id&quot;,type = IdType.AUTO)//value是对应数据库字段的名称，type为主键策略  \n  private int id;  \n private String name;  \n private Date birth;  \n private int age;  \n private String dog;  \n\n  /**  \n * 如果变量名和表里的字段名不符 * 可以使用@TableField指定对应表中的字段 * * @return  \n  */  \n\n  public int getId() {  \n        return id;  \n  }  \n\n    public void setId(int id) {  \n        this.id = id;  \n  }  \n\n    public String getName() {  \n        return name;  \n  }  \n\n    public void setName(String name) {  \n        this.name = name;  \n  }  \n\n    public Date getBirth() {  \n        return birth;  \n  }  \n\n    public void setBirth(Date birth) {  \n        this.birth = birth;  \n  }  \n\n    public int getAge() {  \n        return age;  \n  }  \n\n    public void setAge(int age) {  \n        this.age = age;  \n  }  \n\n    public String getDog() {  \n        return dog;  \n  }  \n\n    public void setDog(String dog) {  \n        this.dog = dog;  \n  }  \n\n    @Override  \n  public String toString() {  \n        return &quot;User{&quot; +  \n                &quot;id=&quot; + id +  \n                &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; +  \n                &quot;, birth=&quot; + birth +  \n                &quot;, age=&quot; + age +  \n                &quot;, dog=&apos;&quot; + dog + &apos;\\&apos;&apos; +  \n                &apos;}&apos;;  \n  }  \n}\n</code></pre><hr>\n<p><strong>新建一个Mapper并继承Mybatis Plus里的BaseMapper类</strong></p>\n<pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {  \n\n}\n</code></pre><hr>\n<h1 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h1><h2 id=\"spring\"><a href=\"#spring\" class=\"headerlink\" title=\"spring\"></a>spring</h2><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  \n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  \n  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  \n  xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;  \n  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  \n http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;  \n\n\n &lt;context:component-scan base-package=&quot;com.xff.service&quot;/&gt;  \n &lt;context:component-scan base-package=&quot;com.xff.mapper&quot; /&gt;  \n &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;  \n  &lt;!-- 加载配置文件 --&gt;  \n  &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;  \n\n &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;  \n &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;  \n &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;  \n &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;  \n &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;  \n &lt;/bean&gt;  \n  &lt;!-- sqlSessinFactory --&gt;  \n  &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean&quot;&gt;  \n  &lt;!-- 加载mybatis的配置文件 --&gt;  \n  &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot; /&gt;  \n  &lt;!-- 数据源 --&gt;  \n  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  \n &lt;property name=&quot;globalConfig&quot; ref=&quot;globalConfiguration&quot; /&gt;  \n &lt;/bean&gt;  \n  &lt;!--mybatisplus全局配置--&gt;  \n  &lt;bean id=&quot;globalConfiguration&quot; class=&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;  \n\n  &lt;!--  \n 在2.3版本以后，dbColumnUnderline 默认值就是true 驼峰命名转换为下划线命名 user_name对应userName --&gt;  &lt;property name=&quot;dbColumnUnderline&quot; value=&quot;true&quot;&gt;&lt;/property&gt;  \n\n  &lt;!--  \n 全局的主键策略 省去了@TableId(value = &quot;id&quot;, type = IdType.AUTO)为主键策略 --&gt; &lt;!-- &lt;property name=&quot;idType&quot; value=&quot;0&quot;&gt;&lt;/property&gt; --&gt;  \n &lt;!-- 全局的表前缀策略配置 省略了@TableName(&quot;employee&quot;) ，如果你的表名为bt1_user --&gt; &lt;!-- &lt;property name=&quot;tablePrefix&quot; value=&quot;tbl_&quot;&gt;&lt;/property&gt; --&gt;  &lt;/bean&gt;  \n\n  &lt;!--Mapper注册--&gt;  \n  &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;  \n &lt;property name=&quot;basePackage&quot; value=&quot;com.xff.mapper&quot; /&gt;  \n &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;  \n &lt;/bean&gt;  \n  &lt;!--事务配置--&gt;  \n  &lt;bean id=&quot;transactionManager&quot;  \n  class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  \n &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  \n &lt;/bean&gt;  \n &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;  \n&lt;/beans&gt;\n</code></pre><hr>\n<h2 id=\"数据库配置db-properties\"><a href=\"#数据库配置db-properties\" class=\"headerlink\" title=\"数据库配置db.properties\"></a>数据库配置db.properties</h2><pre><code>jdbc.driver=com.mysql.jdbc.Driver  \njdbc.url=jdbc:mysql://localhost:3306/mpdemo  \njdbc.username=root  \njdbc.password=olonn\n</code></pre><hr>\n<h2 id=\"mybatis配置文件\"><a href=\"#mybatis配置文件\" class=\"headerlink\" title=\"mybatis配置文件\"></a>mybatis配置文件</h2><pre><code>&lt;!DOCTYPE configuration  \n  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  \n &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  \n&lt;configuration&gt;  \n\n\n&lt;/configuration&gt;\n</code></pre><hr>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><pre><code>import com.xff.mapper.UserMapper;  \nimport com.xff.pojo.User;  \nimport com.xff.service.UserService;  \nimport org.junit.Test;  \nimport org.springframework.beans.BeansException;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n\nimport java.util.Date;  \nimport java.util.List;  \n\n\npublic class TestMP {  \n\n\n\n    public TestMP() throws BeansException {  \n    }  \n\n    @Test  \n  public void test() throws BeansException {  \n        ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);  \n  UserMapper userMapper=ioc.getBean(UserMapper.class);  \n  UserService userService=ioc.getBean(UserService.class);  \n  System.out.println(userService.selectById(1));  \n  User user=new User();  \n  user.setAge(111);  \n  user.setBirth(new Date());  \n  user.setName(&quot;嘻哈哈&quot;);  \n  user.setDog(&quot;MDOG&quot;);  \n  userService.insert(user);  \n  List&lt;User&gt; alist=userService.selectList(null);  \n  System.out.println(alist.get(0).toString()+alist.get(1).toString());  \n\n  /* new com.xff.Test().selectMM();*/  \n\n  }  \n}\n</code></pre><hr>\n<p>打印信息</p>\n<pre><code>User{id=1, name=&apos;呜哈哈&apos;, birth=Wed Jan 09 00:00:00 CST 2019, age=43, dog=&apos;tony&apos;}User{id=2, name=&apos;嘻哈哈&apos;, birth=Wed Jan 09 00:00:00 CST 2019, age=111, dog=&apos;MDOG&apos;}\n</code></pre><hr>\n<p>可以看到mybatis plus并不需要我们写对应的mapperxml文件，就能进行数据库访问。</p>\n<p>实际上好像是封装了一个mapperProxy代理类，会生成对应的sql语句，只需要继承BaseMapper接口类即可。后续再追详细代码…</p>\n<hr>\n<h2 id=\"过程中遇到的问题\"><a href=\"#过程中遇到的问题\" class=\"headerlink\" title=\"过程中遇到的问题:\"></a>过程中遇到的问题:</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/m0_38064463/article/details/80795840\" target=\"_blank\" rel=\"noopener\"># org.xml.sax.SAXParseException; lineNumber: 2; columnNumber: 1; 文件提前结束。</a></p>\n</blockquote>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><blockquote>\n<p><a href=\"https://blog.csdn.net/qq_37171353/article/details/80887280\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_37171353/article/details/80887280</a></p>\n</blockquote>\n","categories":["mybatis"],"tags":["mybatis_plus"]},{"title":"mybatis plus插件使用","url":"/2019/01/11/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"分页插件\"><a href=\"#分页插件\" class=\"headerlink\" title=\"分页插件\"></a>分页插件</h1><p>使用mybatis plus时分页</p>\n<p>可以直接使用生成的mapper或者service封装好的分页方法</p>\n<pre><code>userService.selectPage(new Page&lt;&gt;(6,5),null).getRecords().stream().forEach(System.out::println);\n</code></pre><p>但是这种方法只是物理上的分页，实际查询时会把所有记录全部查询出来，然后在内存中分页，效率不高。</p>\n<p>一般我们使用mybatis plus 自带的分页插件实现分页功能。</p>\n<p>首先，在spring配置文件中配置分页插件。</p>\n<p>配置在sqlSessionFactory的bean标签下</p>\n<pre><code>&lt;!-- 插件注册 --&gt;  \n&lt;property name=&quot;plugins&quot;&gt;  \n &lt;list&gt;  &lt;!-- 注册分页插件 --&gt;  \n  &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot;&gt;&lt;/bean&gt;  \n\n  &lt;!-- 注册执行分析插件 --&gt;  \n  &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.SqlExplainInterceptor&quot;&gt;  \n &lt;property name=&quot;stopProceed&quot; value=&quot;true&quot;&gt;&lt;/property&gt;  \n &lt;/bean&gt;  \n  &lt;!-- 注册性能分析插件 --&gt;  \n  &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.PerformanceInterceptor&quot;&gt;  \n &lt;property name=&quot;format&quot; value=&quot;true&quot;&gt;&lt;/property&gt;  \n  &lt;!-- &lt;property name=&quot;maxTime&quot; value=&quot;5&quot;&gt;&lt;/property&gt; --&gt;  \n  &lt;/bean&gt;  \n\n  &lt;!-- 注册乐观锁插件 --&gt;  \n  &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor&quot;&gt;  \n &lt;/bean&gt;  \n &lt;/list&gt;  \n&lt;/property&gt;\n</code></pre><p>在plugins属性设置里，查看源码可以看到是使用数组设值。</p>\n<pre><code>public void setPlugins(org.apache.ibatis.plugin.Interceptor[] plugins) { /* compiled code */ }\n</code></pre><p>因此我们用list标签配置各种插件。</p>\n<p>配置完成后，我们这样就能实现分页：</p>\n<pre><code>UserService userService=ioc.getBean(UserService.class);  \nPage&lt;User&gt; page = new Page&lt;&gt;(3,5);  \n\nPage&lt;User&gt; emps =  \n        userService.selectPage(page, null);  \nSystem.out.println(emps);  \n\n\nSystem.out.println(&quot;===============获取分页相关的一些信息======================&quot;);  \n\nSystem.out.println(&quot;总条数:&quot; +page.getTotal());  \nSystem.out.println(page.getRecords());  \nSystem.out.println(&quot;当前页码: &quot;+  page.getCurrent());  \nSystem.out.println(&quot;总页码:&quot; + page.getPages());  \nSystem.out.println(&quot;每页显示的条数:&quot; + page.getSize());  \nSystem.out.println(&quot;是否有上一页: &quot; + page.hasPrevious());  \nSystem.out.println(&quot;是否有下一页: &quot; + page.hasNext());  \n\n//将查询的结果封装到page对象中  \npage.setRecords(emps.getRecords());\n</code></pre><p>我们可以通过page对象获得我们需要的各种值。</p>\n<hr>\n<h1 id=\"分析插件\"><a href=\"#分析插件\" class=\"headerlink\" title=\"分析插件\"></a>分析插件</h1><h2 id=\"执行分析插件\"><a href=\"#执行分析插件\" class=\"headerlink\" title=\"执行分析插件\"></a>执行分析插件</h2><p>主要用来对数据库操作进行分析，若是全表删除或者更新操作，会导致操作失败。</p>\n<p>和sql语句中的Explain关键字有关。</p>\n<h2 id=\"性能分析插件\"><a href=\"#性能分析插件\" class=\"headerlink\" title=\"性能分析插件\"></a>性能分析插件</h2><p>可以对数据库操作进行分析，例如指定限制时间，若是对数据库的操作超时等，返回操作失败的结果。</p>\n<hr>\n<hr>\n<h2 id=\"乐观锁插件\"><a href=\"#乐观锁插件\" class=\"headerlink\" title=\"乐观锁插件\"></a>乐观锁插件</h2><p>上面有配置，在表对应的javabean类里，新添字段，然后在字段上加上@Version注解。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz2myyutlqj307i01sdfn.jpg\" alt=\"\"></p>\n<p>表中也新增该字段，然后在每次对数据库进行操作的时候，会判断你操作中的version值是否和数据库中的一致，如果此时有其他人对表中你将操作的字段进行了更改，version会自增，你的version值和表中不一致会导致操作失败。</p>\n<hr>\n<pre><code>&lt;!-- 定义MybatisPlus的全局策略配置--&gt;  \n&lt;bean id =&quot;globalConfiguration&quot; class=&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;  \n  &lt;!-- 在2.3版本以后，dbColumnUnderline 默认值就是true --&gt;  \n  &lt;property name=&quot;dbColumnUnderline&quot; value=&quot;true&quot;&gt;&lt;/property&gt;  \n  &lt;!-- Mysql 全局的主键策略 --&gt;  \n &lt;!-- &lt;property name=&quot;idType&quot; value=&quot;0&quot;&gt;&lt;/property&gt; --&gt;    &lt;!-- Oracle全局主键策略 --&gt;  \n  &lt;property name=&quot;idType&quot; value=&quot;1&quot;&gt;&lt;/property&gt;  \n  &lt;!-- 全局的表前缀策略配置 --&gt;  \n  &lt;property name=&quot;tablePrefix&quot; value=&quot;tbl_&quot;&gt;&lt;/property&gt;  \n  &lt;!--注入自定义全局操作   \n   &lt;property name=&quot;sqlInjector&quot; ref=&quot;mySqlInjector&quot;&gt;&lt;/property&gt;  \n --&gt; &lt;!-- 注入逻辑删除 --&gt;  &lt;property name=&quot;sqlInjector&quot; ref=&quot;logicSqlInjector&quot;&gt;&lt;/property&gt;  \n  &lt;!-- 注入逻辑删除全局值 --&gt;  \n  &lt;property name=&quot;logicDeleteValue&quot; value = &quot;-1&quot;&gt;&lt;/property&gt;  \n &lt;property name=&quot;logicNotDeleteValue&quot; value=&quot;1&quot;&gt;&lt;/property&gt;  \n  &lt;!-- 注入公共字段填充处理器 --&gt;  \n  &lt;property name=&quot;metaObjectHandler&quot; ref=&quot;myMetaObjectHandler&quot;&gt;&lt;/property&gt;  \n  &lt;!-- 注入Oracle主键Sequence --&gt;  \n  &lt;property name=&quot;keyGenerator&quot; ref=&quot;oracleKeyGenerator&quot;&gt;&lt;/property&gt;  \n&lt;/bean&gt;  \n\n\n&lt;!-- 定义自定义注入器 --&gt;  \n&lt;bean id=&quot;mySqlInjector&quot; class=&quot;com.atguigu.mp.injector.MySqlInjector&quot;&gt;&lt;/bean&gt;  \n\n&lt;!-- 逻辑删除 --&gt;  \n&lt;bean id=&quot;logicSqlInjector&quot; class=&quot;com.baomidou.mybatisplus.mapper.LogicSqlInjector&quot;&gt;&lt;/bean&gt;  \n\n&lt;!-- 公共字段填充 处理器 --&gt;  \n&lt;bean id=&quot;myMetaObjectHandler&quot; class=&quot;com.atguigu.mp.metaObjectHandler.MyMetaObjectHandler&quot;&gt; &lt;/bean&gt;  \n\n&lt;!-- 配置Oracle主键Sequence --&gt;  \n&lt;bean id=&quot;oracleKeyGenerator&quot; class=&quot;com.baomidou.mybatisplus.incrementer.OracleKeyGenerator&quot;&gt;&lt;/bean&gt;\n</code></pre><hr>\n<h2 id=\"逻辑删除\"><a href=\"#逻辑删除\" class=\"headerlink\" title=\"逻辑删除\"></a>逻辑删除</h2><p>同样，配置完后，给表和对应的javabean新增一个字段，然后用上注解</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz2n8b2ocmj309i01jjr8.jpg\" alt=\"\"></p>\n<p>这样表中每个数据被删除时并不会真正从表中移除，而是将该数据的logicFlag字段更改为-1，然后其他操作不能对该行数据进行影响。</p>\n<hr>\n<h2 id=\"自定义全局操作\"><a href=\"#自定义全局操作\" class=\"headerlink\" title=\"自定义全局操作\"></a>自定义全局操作</h2><p>当想自定义一个新方法的时候又不想写对应的xml文件，可以通过该方法，配置完后，在Mapper内新建一个方法</p>\n<pre><code>public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; {  \n\n   int deleteAll();  \n}\n</code></pre><p>然后新建类MySqlInjector</p>\n<pre><code>/**  \n * 自定义全局操作 */public class MySqlInjector  extends AutoSqlInjector{  \n\n   /**  \n * 扩展inject 方法，完成自定义全局操作 */  @Override  \n  public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass,  \n  Class&lt;?&gt; modelClass, TableInfo table) {  \n      //将EmployeeMapper中定义的deleteAll， 处理成对应的MappedStatement对象，加入到configuration对象中。  \n       //注入的SQL语句  \n  String sql = &quot;delete from &quot; +table.getTableName();  \n  //注入的方法名   一定要与EmployeeMapper接口中的方法名一致  \n  String method = &quot;deleteAll&quot; ;  \n  //构造SqlSource对象  \n  SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);  \n  //构造一个删除的MappedStatement  \n  this.addDeleteMappedStatement(mapperClass, method, sqlSource);  \n  }  \n}\n</code></pre><hr>\n<h2 id=\"公共字段填充器\"><a href=\"#公共字段填充器\" class=\"headerlink\" title=\"公共字段填充器\"></a>公共字段填充器</h2><p>如上配置之后</p>\n<p>在需要自动填充的字段上添加注解</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz2ng4teduj3087026jr9.jpg\" alt=\"\"></p>\n<p>这样当插入和更新操作时，会进入已注册的填充类中的方法检查</p>\n<p><strong>MyMetaObjectHandler</strong>：</p>\n<pre><code>/**  \n * 自定义公共字段填充处理器 */public class MyMetaObjectHandler extends MetaObjectHandler {  \n\n   /**  \n * 插入操作 自动填充 */  @Override  \n  public void insertFill(MetaObject metaObject) {  \n      //获取到需要被填充的字段的值  \n  Object fieldValue = getFieldValByName(&quot;name&quot;, metaObject);  \n if(fieldValue == null) {  \n         System.out.println(&quot;*******插入操作 满足填充条件*********&quot;);  \n  setFieldValByName(&quot;name&quot;, &quot;weiyunhui&quot;, metaObject);  \n  }  \n\n   }  \n   /**  \n * 修改操作 自动填充 */  @Override  \n  public void updateFill(MetaObject metaObject) {  \n      Object fieldValue = getFieldValByName(&quot;name&quot;, metaObject);  \n if(fieldValue == null) {  \n         System.out.println(&quot;*******修改操作 满足填充条件*********&quot;);  \n  setFieldValByName(&quot;name&quot;, &quot;weiyh&quot;, metaObject);  \n  }  \n   }  \n\n}\n</code></pre><p>当满足<strong>if</strong>语句中的条件的时候，会自动为下面设置的字段填充上设置的值。</p>\n<hr>\n<h2 id=\"Oracle实现自增操作\"><a href=\"#Oracle实现自增操作\" class=\"headerlink\" title=\"Oracle实现自增操作\"></a>Oracle实现自增操作</h2><p>学习oracle后明白，oracle里没有mysql一样的Auto_increment字段。</p>\n<p>一般我们使用序列Sequence来实现同样的功能</p>\n<p>如上配置后（记得设置主键策略为IdType.INPUT）</p>\n<p>在oracle里新建序列，然后在需要使用的javabean类上注解</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz2nntp04yj30ak02rdfu.jpg\" alt=\"\"></p>\n<p>value值为你的序列名。</p>\n<p>另外，我们还可以使用多个类继承一个父类，然后在父类上添加该注解，实现多个类共用一个序列。</p>\n<hr>\n<hr>\n<p>另外，mybatis plus还有很多功能，如AR（Active Record），让javabean类继承Model类，然后自身可以调用对应的数据库操作方法</p>\n<p>如<br>User user=new User()；<br>user.setId(1);<br>user.setName(“哈哈”);<br>user.updateById();</p>\n<hr>\n<p>还有什么动态切换数据源之类的功能…<br>具体上官网</p>\n<blockquote>\n<p><a href=\"https://mp.baomidou.com/guide/tenant.html\" target=\"_blank\" rel=\"noopener\">https://mp.baomidou.com/guide/tenant.html</a></p>\n</blockquote>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fz2nroh8pyj30mx0fadr2.jpg\" alt=\"\"></p>\n","categories":["mybatis"],"tags":["mybatis_plus"]},{"title":"vuejs发送异步请求","url":"/2019/01/29/vuejs%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>使用vue时如何发送请求？</p>\n<hr>\n<p>答：ajax，不过vue不使用jquery，那么需要引入一些HTTP库工具，使用其中封装好的请求方法即可</p>\n<p>superagent或者Axios（主流）<br>使用文档</p>\n<blockquote>\n<p><a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/yunye/axios/234845</a><br><a href=\"https://www.jianshu.com/p/1432e0f29abd\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/1432e0f29abd</a></p>\n</blockquote>\n<p>首先要安装相应的工具<br>运行命令</p>\n<pre><code>npm install xxx -D\n</code></pre><p>xxx替换为对应的组件名</p>\n<p>然后在src下的config目录新建js文件<br>假如现在使用的是superagent<br><strong>api.js</strong></p>\n<pre><code>// 配置API接口地址\nvar root = &apos;https://cnodejs.org/api/v1&apos;;\n// 引用superagent\nvar request = require(&apos;superagent&apos;);\n// 自定义判断元素类型JS\nfunction toType(obj) {\n  return ({}).toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase()\n}\n// 参数过滤函数\nfunction filter_null(o) {\n  for (var key in o) {\n    if (o[key] == null) {\n      delete o[key]\n    }\n    if (toType(o[key]) == &apos;string&apos;) {\n      o[key] = o[key].trim()\n      if (o[key].length == 0) {\n        delete o[key]\n      }\n    }\n  }\n  return o\n}\n/*\n  接口处理函数\n  这个函数每个项目都是不一样的，我现在调整的是适用于\n  https://cnodejs.org/api/v1 的接口，如果是其他接口\n  需要根据接口的参数进行调整。参考说明文档地址：\n  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd\n*/\nfunction _api_base(method, url, params, success, failure) {\n  var r = request(method, url).type(&apos;text/plain&apos;)\n  if (params) {\n    params = filter_null(params);\n    if (method === &apos;POST&apos; || method === &apos;PUT&apos;) {\n      if (toType(params) == &apos;object&apos;) {\n        params = JSON.stringify(params);\n      }\n      r = r.send(params)\n    } else if (method == &apos;GET&apos; || method === &apos;DELETE&apos;) {\n      r = r.query(params)\n    }\n  }\n  r.end(function(err, res) {\n    if (err) {\n      alert(&apos;api error, HTTP CODE: &apos; + res.status);\n      return;\n    };\n    if (res.body.success == true) {\n      if (success) {\n        success(res.body);\n      }\n    } else {\n      if (failure) {\n        failure(res.body);\n      } else {\n        alert(&apos;error: &apos; + JSON.stringify(res.body));\n      }\n    }\n  });\n};\n// 返回在vue模板中的调用接口\nexport default {\n  get: function(url, params, success, failure) {\n    return _api_base(&apos;GET&apos;, root + &apos;/&apos; + url, params, success, failure)\n  },\n  post: function(url, params, success, failure) {\n    return _api_base(&apos;POST&apos;, root + &apos;/&apos; + url, params, success, failure)\n  },\n  put: function(url, params, success, failure) {\n    return _api_base(&apos;PUT&apos;, root + &apos;/&apos; + url, params, success, failure)\n  },\n  delete: function(url, params, success, failure) {\n    return _api_base(&apos;DELETE&apos;, root + &apos;/&apos; + url, params, success, failure)\n  },\n}\n</code></pre><p>这是原博作者封装好的请求方法，开头的api地址是我们项目的基础请求地址头<br>这里填的是cnodejs.org提供的api接口</p>\n<p>使用时只需要</p>\n<p>先在启动入口里全局配置好</p>\n<pre><code>import api from &apos;./config/api&apos;\nVue.prototype.$api=api\n</code></pre><p>这两行的意思大概就是把api.js文件注册到全局，然后可以通过 $api.方法名 调用该文件里的方法。</p>\n<hr>\n<p>如</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n    import Header from &apos;../components/header&apos;\n    import Footer from &apos;../components/footer&apos;\n\n\n\n    export default{\n        components:{Header,Footer},\n        data(){\n            return{\n                lists:[]\n            }\n        },\n        created(){\n            this.get_data()\n        },\n        methods:{\n            get_data:function(params){\n                var v=this\n                if(!params) params={}\n                    v.$api.get(&apos;topics&apos;,params,function(r){\n                        v.lists=r.data;\n                    })\n            },\n        },\n    }\n&lt;/script&gt;\n</code></pre><p>created是该页面创建时执行的方法，params是传入的参数，’topics’是请求的地址，r是成功执行时返回的数据</p>\n<hr>\n<p>然后该页面的template块为</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;Header&gt;&lt;/Header&gt;\n    &lt;ul class=&quot;list&quot;&gt;\n      &lt;li v-for=&quot;item in lists&quot;&gt;\n          &lt;time v-text=&quot;$fortime.goodTime(item.create_at)&quot;&gt;&lt;/time&gt;\n          &lt;router-link :to=&quot;&apos;/content/&apos; + item.id&quot;&gt;{{item.title}}&lt;/router-link&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;Footer&gt;&lt;/Footer&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre><p>fortime是我注册的工具类，用来格式化时间<br>router-link相当于a标签，请求的地址是/content/加上item的id</p>\n<hr>\n<p>接下来写content里的内容，这次使用axios工具<br>一样，先install，创建一个index.js写入</p>\n<pre><code>// 配置API接口地址\nvar root = &apos;/api/v1&apos;\n// 引用axios\nvar axios = require(&apos;axios&apos;)\n// 自定义判断元素类型JS\nfunction toType (obj) {\n  return ({}).toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase()\n}\n// 参数过滤函数\nfunction filterNull (o) {\n  for (var key in o) {\n    if (o[key] === null) {\n      delete o[key]\n    }\n    if (toType(o[key]) === &apos;string&apos;) {\n      o[key] = o[key].trim()\n    } else if (toType(o[key]) === &apos;object&apos;) {\n      o[key] = filterNull(o[key])\n    } else if (toType(o[key]) === &apos;array&apos;) {\n      o[key] = filterNull(o[key])\n    }\n  }\n  return o\n}\n/*\n  接口处理函数\n  这个函数每个项目都是不一样的，我现在调整的是适用于\n  https://cnodejs.org/api/v1 的接口，如果是其他接口\n  需要根据接口的参数进行调整。参考说明文档地址：\n  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd\n  主要是，不同的接口的成功标识和失败提示是不一致的。\n  另外，不同的项目的处理方法也是不一致的，这里出错就是简单的alert\n*/\n\nfunction apiAxios (method, url, params, success, failure) {\n  if (params) {\n    params = filterNull(params)\n  }\n  axios({\n    method: method,\n    url: url,\n    data: method === &apos;POST&apos; || method === &apos;PUT&apos; ? params : null,\n    params: method === &apos;GET&apos; || method === &apos;DELETE&apos; ? params : null,\n    baseURL: root,\n    withCredentials: false\n  })\n  .then(function (res) {\n    if (res.data.success === true) {\n      if (success) {\n        success(res.data)\n      }\n    } else {\n      if (failure) {\n        failure(res.data)\n      } else {\n        window.alert(&apos;error: &apos; + JSON.stringify(res.data))\n      }\n    }\n  })\n  .catch(function (err) {\n    let res = err.response\n    if (err) {\n      window.alert(&apos;api error, HTTP CODE: &apos; + res.status)\n    }\n  })\n}\n\n// 返回在vue模板中的调用接口\nexport default {\n  get: function (url, params, success, failure) {\n    return apiAxios(&apos;GET&apos;, url, params, success, failure)\n  },\n  post: function (url, params, success, failure) {\n    return apiAxios(&apos;POST&apos;, url, params, success, failure)\n  },\n  put: function (url, params, success, failure) {\n    return apiAxios(&apos;PUT&apos;, url, params, success, failure)\n  },\n  delete: function (url, params, success, failure) {\n    return apiAxios(&apos;DELETE&apos;, url, params, success, failure)\n  }\n}\n</code></pre><p><strong>！这里</strong>不直接用原api地址是因为cnode.js的接口处理的很好，解决了跨域的问题。实际项目中，很多接口不允许跨域请求。为了解决这个问题，采用webpack的代理的方式<br>在<strong>根目录的config文件夹</strong>下打开index.js，找到proxyTable这一行，里面就是我们要填的代理地址<br>这里我们写的是</p>\n<pre><code>proxyTable: {\n    &apos;/api/v1/**&apos;:{\n        target: &apos;https://cnodejs.org&apos;,\n        secure: false,\n        changeOrigin: false,\n\n    }\n},\n</code></pre><p>然后在main.js里注册</p>\n<pre><code>import aapi from &apos;./config/index&apos;\nVue.prototype.$axapi=aapi\n</code></pre><p>然后使用</p>\n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;myHeader&gt;&lt;/myHeader&gt;\n    &lt;h2 v-text=&quot;dat.title&quot;&gt;&lt;/h2&gt;\n    &lt;p v-if=dat.author&gt;作者：{{dat.author.loginname}}　　发表于：{{$fortime.goodTime(dat.create_at)}}&lt;/p&gt;\n    &lt;hr&gt;\n    &lt;article v-html=&quot;dat.content&quot;&gt;&lt;/article&gt;\n    &lt;h3&gt;网友回复：&lt;/h3&gt;\n    &lt;ul&gt;\n      &lt;li v-for=&quot;i in dat.replies&quot;&gt;\n        &lt;p&gt;评论者：{{i.author.loginname}}　　评论于：{{$fortime.goodTime(i.create_at)}}&lt;/p&gt;\n        &lt;article v-html=&quot;i.content&quot;&gt;&lt;/article&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;myFooter&gt;&lt;/myFooter&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport myHeader from &apos;../components/header.vue&apos;\nimport myFooter from &apos;../components/footer.vue&apos;\nexport default {\n  components: { myHeader, myFooter },\n  data () {\n    return {\n      id: this.$route.params.id,\n      dat: {}\n    }\n  },\n  created () {\n    this.getData()\n  },\n  methods: {\n    getData () {\n      this.$axapi.get(&apos;topic/&apos; + this.id, null, r =&gt; {\n        this.dat = r.data\n      })\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre><p>这里出过一个错就是，老提示loginname not defined，后来发现是author还没加载就加载了loginname，在p标签里加上v-if后解决问题</p>\n<hr>\n<p>运行结果<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fznl8issgwj30y30g0771.jpg\" alt=\"\"></p>\n<hr>\n<p>说明请求成功，具体项目代码在</p>\n<blockquote>\n<p><a href=\"https://github.com/HolyDogs/VueStructDemo\" target=\"_blank\" rel=\"noopener\">https://github.com/HolyDogs/VueStructDemo</a></p>\n</blockquote>\n","categories":["前端"],"tags":["vue","ajax"]},{"title":"【JAVA8新特性】","url":"/2018/10/20/%E3%80%90JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/","content":"<h2 id=\"一-Lambda表达式\"><a href=\"#一-Lambda表达式\" class=\"headerlink\" title=\"(一)Lambda表达式\"></a>(一)Lambda表达式</h2><p>java8新特性支持lambda表达式，能让代码看起来更简洁。</p>\n<pre><code>interface Aaa{\npublic void printz(String z);\n}\n\n//老版本\n    String t=&quot;gggg&quot;;\n    Aaa olda=new Aaa() {\n\n        @Override\n        public void printz(String z) {\n            // TODO Auto-generated method stub\n            System.out.println(z);\n        }\n    };\n    olda.printz(t);\n\n    //JAVA 8\n    //变量t在只后不得更改值，否则会报错，Local variable t defined in an enclosing\n    //scope must be final or effectively final\n    //lambda表达式内部只能调用final修饰的变量\n    Aaa zAaa=((String z)-&gt;System.out.println(z+&quot;qq&quot;+t));\n    zAaa.printz(t);\n\n    //老版本\n    Runnable oldrunnable=new Runnable() {\n\n        @Override\n        public void run() {\n            // TODO Auto-generated method stub\n            System.out.println(&quot;helloWorld&quot;);\n        }\n    };\n    new Thread(oldrunnable).start();\n\n    //java 8\n    new Thread(()-&gt;System.out.print(&quot;helloWorld8&quot;)).start();\n</code></pre><p>结果<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw6ltopgbuj303k01q0hu.jpg\" alt=\"\"></p>\n<h2 id=\"（二）方法引用\"><a href=\"#（二）方法引用\" class=\"headerlink\" title=\"（二）方法引用\"></a>（二）方法引用</h2><pre><code>      List&lt;Name&gt; names = new ArrayList&lt;Name&gt;();\n\n      names.add(new Name(&quot;Bob&quot;));\n      names.add(new Name(&quot;JECK&quot;));\n      names.add(new Name(&quot;AICE&quot;));\n      names.add(new Name(&quot;SENCE&quot;));\n      names.add(new Name(&quot;MONTE&quot;));\n\n\n\n      names.forEach(Name::printz);\n}\n\nclass Name{\n    private String name;\n    public Name(String name) {\n        this.name=name;\n    }\n\n    public void printz() {\n        System.out.println(name);\n    }\n}`\n</code></pre><p>输出<br>Bob<br>JECK<br>AICE<br>SENCE<br>MONTE</p>\n<h2 id=\"（三）函数式接口\"><a href=\"#（三）函数式接口\" class=\"headerlink\" title=\"（三）函数式接口\"></a>（三）函数式接口</h2><p>java8新提供了很多函数式接口，具体自行搜索，这里用其中一种做例子。</p>\n<pre><code>    public static void method1(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate) {\n    for (Integer integer : list) {\n        if(predicate.test(integer)) {\n            System.out.print(integer+&quot; &quot;);\n        }\n    }\n}\n    List&lt;Integer&gt; nIntegers=Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n    //如何获取list里大于5的元素呢？\n\n    //老方法\n    for (Integer integer : nIntegers) {\n        if(integer&gt;5) {\n            System.out.print(integer+&quot; &quot;);\n        }\n    }\n\n    System.out.println();\n\n    //运用java8提供的函数接口\n    method1(nIntegers, n-&gt;n&gt;5);\n\n    System.out.println();\n\n    //运用java8新特性省略方法，更简洁\n    nIntegers.stream().filter(n-&gt;n&gt;5).forEach(System.out::print);\n</code></pre><p>结果<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw6nh9r48ij303p01h0gw.jpg\" alt=\"\"></p>\n<h2 id=\"（四）默认方法\"><a href=\"#（四）默认方法\" class=\"headerlink\" title=\"（四）默认方法\"></a>（四）默认方法</h2><p>Java 8 新增了接口的默认方法。</p>\n<p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p>\n<p>我们只需在方法名前面加个default关键字即可实现默认方法<br>    为了解决接口的修改与现有的实现不兼容的问题。</p>\n<pre><code>public class Java8Test {\n\n@Test\npublic void test() {\n    System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));\n    CarS car=new CarS();\n    car.ss();\n\n}\n\npublic interface Car{\ndefault void haha() {\n    System.out.println(&quot;haha&quot;);\n}\n\n}\npublic interface Bus{\ndefault void haha() {\n    System.out.println(&quot;heihei&quot;);\n}\n}\npublic class CarS implements Car,Bus{\n\npublic void ss() {\n    haha();\n}\n\n@Override\npublic void haha() {\n    // TODO Auto-generated method stub\n    Bus.super.haha();\n    Car.super.haha();\n}\n}\n\n}\n</code></pre><h2 id=\"（五）Stream\"><a href=\"#（五）Stream\" class=\"headerlink\" title=\"（五）Stream\"></a>（五）Stream</h2><p>java8引入一种新的抽象称做流Stream，能以声明的方式来处理数据。</p>\n<p>下面代码实现了随机产生10个数，并把大于0的数输出。</p>\n<pre><code>Random random=new Random();\nrandom.ints().limit(10).filter(n-&gt;n&gt;0).forEach(System.out::println);\n</code></pre><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw6teiaq9ij305j01g0mq.jpg\" alt=\"\"></h2><p>下面代码对list里的字符串重复拼接输出到5条记录的数组里，并输出数组。            </p>\n<pre><code>List&lt;String&gt; sList=Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);\nSystem.out.println(sList.stream().map(n-&gt;n+n).limit(5).collect(Collectors.toList()));\n</code></pre><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fw6teszddcj306w00m0cp.jpg\" alt=\"\"></p>\n<p>另外，parallelStream()相对于stream()，是流并行处理方式。<br>统计结果的收集器</p>\n<pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);                 \nIntSummaryStatistics  stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); \nSystem.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); \nSystem.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); \nSystem.out.println(&quot;所有数之和 : &quot; + stats.getSum());\nSystem.out.println(&quot;平均数 : &quot; + stats.getAverage());\n</code></pre><h2 id=\"（六）Optional类\"><a href=\"#（六）Optional类\" class=\"headerlink\" title=\"（六）Optional类\"></a>（六）Optional类</h2><p>一个可以存放null的容器，解决了nullpoint空指针问题。</p>\n<pre><code>    Integer value1 = null;\nInteger value2 = 222;\nOptional&lt;Integer&gt; a = Optional.ofNullable(value1);\n\n  // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException\nOptional&lt;Integer&gt; b = Optional.of(value2);\n\nSystem.out.println(a.orElse(555));\nSystem.out.println(b.get());\n</code></pre><p>输出555<br>222<br>其中a.orElse为如果为空值则取555，b若为空则抛出异常。</p>\n<h2 id=\"（七）Nashorn-JavaScript\"><a href=\"#（七）Nashorn-JavaScript\" class=\"headerlink\" title=\"（七）Nashorn JavaScript\"></a>（七）Nashorn JavaScript</h2><p>Nashorn 一个 javascript 引擎。</p>\n<p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p>\n<p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>\n<p>实现了java和JavaScript互相调用。</p>\n<pre><code>ScriptEngineManager  scriptEngineManager = new  ScriptEngineManager(); \nScriptEngine  nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); \nString  name = &quot;Runoob&quot;; Integer  result = null; \ntry  {  \nnashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);\n result = (Integer)  \n nashorn.eval(&quot;10 + 2&quot;); \n }catch(ScriptException  e){\n   System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage()); \n   }  \n   System.out.println(result.toString());\n</code></pre><p>输出Runoob  12</p>\n<pre><code>var  BigDecimal  =  Java.type(&apos;java.math.BigDecimal&apos;); \nfunction calculate(amount, percentage)  { \nvar result =  new  BigDecimal(amount).multiply(  new  BigDecimal(percentage)).divide(new  BigDecimal(&quot;100&quot;),  2,  BigDecimal.ROUND_HALF_EVEN);\nreturn result.toPlainString();  }  \nvar result = calculate(568000000000000000023,13.9);  \nprint(result);\n</code></pre><p>命令行运行上诉程序 : jjs xxx.js<br>结果：78952000000000002017.94</p>\n<h2 id=\"（八）日期时间API\"><a href=\"#（八）日期时间API\" class=\"headerlink\" title=\"（八）日期时间API\"></a>（八）日期时间API</h2><p>旧版java中，日期时间相关的类存在诸多问题：<strong>非线程安全</strong>、<strong>设计差</strong>（java.util和java.sql中日期类名相同，但对应内容不一致，前者多了具体时间）、<strong>时区处理麻烦</strong>。</p>\n<p>java8在java.time包里引入了很多新的API：local、 zoned….</p>\n<pre><code>    // 获取当前的日期时间\nLocalDateTime currentTime = LocalDateTime.now();\nSystem.out.println(&quot;LocalDateTime.now: &quot; + currentTime);\n\nLocalDate date1 = currentTime.toLocalDate();\nSystem.out.println(&quot;localdatetime.tolocaldate=localdate: &quot; + date1);\n\nMonth month = currentTime.getMonth();\nint day = currentTime.getDayOfMonth();\nint seconds = currentTime.getSecond();\n\nSystem.out.println(&quot;localdatetime.getmonth=month: &quot; + month +&quot;, localdatetime.getdayofmonth=int: &quot; + day +&quot;, localdatetime.getseconds=int: &quot; + seconds);\n\n//用当前时间，修改天数和年份\nLocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);\nSystem.out.println(&quot;date2: &quot; + date2);\n\n//设置一个日期对象的值\nLocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);\nSystem.out.println(&quot;date3: &quot; + date3);\n\n//设置时间的值\nLocalTime date4 = LocalTime.of(22, 15);\nSystem.out.println(&quot;date4: &quot; + date4);\n\n//用另一种格式设置时间\nLocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);\nSystem.out.println(&quot;date5: &quot; + date5);\n</code></pre><p>输出：LocalDateTime.now: 2018-10-13T20:14:29.390<br>localdatetime.tolocaldate=localdate: 2018-10-13<br>localdatetime.getmonth=month: OCTOBER, localdatetime.getdayofmonth=int: 13, localdatetime.getseconds=int: 29<br>date2: 2012-10-10T20:14:29.390<br>date3: 2014-12-12<br>date4: 22:15<br>date5: 20:15:30</p>\n<p><strong>时区相关:</strong></p>\n<pre><code>    ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);\nSystem.out.println(&quot;date1: &quot; + date1);\n\nZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);\nSystem.out.println(&quot;ZoneId: &quot; + id);\n\nZoneId currentZone = ZoneId.systemDefault();\nSystem.out.println(&quot;当期时区: &quot; + currentZone);\n\nZonedDateTime dateTime=ZonedDateTime.now(currentZone);\nSystem.out.println(&quot;当前时区时间:&quot;+dateTime);\n</code></pre><p>输出：<br>date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]<br>ZoneId: Europe/Paris<br>当期时区: Asia/Shanghai<br>当前时区时间:2018-10-13T20:20:45.466+08:00[Asia/Shanghai]</p>\n<hr>\n<p>时间相关的计算:计算上个月的今天是周几?</p>\n<pre><code>LocalDateTime currentTime = LocalDateTime.now();\ncurrentTime=currentTime.withMonth(currentTime.getMonthValue()-1);\nSystem.out.println(currentTime.getDayOfWeek());\n</code></pre><p>结果:THURSDAY</p>\n<h2 id=\"（九）Base64\"><a href=\"#（九）Base64\" class=\"headerlink\" title=\"（九）Base64\"></a>（九）Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器。</p>\n<pre><code>   try {\n\n   // 使用基本编码\n   String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));\n   System.out.println(&quot;Base64 比那么字符串 (基本) :&quot; + base64encodedString);\n\n   // 解码\n   byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);\n\n   System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));\n   base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));\n   System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);\n\n   StringBuilder stringBuilder = new StringBuilder();\n\n   for (int i = 0; i &lt; 10; ++i) {\n      stringBuilder.append(UUID.randomUUID().toString());\n   }\n\n   byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);\n   String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);\n   System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);\n   byte[] aString=Base64.getMimeDecoder().decode(mimeEncodedString);\n   String aString2=new String(aString,&quot;utf-8&quot;);\n   System.out.println(aString2);\n\n}catch(UnsupportedEncodingException e){\n   System.out.println(&quot;Error :&quot; + e.getMessage());\n}\n</code></pre><p>结果:<br>Base64 比那么字符串 (基本) :cnVub29iP2phdmE4<br>原始字符串: runoob?java8<br>Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=<br>Base64 编码字符串 (MIME) :ZDEzM2E2MGEtNTllMS00ZGI5LWE5OWItNDFkNWMwZWU4ZWRlNzVkMmM5NTctMjFmNi00NTM3LWE2<br>NjQtMTUwNmJkOGU0ZWZjNDk0YjEyMTctM2RhZi00NDQ0LTgzNGItYzE0ZWFiY2ZhZWUxYzUxYjNj<br>N2MtMjQ0My00Y2UwLTlhZWItNjE0M2EzZDUzNmQ5OGNjMTgxZTgtMjg3MS00ZDY0LTg0MDktZTgw<br>MGE2OTNlZDdiM2QyOTBiNmQtYTUyYi00NzY3LWFjZmYtMWM0ODRiOGNmNGQzZjhkZjQ0MDItOWMw<br>Ni00YjMzLWEyZGUtZDcxYzc4N2NiZjBkMzQ2ZTY1OWQtMjU1OS00ZDVjLWE3ZjktMDQyMWNmYmY4<br>MjVlMmNhMDhkZGItMDU5OC00Yjk1LTg2ZjktNTdmYWRjZDBjMDBiOWYyYmMzYWMtZDAwNi00ZThk<br>LTlhNjQtNTU3OTcxODk1NjZi<br>d133a60a-59e1-4db9-a99b-41d5c0ee8ede75d2c957-21f6-4537-a664-1506bd8e4efc494b1217-3daf-4444-834b-c14eabcfaee1c51b3c7c-2443-4ce0-9aeb-6143a3d536d98cc181e8-2871-4d64-8409-e800a693ed7b3d290b6d-a52b-4767-acff-1c484b8cf4d3f8df4402-9c06-4b33-a2de-d71c787cbf0d346e659d-2559-4d5c-a7f9-0421cfbf825e2ca08ddb-0598-4b95-86f9-57fadcd0c00b9f2bc3ac-d006-4e8d-9a64-55797189566b</p>\n<hr>\n<h2 id=\"……\"><a href=\"#……\" class=\"headerlink\" title=\"……\"></a>……</h2><p>Over~</p>\n","categories":["java"],"tags":["java8"]},{"title":"【leetcode】笔记2","url":"/2018/11/08/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B02/","content":"<h2 id=\"11-Container-With-Most-Water\"><a href=\"#11-Container-With-Most-Water\" class=\"headerlink\" title=\"11. Container With Most Water\"></a>11. Container With Most Water</h2><p>Given  _n_  non-negative integers  _a1_,  _a2_, …,  _an_ , where each represents a point at coordinate (_i_,  _ai_).  _n_  vertical lines are drawn such that the two endpoints of line  _i_  is at (_i_,  _ai_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p><strong>Note:</strong> You may not slant the container and  _n_  is at least 2.</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fx0riuv5qxj30m90anq3j.jpg\" alt=\"\"></p>\n<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>\n<p><strong>Example:</strong></p>\n<p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>class Solution {\n    public int maxArea(int[] height) {\n        if(height.length&lt;2)return 0;\n        int head=0,tail=height.length-1;\n        int max = 0;\n        while (head!=tail) {\n            if (height[head]&gt;height[tail]) {\n                if((tail-head)*height[tail]&gt;max) {\n                    max=(tail-head)*height[tail];\n                }\n                tail--;\n            }else {\n                if((tail-head)*height[head]&gt;max) {\n                    max=(tail-head)*height[head];\n                }\n                head++;\n            }\n        }\n        return max;\n    }\n}\n</code></pre><p>定义两个下标变量从两端往中间遍历，比较俩下标对应的高度，若想中间的面积更大，则只改变高度较低的那一端的下标值向中间靠拢，最后通过一个变量记录最大值即可。</p>\n<hr>\n<h2 id=\"15-3Sum\"><a href=\"#15-3Sum\" class=\"headerlink\" title=\"15. 3Sum\"></a>15. 3Sum</h2><p>Given an array  <code>nums</code>  of  _n_  integers, are there elements  _a_,  _b_,  _c_  in  <code>nums</code>  such that  _a_  +  _b_  +  _c_  = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n<p><strong>Note:</strong></p>\n<p>The solution set must not contain duplicate triplets.</p>\n<p><strong>Example:</strong></p>\n<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>\n<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n        if(nums.length&lt;3) return Arrays.asList();\n        List&lt;List&lt;Integer&gt;&gt; aList=new ArrayList&lt;&gt;();\n        Arrays.sort(nums);\n        for(int i=0;i+2&lt;nums.length;i++) {\n            if (i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;\n            if (nums[i]&gt;0) break;\n            int target=-nums[i];\n            int j=i+1,k=nums.length-1;\n            while(k&gt;j) {\n                if(target==nums[j]+nums[k]) {\n                    aList.add(Arrays.asList(nums[i],nums[j],nums[k]));\n                    j++;\n                    k--;\n                    while(j&lt;k&amp;&amp;nums[j]==nums[j-1])j++;\n                    while(j&lt;k&amp;&amp;nums[k]==nums[k+1])k--;\n                }else if(target&lt;nums[j]+nums[k]){\n                    k--;\n                }else {\n                    j++;\n                }\n            }\n        }\n        return aList;\n    }\n}\n</code></pre><p>大概思想就是让每个数负数作为和，定义两个指针从这个数的右边和数组末向中间遍历，若有符合条件的加入list，跳过重复项</p>\n<hr>\n<h2 id=\"17-Letter-Combinations-of-a-Phone-Number\"><a href=\"#17-Letter-Combinations-of-a-Phone-Number\" class=\"headerlink\" title=\"17. Letter Combinations of a Phone Number\"></a>17. Letter Combinations of a Phone Number</h2><p>Given a string containing digits from  <code>2-9</code>  inclusive, return all possible letter combinations that the number could represent.</p>\n<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<p><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png\" alt=\"\"></p>\n<p><strong>Example:</strong></p>\n<p><strong>Input:</strong> “23”<br><strong>Output:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>\n<p><strong>Note:</strong></p>\n<p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>\n<h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>class Solution {\n     HashMap&lt;Character, List&lt;Character&gt;&gt; map=new HashMap&lt;&gt;();\n     StringBuilder stringBuilder=new StringBuilder();\n     List&lt;String&gt; aList=new ArrayList&lt;&gt;();\n\n    public  List&lt;String&gt; letterCombinations(String digits) {\n\n        if(digits.length()==0||digits==null) return Arrays.asList();       \n        map.put(&apos;2&apos;, Arrays.asList(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));\n        map.put(&apos;3&apos;, Arrays.asList(&apos;d&apos;,&apos;e&apos;,&apos;f&apos;));\n        map.put(&apos;4&apos;, Arrays.asList(&apos;g&apos;,&apos;h&apos;,&apos;i&apos;));\n        map.put(&apos;5&apos;, Arrays.asList(&apos;j&apos;,&apos;k&apos;,&apos;l&apos;));\n        map.put(&apos;6&apos;, Arrays.asList(&apos;m&apos;,&apos;n&apos;,&apos;o&apos;));\n        map.put(&apos;7&apos;, Arrays.asList(&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;));\n        map.put(&apos;8&apos;, Arrays.asList(&apos;t&apos;,&apos;u&apos;,&apos;v&apos;));\n        map.put(&apos;9&apos;, Arrays.asList(&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;));\n        doAdd(digits,0);\n\n        return aList;\n    }\n\n\n\n    private void doAdd(String digits, int i) {\n        if (i&lt;digits.length()) {\n            for (Character character : map.get(digits.charAt(i))) {\n                stringBuilder.append(character);\n                doAdd(digits, i+1);\n                stringBuilder.deleteCharAt(i);\n            }\n        }else {\n            aList.add(stringBuilder.toString());\n            return;\n        }\n    }\n}\n</code></pre><hr>\n<h2 id=\"21-Merge-Two-Sorted-Lists\"><a href=\"#21-Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"21. Merge Two Sorted Lists\"></a>21. Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>\n<p><strong>Example:</strong></p>\n<p><strong>Input:</strong> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l1==null) return l2;\n        if(l2==null) return l1;\n        ListNode node;\n        if(l1.val&gt;l2.val) {\n            node=l2;\n            l2=l2.next;\n        }else {\n            node=l1;\n            l1=l1.next;\n        }\n        ListNode head=new ListNode(0);\n        head.next=node;\n\n        while(l1!=null||l2!=null) {\n            if(l1==null) {\n                node.next=l2;\n                break;\n            }else if(l2==null) {\n                node.next=l1;\n                break;\n            }\n            if (l1.val&gt;l2.val) {\n                node.next=l2;\n                l2=l2.next;\n            }else {\n                node.next=l1;\n                l1=l1.next;\n            }\n            node=node.next;\n        }\n        return head.next;\n    }\n}\n</code></pre><h2 id=\"22-Generate-Parentheses\"><a href=\"#22-Generate-Parentheses\" class=\"headerlink\" title=\"22. Generate Parentheses\"></a>22. Generate Parentheses</h2><p>Given  _n_  pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>\n<p>For example, given  _n_  = 3, a solution set is:</p>\n<pre><code>[\n  &quot;((()))&quot;,\n  &quot;(()())&quot;,\n  &quot;(())()&quot;,\n  &quot;()(())&quot;,\n  &quot;()()()&quot;\n]\n</code></pre><h2 id=\"Solution-4\"><a href=\"#Solution-4\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>class Solution {\n    public List&lt;String&gt; generateParenthesis(int n) {\n        List&lt;String&gt; aList=new ArrayList&lt;&gt;();\n        StringBuilder sBuilder=new StringBuilder();\n        doListCur(0,0,sBuilder,n,aList);\n        return aList;\n    }\n\n\n    private void doListCur(int left, int right, StringBuilder sBuilder,int n,List&lt;String&gt; aList) {\n        if(n==right) {\n            aList.add(sBuilder.toString());\n            return;\n        }\n\n        if (left&lt;n) {\n            sBuilder.append(&apos;(&apos;);\n            doListCur(left+1, right, sBuilder, n, aList);\n            sBuilder.deleteCharAt(sBuilder.length()-1);\n        }\n        if (right&lt;left) {\n            sBuilder.append(&apos;)&apos;);\n            doListCur(left, right+1, sBuilder, n, aList);\n            sBuilder.deleteCharAt(sBuilder.length()-1);\n        }\n\n    }\n}\n</code></pre><p>类似上题</p>\n<hr>\n<h2 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"23. Merge k Sorted Lists\"></a>23. Merge k Sorted Lists</h2><p>Merge  _k_  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>\n<p><strong>Example:</strong></p>\n<p><strong>Input:</strong></p>\n<pre><code>[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n</code></pre><p><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>\n<h2 id=\"Solution-5\"><a href=\"#Solution-5\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>class Solution {\n    public ListNode mergeKLists(ListNode[] lists) { \n        Comparator&lt;ListNode&gt; cmp;\n        cmp = new Comparator&lt;ListNode&gt;() {  \n        @Override\n        public int compare(ListNode o1, ListNode o2) {\n            // TODO Auto-generated method stub\n            return o1.val-o2.val;\n        }\n        };\n\n        Queue&lt;ListNode&gt; q = new PriorityQueue&lt;ListNode&gt;(cmp);\n        for(ListNode l : lists){\n            if(l!=null){\n                q.add(l);\n            }        \n        }\n        ListNode head = new ListNode(0);\n        ListNode point = head;\n        while(!q.isEmpty()){ \n            point.next = q.poll();\n            point = point.next; \n            ListNode next = point.next;\n            if(next!=null){\n                q.add(next);\n            }\n        }\n        return head.next;\n    }\n}\n</code></pre><p>另外还可以利用第21题的两两链表合并，速度更快</p>\n<hr>\n<h2 id=\"31-Next-Permutation\"><a href=\"#31-Next-Permutation\" class=\"headerlink\" title=\"31. Next Permutation\"></a>31. Next Permutation</h2><p>Implement  <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>\n<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>\n<p>The replacement must be  <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\" rel=\"noopener\">in-place</a></strong>  and use only constant extra memory.</p>\n<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>\n<p><code>1,2,3</code>  →  <code>1,3,2</code><br><code>3,2,1</code>  →  <code>1,2,3</code><br><code>1,1,5</code>  →  <code>1,5,1</code></p>\n<pre><code>class Solution {\n    public void nextPermutation(int[] nums) {\n        if(nums.length&lt;2) return;\n        int n=nums.length-1;\n        List&lt;Integer&gt; aList=new ArrayList&lt;&gt;();\n        aList.add(nums[n]);\n        while(n&gt;0) {\n            int j=n-1;\n            for(int i=0;i&lt;aList.size();i++) {\n                if (aList.get(i)&gt;nums[j]) {\n                    int anum=nums[nums.length-1-i];\n                    nums[nums.length-1-i]=nums[j];\n                    nums[j]=anum;\n                    Arrays.sort(nums, j+1, nums.length);\n                    return;\n                }\n            }\n            aList.add(nums[j]);\n            n--;\n        }\n        Arrays.sort(nums);\n    }\n}\n</code></pre><p>用list里的数去和它前面一位的数比较，如果遇到某一个数大于这个数，就互换这两个数的位置，并把前面数后面的位置重新排序。否则就把这个数加入到list里，再次循环。如果一直到循环结束未发现任何后面的数大于前面的数，就把数组从小到大重新排序。</p>\n<hr>\n","categories":["数据结构"],"tags":["LeetCode","算法"]},{"title":"【LeetCode】笔记1","url":"/2018/11/06/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B01/","content":"<h2 id=\"1-Two-Sum\"><a href=\"#1-Two-Sum\" class=\"headerlink\" title=\"1. Two Sum\"></a>1. Two Sum</h2><p><strong>Given an array of integers, return  </strong>indices<strong>  of the two numbers such that they add up to a specific target.<br>You may assume that each input would have  </strong><em>exactly</em><strong>  one solution, and you may not use the  <em>same</em>  element twice.</strong></p>\n<p><strong>Example:</strong></p>\n<pre><code>Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[**0**] + nums[**1**] = 2 + 7 = 9,\nreturn [**0**, **1**].\n</code></pre><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class=\"line\">    int[] result = new int[2];</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">    for (int i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class=\"line\">        if (map.containsKey(target - numbers[i])) &#123;</span><br><span class=\"line\">            result[1] = i;</span><br><span class=\"line\">            result[0] = map.get(target - numbers[i]);</span><br><span class=\"line\">            return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.put(numbers[i], i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用Hashmap结构，将值存在key，数组索引序号存在value里，使用containsKey方法简易地寻找和为target的对应项，若存在则返回对应下标，不存在就加入到map中。</p>\n<hr>\n<h2 id=\"3-Longest-Substring-Without-Repeating-Characters\"><a href=\"#3-Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"3. Longest Substring Without Repeating Characters\"></a>3. Longest Substring Without Repeating Characters</h2><p>Given a string, find the length of the  <strong>longest substring</strong>  without repeating characters.</p>\n<p><strong>Example 1:</strong></p>\n<p><strong>Input:</strong> “abcabcbb”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is <code>&quot;abc&quot;</code>, with the length of 3. </p>\n<p><strong>Example 2:</strong></p>\n<p><strong>Input:</strong> “bbbbb”<br><strong>Output:</strong> 1 <strong>Explanation:</strong> The answer is <code>&quot;b&quot;</code>, with the length of 1.</p>\n<p><strong>Example 3:</strong></p>\n<p><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3 <strong>Explanation:</strong> The answer is <code>&quot;wke&quot;</code>, with the length of 3.<br>             Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.<br>即寻找最长连续子串</p>\n<h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>public int lengthOfLongestSubstring(String s) {\n    int n=s.length();\n    HashSet&lt;Character&gt; sett=new HashSet&lt;&gt;();\n    int maxlen=0,j=0,k=0;\n    while (j&lt;n&amp;&amp;k&lt;n) {\n        if(sett.contains(s.charAt(j))) {\n            sett.remove(s.charAt(k));\n            k++;\n        }else {\n            sett.add(s.charAt(j));\n            j++;\n            maxlen=Math.max(maxlen, j-k);\n        }\n    }\n    return maxlen;\n}\n</code></pre><p>利用HashSet结构，从字符串开始处索引，当没有重复字符时，定义的一个指针j递增，并计算最长的子串长度，当遇到重复字符时，另一指针k递增，并逐个移除Set集合里的值，直到将重复的字符移出。</p>\n<hr>\n<h2 id=\"4-Median-of-Two-Sorted-Arrays\"><a href=\"#4-Median-of-Two-Sorted-Arrays\" class=\"headerlink\" title=\"4. Median of Two Sorted Arrays\"></a>4. Median of Two Sorted Arrays</h2><p>There are two sorted arrays  <strong>nums1</strong>  and  <strong>nums2</strong>  of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n<p>You may assume  <strong>nums1</strong>  and  <strong>nums2</strong> cannot be both empty.</p>\n<p><strong>Example 1:</strong></p>\n<p>nums1 = [1, 3]<br>nums2 = [2]</p>\n<p>The median is 2.0</p>\n<p><strong>Example 2:</strong></p>\n<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>\n<p>The median is (2 + 3)/2 = 2.5</p>\n<h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>A</p>\n<pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    int m=nums1.length,n=nums2.length;\n    int slen=m+n;\n    int num[]=new int[slen];\n    int j=0,k=0,i=0;\n    while(j&lt;m&amp;&amp;k&lt;n){\n        num[i]=(nums1[j]&gt;nums2[k]?nums2[k++]:nums1[j++]);\n        i++;\n    }\n    while(j&lt;m){\n        num[i++]=nums1[j++];\n    }\n    while(k&lt;n){\n        num[i++]=nums2[k++];\n    }\n    if(slen%2==1){\n        return num[slen/2];\n    }else{\n        return (double)(num[slen/2]+num[slen/2-1])/2;\n    }\n}\n</code></pre><p>这个算法很容易理解，就是把两个数组重新排序到一个大数组里，再算中位数就很容易。</p>\n<p>B</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class=\"line\">    int m = nums1.length;</span><br><span class=\"line\">    int n = nums2.length;</span><br><span class=\"line\">    int len = m + n;</span><br><span class=\"line\">    if(len % 2 == 0)&#123;</span><br><span class=\"line\">        double left =  (double)findKthHelper(nums1, 0, nums2, 0, len/2);</span><br><span class=\"line\">        double right =  (double)findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class=\"line\">        return (double)(left + right)/2;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private int findKthHelper(int[] A, int aStart, int[] B, int bStart, int k)&#123;</span><br><span class=\"line\">    if(aStart &gt;= A.length)&#123;</span><br><span class=\"line\">        return B[bStart + k - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(bStart &gt;= B.length)&#123;</span><br><span class=\"line\">        return A[aStart + k - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(k == 1)&#123;</span><br><span class=\"line\">        return Math.min(A[aStart], B[bStart]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int aMid = aStart + k/2 - 1;</span><br><span class=\"line\">    int bMid = bStart + k/2 - 1;</span><br><span class=\"line\">    int aVal = aMid &gt;= A.length ? Integer.MAX_VALUE : A[aMid];</span><br><span class=\"line\">    int bVal = bMid &gt;= B.length ? Integer.MAX_VALUE : B[bMid];</span><br><span class=\"line\">    if(aVal &lt;= bVal)&#123;</span><br><span class=\"line\">        return findKthHelper(A, aMid + 1, B, bStart, k - k/2);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return findKthHelper(A, aStart, B, bMid + 1, k - k/2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基于二分法，比较AMid和BMid保留应该保留的部分递归，直至K==1.</p>\n<hr>\n<h2 id=\"5-Longest-Palindromic-Substring\"><a href=\"#5-Longest-Palindromic-Substring\" class=\"headerlink\" title=\"5. Longest Palindromic Substring\"></a>5. Longest Palindromic Substring</h2><p>Given a string  <strong>s</strong>, find the longest palindromic substring in  <strong>s</strong>. You may assume that the maximum length of  <strong>s</strong>  is 1000.</p>\n<p><strong>Example 1:</strong></p>\n<p><strong>Input:</strong> “babad”<br><strong>Output:</strong> “bab”<br><strong>Note:</strong> “aba” is also a valid answer.</p>\n<p><strong>Example 2:</strong></p>\n<p><strong>Input:</strong> “cbbd”<br><strong>Output:</strong> “bb”</p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><pre><code>public String longestPalindrome(String s) {\n    if(s.length()&lt;1) return s;\n    StringBuilder str=new StringBuilder(s);\n    StringBuilder rs=new StringBuilder(s);\n    rs.reverse();\n    int len=s.length();\n    String outstr=&quot;&quot;;\n    for(int i=0;i&lt;=len-1;i++) {\n        for(int n=2;n&lt;=len-i;n++) {\n            if(str.substring(i, n+i).equals(rs.substring(len-n-i, len-i))) {\n                if(str.substring(i, n+i).length()&gt;outstr.length()) {\n                    outstr=str.substring(i, n+i);\n                } \n            }\n        }\n    }\n    if(outstr.equals(&quot;&quot;)) {\n        outstr=str.substring(0, 1);\n    }\n    return outstr;\n}\n</code></pre><p>将原字符串反转，通过比较对应位置的子字符串</p>\n<p>Better Solution</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">private int lo, maxLen;</span><br><span class=\"line\"></span><br><span class=\"line\">public String longestPalindrome(String s) &#123;</span><br><span class=\"line\">\tint len = s.length();</span><br><span class=\"line\">\tif (len &lt; 2)</span><br><span class=\"line\">\t\treturn s;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    for (int i = 0; i &lt; len-1; i++) &#123;</span><br><span class=\"line\">     \textendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible</span><br><span class=\"line\">     \textendPalindrome(s, i, i+1); //assume even length.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return s.substring(lo, lo + maxLen);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void extendPalindrome(String s, int j, int k) &#123;</span><br><span class=\"line\">\twhile (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span><br><span class=\"line\">\t\tj--;</span><br><span class=\"line\">\t\tk++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (maxLen &lt; k - j - 1) &#123;</span><br><span class=\"line\">\t\tlo = j + 1;</span><br><span class=\"line\">\t\tmaxLen = k - j - 1;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>extendPalindrome方法选定一个中心，以两个指针j和k分别向俩个方向延伸，遍历完字符串即可。</p>\n<hr>\n<h2 id=\"10-Regular-Expression-Matching\"><a href=\"#10-Regular-Expression-Matching\" class=\"headerlink\" title=\"10. Regular Expression Matching\"></a>10. Regular Expression Matching</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for  <code>&#39;.&#39;</code>  and  <code>&#39;*&#39;</code>.</p>\n<p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p>\n<p>The matching should cover the  <strong>entire</strong>  input string (not partial).</p>\n<p><strong>Note:</strong></p>\n<ul>\n<li><code>s</code> could be empty and contains only lowercase letters  <code>a-z</code>.</li>\n<li><code>p</code>  could be empty and contains only lowercase letters  <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<p><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.</p>\n<p><strong>Example 2:</strong></p>\n<p><strong>Input:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>\n<p><strong>Example 3:</strong></p>\n<p><strong>Input:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “.</em>“ means “zero or more (*) of any character (.)”.</p>\n<p><strong>Example 4:</strong></p>\n<p><strong>Input:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p>\n<p><strong>Example 5:</strong></p>\n<p><strong>Input:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>Output:</strong> false</p>\n<h2 id=\"Solution-4\"><a href=\"#Solution-4\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>正则表达式</p>\n<pre><code>public boolean isMatch(String s, String p) {\n    java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(p);\n    java.util.regex.Matcher matcher=pattern.matcher(s);\n    if(matcher.matches()) {\n        return true;\n    }else {\n        return false;\n    }\n}\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public boolean isMatch(String s, String p) &#123;</span><br><span class=\"line\">    if (s == null || p == null) &#123;</span><br><span class=\"line\">        return s == p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    char[] sArray = s.toCharArray();</span><br><span class=\"line\">    char[] pArray = p.toCharArray();</span><br><span class=\"line\">    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class=\"line\">    dp[0][0] = true;</span><br><span class=\"line\">    for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class=\"line\">        if (p.charAt(j - 1) == &apos;*&apos;) &#123; // * is promised not to be the first char</span><br><span class=\"line\">            dp[0][j] = dp[0][j - 2];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 1; i &lt; dp.length; i++) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class=\"line\">            if (pArray[j - 1] == sArray[i - 1] || pArray[j - 1] == &apos;.&apos;) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class=\"line\">            &#125; else if (pArray[j - 1] == &apos;*&apos;) &#123;</span><br><span class=\"line\">                if (sArray[i - 1] == pArray[j - 2] || pArray[j - 2] == &apos;.&apos;) &#123;</span><br><span class=\"line\">                    dp[i][j] = (dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j]);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i][j - 2];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dp[dp.length - 1][dp[0].length - 1];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数据结构"],"tags":["LeetCode","算法"]},{"title":"【shiro】初识shiro身份与权限验证","url":"/2019/03/18/%E3%80%90shiro%E3%80%91%E5%88%9D%E8%AF%86shiro%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/","content":"<h2 id=\"依赖导入\"><a href=\"#依赖导入\" class=\"headerlink\" title=\"依赖导入\"></a>依赖导入</h2><pre><code>&lt;dependencies&gt;  \n &lt;dependency&gt;\n     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  \n     &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;  \n     &lt;version&gt;1.3.2&lt;/version&gt;  \n &lt;/dependency&gt;  \n &lt;dependency&gt;\n      &lt;groupId&gt;commons-logging&lt;/groupId&gt;  \n     &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;  \n     &lt;version&gt;1.2&lt;/version&gt;  \n &lt;/dependency&gt;  \n &lt;dependency&gt; \n     &lt;groupId&gt;junit&lt;/groupId&gt;  \n     &lt;artifactId&gt;junit&lt;/artifactId&gt;  \n     &lt;version&gt;4.12&lt;/version&gt;  \n &lt;/dependency&gt; \n &lt;dependency&gt; \n     &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;  \n     &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;  \n     &lt;version&gt;1.3&lt;/version&gt;  \n &lt;/dependency&gt; \n &lt;dependency&gt; \n     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  \n     &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  \n     &lt;version&gt;1.7.25&lt;/version&gt;  \n &lt;/dependency&gt;\n &lt;/dependencies&gt;\n</code></pre><h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>log4j.properties</p>\n<pre><code># Configure logging for testing: optionally with log file  \nlog4j.rootLogger=WARN, stdout  \n# log4j.rootLogger=WARN, stdout, logfile  \n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender  \nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n  \n\nlog4j.appender.logfile=org.apache.log4j.FileAppender  \nlog4j.appender.logfile.File=target/spring.log  \nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre><p>myshiro.ini （后期可以通过其他方式配置）</p>\n<pre><code>[main]  \nmyRealm=MyDefaultRealm  \nsecurityManager.realms=$myRealm\n</code></pre><p>MyDefaultRealm是自定义的Realm对象包全路径</p>\n<hr>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>通过shiro登陆验证的流程，如下图<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g1782tpgahj30df08qgn5.jpg\" alt=\"\"></p>\n<p>我们先通过<strong>Subject</strong>，这是一个门面对象去“迎接”登陆的用户的信息，<br>然后把这些信息交给Shiro的核心<strong>SecurityManager</strong>的核心管理</p>\n<p><strong>Realm</strong>数据源,用于保存从数据库获取的数据对象</p>\n<hr>\n<h2 id=\"自定义Realm\"><a href=\"#自定义Realm\" class=\"headerlink\" title=\"自定义Realm\"></a>自定义Realm</h2><pre><code>import org.apache.shiro.authc.*;  \nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;  \nimport org.apache.shiro.authz.AuthorizationInfo;  \nimport org.apache.shiro.authz.SimpleAuthorizationInfo;  \nimport org.apache.shiro.realm.AuthorizingRealm;  \nimport org.apache.shiro.subject.PrincipalCollection;  \nimport org.apache.shiro.util.ByteSource;  \n\nimport java.util.Arrays;  \n\n/**  \n * @ClassName MyDefaultRealm  \n * @Description TODO  \n  * @Author xufeng  \n * @Data 2019/3/18 16:58  \n * @Version 1.0  \n **/public class MyDefaultRealm extends AuthorizingRealm {  \n\n    public MyDefaultRealm(){  \n        HashedCredentialsMatcher passwordMatcher = new HashedCredentialsMatcher(&quot;md5&quot;);  \n\n  passwordMatcher.setHashIterations(3);  \n this.setCredentialsMatcher(passwordMatcher);  \n  }  \n\n    //授权  \n  @Override  \n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {  \n        String myName = (String) principals.getPrimaryPrincipal();  \n  SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();  \n  info.addRole(&quot;admin&quot;);  \n  info.addStringPermissions(Arrays.asList(&quot;add&quot;,&quot;delete&quot;));  \n\n return info;  \n  }  \n\n    //验证  \n  @Override  \n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {  \n        String userName  = (String) token.getPrincipal();  \n\n  String tSalt = &quot;盐值123&quot;;  \n\n if (&quot;xff&quot;.equals(userName)){  \n            throw new UnknownAccountException();  \n  }  \n\n        return new SimpleAuthenticationInfo(userName, getPasswordFromDB(userName), generateSalt(tSalt), getName());  \n  }  \n\n    private String getPasswordFromDB(String userName) {  \n        //do SomeThing  \n  return &quot;4d7461d62743c1e852f96ac24a6d1767&quot;;  \n  }  \n\n    private ByteSource generateSalt(String salt) {  \n        return ByteSource.Util.bytes(salt);  \n  }  \n\n}\n</code></pre><p>doGetAuthorizationInfo是授权，在这个方法里查询数据库，获取用户权限并放入权限对象返回</p>\n<p>doGetAuthenticationInfo是验证，在该方法里通过用户名从数据库查询密码，然后与token中的用户密码校验，成功会返回登陆信息，失败会抛出异常</p>\n<p>可以在该类的构造器中声明密码的加密方法，以什么方式加密、盐值，以及，循环多少次</p>\n<hr>\n<h2 id=\"编写测试类\"><a href=\"#编写测试类\" class=\"headerlink\" title=\"编写测试类\"></a>编写测试类</h2><pre><code>import org.apache.shiro.SecurityUtils;  \nimport org.apache.shiro.authc.AuthenticationException;  \nimport org.apache.shiro.authc.UsernamePasswordToken;  \nimport org.apache.shiro.config.IniSecurityManagerFactory;  \nimport org.apache.shiro.crypto.hash.Md5Hash;  \nimport org.apache.shiro.subject.Subject;  \nimport org.apache.shiro.util.Factory;  \nimport org.junit.Assert;  \nimport org.junit.Test;  \nimport org.apache.shiro.mgt.SecurityManager;  \n\n/**  \n * @ClassName MyTest  \n * @Description TODO  \n  * @Author xufeng  \n * @Data 2019/3/18 16:31  \n * @Version 1.0  \n **/public class MyTest {  \n\n    @Test  \n  public void test() {  \n\n      Factory&lt;SecurityManager&gt; factory  = new IniSecurityManagerFactory(&quot;classpath:myshiro.ini&quot;);  \n      SecurityManager sm = factory.getInstance();  \n      SecurityUtils.setSecurityManager(sm);  \n\n      Subject subject = SecurityUtils.getSubject();  \n      UsernamePasswordToken token = new UsernamePasswordToken(&quot;jay&quot;,&quot;123456&quot;);  \n\n     try{  \n                subject.login(token);  \n      }catch (AuthenticationException a){  \n                System.out.println(&quot;登陆失败&quot;);  \n      }  \n            //断言用户已经登陆  \n      Assert.assertEquals(true, subject.isAuthenticated());  \n\n      System.out.println(subject.hasRole(&quot;admin&quot;));  \n\n      subject.checkRole(&quot;admin&quot;);  \n\n      System.out.println(subject.isPermitted(&quot;add&quot;));  \n\n      System.out.println(subject.isPermittedAll(&quot;add&quot;,&quot;delete&quot;));  \n\n      System.out.println(subject.isPermitted(&quot;update&quot;));  \n\n      System.out.println(subject.getPrincipal().toString());  \n\n      subject.logout();  \n\n      System.out.println(subject.getPrincipal().toString());  \n  }  \n\n    @Test  \n  public void tt(){  \n      Md5Hash md5Hash = new Md5Hash(&quot;123456&quot;,&quot;盐值123&quot;,3);  \n      System.out.println(md5Hash);  \n  }  \n}\n</code></pre><p>方法内前面三行是引入shiro配置，创建subject门面对象，通过login方法验证token</p>\n<p>在subject.login(token)这行打个断点，可以看到token里的值如下：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g178vs0ld1j30br06kq34.jpg\" alt=\"\"></p>\n<p>下面是对用户权限的验证，最后打印结果为：</p>\n<pre><code>true\ntrue\ntrue\nfalse\njay\n\njava.lang.NullPointerException\n    at MyTest.test(MyTest.java:52)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)\n    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)\n    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)\n    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)\n</code></pre><p>logout后subject对象会被销毁，抛出空指针异常。</p>\n","categories":["shiro"]},{"title":"【mybatis】大概总结(一)","url":"/2018/11/03/%E3%80%90mybatis%E3%80%91%E5%A4%A7%E6%A6%82%E6%80%BB%E7%BB%93(%E4%B8%80)/","content":"<p><a href=\"#c\">原生访问数据库方法</a><br><a href=\"#a\">总配置文件</a><br><a href=\"#mapper\">mapper配置</a><br><a href=\"#mapperj\">mapper接口</a><br><a href=\"#mapperc\">使用示例</a></p>\n<hr>\n<p><span id=\"c\"></span></p>\n<h2 id=\"原生访问数据库方法-jdbc\"><a href=\"#原生访问数据库方法-jdbc\" class=\"headerlink\" title=\"原生访问数据库方法:jdbc\"></a>原生访问数据库方法:jdbc</h2><p><strong>jdbc编程步骤:</strong></p>\n<ol>\n<li>加载数据库驱动</li>\n<li>创建并获取数据库链接</li>\n<li>创建jdbc statement对象</li>\n<li>设置sql语句</li>\n<li>设置sql语句中的参数(使用preparedStatement)</li>\n<li>通过statement执行sql并获取结果</li>\n<li>对sql执行结果进行解析处理</li>\n<li>释放资源(resultSet、preparedstatement、connection)</li>\n</ol>\n<p><strong>缺点</strong>：每次对数据库操作时就得建立连接，用完又得释放，非常不方便，且对数据库造成压力较大。不灵活， 程序耦合度高。</p>\n<hr>\n<h1 id=\"–Mybatis–\"><a href=\"#–Mybatis–\" class=\"headerlink\" title=\"–Mybatis–\"></a>–Mybatis–</h1><p>与hibernate类似，mybatis也让表和java类产生映射关系，通过配置映射文件实现。</p>\n<p>可创建相应实体类.xml，并在mybatis配置文件中加载（这里省略这种方法）。</p>\n<p><span id=\"a\"></span></p>\n<h2 id=\"首先配置mybatis总配置文件SqlMapConfig-xml\"><a href=\"#首先配置mybatis总配置文件SqlMapConfig-xml\" class=\"headerlink\" title=\"首先配置mybatis总配置文件SqlMapConfig.xml\"></a>首先配置mybatis总配置文件SqlMapConfig.xml</h2><p><strong>注意事项:</strong></p>\n<ul>\n<li><strong>标签有固定的配置顺序</strong>：<br>properties（属性）<br>settings（全局配置参数）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）</li>\n<li><strong>mybatis使用自带的数据库连接池，不支持第三方连接池（网上有添加方法）</strong></li>\n</ul>\n<p><strong>配置建议：</strong></p>\n<ul>\n<li><p><strong>别名配置typeAliases</strong>：使用批量配置，标签里加入</p>\n<pre><code>&lt;package name=&quot;com.me.domain&quot;/&gt;\n</code></pre><p>其中com.me.domain是你要自动配置的包里类的别名（用对应类名配置）</p>\n</li>\n</ul>\n<ul>\n<li><p><strong>mappers映射器配置</strong>：使用批量配置，标签里加入</p>\n<pre><code>&lt;package name=&quot;com.me.mapper&quot;/&gt;\n</code></pre><p>其中com.me.mapper对应配置的mapper的包名（同上）</p>\n</li>\n</ul>\n<hr>\n<p>示例（只配置了部分配置）:</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n\n    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;\n\n    &lt;typeAliases&gt;\n        &lt;package name=&quot;com.me.domain&quot;/&gt;\n    &lt;/typeAliases&gt;\n\n    &lt;environments default=&quot;development&quot;&gt;\n        &lt;environment id=&quot;development&quot;&gt;\n            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\n                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;\n                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;\n                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;\n                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;\n            &lt;/dataSource&gt;\n        &lt;/environment&gt;\n    &lt;/environments&gt;\n\n    &lt;mappers&gt;\n        &lt;package name=&quot;com.me.mapper&quot;/&gt;\n    &lt;/mappers&gt;\n\n&lt;/configuration&gt;\n</code></pre><hr>\n<p><span id=\"mapper\"></span></p>\n<h2 id=\"mapper映射器配置\"><a href=\"#mapper映射器配置\" class=\"headerlink\" title=\"mapper映射器配置\"></a>mapper映射器配置</h2><p><strong>输入映射：</strong><br>resultType指定输入参数类型：</p>\n<ul>\n<li>简单类型(直接使用)</li>\n<li>hashmap(直接使用)</li>\n<li>pojo的包装类型（<strong>常用</strong>）：<br>通过创建一个新的类，在这个类里创建想用来操作的输入参数，并生成set和get方法</li>\n</ul>\n<p><strong>输出映射：</strong></p>\n<ul>\n<li><strong>resultType</strong>：列名与属性名一致才能成功映射<ul>\n<li>输出简单类型</li>\n<li>输出pojo对象和列表</li>\n</ul>\n</li>\n<li><strong>resultMap</strong>：可以定义列的别名，通过别名来映射<ul>\n<li>输出配置的resultMap的id对应的对象</li>\n</ul>\n</li>\n</ul>\n<p>resultMap需要先在mapper里配置resultMap（使用时若要用其他mapper里的resultMap配置，需要在前面加上对应mapper的namespace）示例：</p>\n<pre><code>&lt;!-- 定义resultMap\n将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系\n\ntype：resultMap最终映射的java对象类型,可以使用别名\nid：对resultMap的唯一标识\n --&gt;\n &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;\n    &lt;!-- id表示查询结果集中唯一标识 \n    column：查询出来的列名\n    property：type指定的pojo类型中的属性名\n    最终resultMap对column和property作一个映射关系 （对应关系）\n    --&gt;\n    &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;\n    &lt;!-- \n    result：对普通名映射定义\n    column：查询出来的列名\n    property：type指定的pojo类型中的属性名\n    最终resultMap对column和property作一个映射关系 （对应关系）\n     --&gt;\n    &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;\n\n &lt;/resultMap&gt;\n</code></pre><p>使用示例:</p>\n<pre><code>&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;\n    SELECT id id_,username username_ FROM USER WHERE id=#{value}\n&lt;/select&gt;\n</code></pre><p>另外在接口中，返回类型写map对应实体类就OK</p>\n<hr>\n<p>Mapper配置示例:</p>\n<pre><code>&lt;!DOCTYPE mapper\n    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\n    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n\n&lt;mapper namespace=&quot;com.me.mapper.GoodsMapper&quot;&gt;\n\n&lt;resultMap type=&quot;goods&quot; id=&quot;goodsResultMap&quot;&gt;\n    &lt;id column=&quot;gname_haha&quot; property=&quot;gname&quot; /&gt;\n    &lt;result column=&quot;price_haha&quot; property=&quot;price&quot; /&gt;\n&lt;/resultMap&gt;\n\n&lt;insert id=&quot;insertGoods&quot; parameterType=&quot;goods&quot;&gt;\n    INSERT INTO GOODS(gname,price) VALUE(#{gname},#{price})\n&lt;/insert&gt;\n\n&lt;select id=&quot;selectall&quot; resultMap=&quot;goodsResultMap&quot;&gt;\n    SELECT gname gname_haha,price price_haha FROM goods\n&lt;/select&gt;\n</code></pre><p></p>\n<hr>\n<p><span id=\"mapperj\"></span></p>\n<h2 id=\"Mapper接口：\"><a href=\"#Mapper接口：\" class=\"headerlink\" title=\"Mapper接口：\"></a><strong>Mapper接口：</strong></h2><p>创建mapper.xml映射器对应的接口。<br>在mapper.xml中配置的方法，需要在mapper接口类里配置:<br>其中必须符合以下<strong>四</strong>个规范:</p>\n<ul>\n<li>mapper接口类和映射文件在同一包下</li>\n<li>mapper接口里方法名与映射文件配置id一致</li>\n<li>mapper接口方法参数和映射文件配置参数类型一致</li>\n<li>mapper接口方法返回类型和映射文件配置参数类型一致（可以用list&lt;类&gt;，会自动调用selectlist返回对应对象的list集合）</li>\n</ul>\n<p>示例:</p>\n<pre><code>package com.me.mapper;\n\nimport java.util.List;\n\nimport com.me.domain.User;\nimport com.me.domain.UserQuery;\n\npublic interface UserMapper {\n    public User findUserById(Integer userid) throws Exception;\n\n    public User selectUserQuery(UserQuery userQuery) throws Exception;\n\n    public void updateUser(User user) throws Exception;\n\n    public List&lt;User&gt; findUserByName(String string) throws Exception;\n\n    public List&lt;User&gt; selectUserList(UserQuery userQuery) throws Exception;\n}\n</code></pre><hr>\n<p><span id=\"mapperc\"></span></p>\n<h2 id=\"使用mapper操作数据：\"><a href=\"#使用mapper操作数据：\" class=\"headerlink\" title=\"使用mapper操作数据：\"></a>使用mapper操作数据：</h2><p>示例:</p>\n<pre><code>import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.me.domain.Goods;\nimport com.me.domain.User;\nimport com.me.domain.UserQuery;\nimport com.me.mapper.GoodsMapper;\nimport com.me.mapper.UserMapper;\n\npublic class Tmybati {\n\n    SqlSessionFactory sessionFactory;\n    //这个注解会让这个方法在test方法前执行\n    @Before\n    public void a() throws IOException {\n        String string=&quot;SqlMapConfig.xml&quot;;\n\n        InputStream inputStream=Resources.getResourceAsStream(string);\n\n        sessionFactory=new SqlSessionFactoryBuilder().build(inputStream);\n\n    }\n\n    //测试方法\n    @Test\n    public void tess() throws Exception {\n        SqlSession session=sessionFactory.openSession();\n        UserMapper userMapper=session.getMapper(UserMapper.class);\n/*        \n        User user2=new User();\n        user2.setUserid(1111);\n\n        Goods goods=new Goods();\n        goods.setGname(&quot;吴克&quot;);\n        goods.setPrice(1111);\n\n        UserQuery userQuery=new UserQuery();\n        userQuery.setUser(user2);\n        userQuery.setGoods(goods);\n\n        List&lt;User&gt; users=userMapper.selectUserList(userQuery);\n        users.stream().forEach(System.out::println);\n\n        User user=userMapper.findUserById(1111);\n        System.out.println(user);*/\n\n        Goods dGoods =new Goods();\n        dGoods.setGname(&quot;吴克5&quot;);\n        dGoods.setPrice(1111);\n        GoodsMapper goodsMapper=session.getMapper(GoodsMapper.class);\n        List&lt;Goods&gt; goods=goodsMapper.selectall();\n\n        goods.stream().filter(n-&gt;n.getPrice()==123).forEach(System.out::println);\n\n        session.commit();\n        session.close();\n\n    }\n}\n</code></pre><hr>\n","categories":["mybatis"],"tags":["mybatis"]},{"title":"【ssm】ssm整合配置","url":"/2018/10/19/%E3%80%90ssm%E3%80%91ssm%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/","content":"<ul>\n<li><strong>导入所有需要的包（添加maven依赖）:</strong></li>\n</ul>\n<pre><code>&lt;dependencies&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n         &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n         &lt;version&gt;3.4.5&lt;/version&gt;\n     &lt;/dependency&gt;\n           &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n         &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n         &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n         &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n         &lt;version&gt;3.1.0&lt;/version&gt;\n     &lt;/dependency&gt;\n     &lt;dependency&gt;\n         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n         &lt;artifactId&gt;jstl&lt;/artifactId&gt;\n         &lt;version&gt;1.2&lt;/version&gt;\n     &lt;/dependency&gt;\n           &lt;dependency&gt;\n         &lt;groupId&gt;junit&lt;/groupId&gt;\n         &lt;artifactId&gt;junit&lt;/artifactId&gt;\n         &lt;version&gt;4.12&lt;/version&gt;\n         &lt;type&gt;pom.lastUpdated&lt;/type&gt;\n     &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n        &lt;version&gt;3.6&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n        &lt;version&gt;1.2&lt;/version&gt;\n        &lt;type&gt;pom.lastUpdated&lt;/type&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n        &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;\n        &lt;version&gt;1.11&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;commons-io&lt;/groupId&gt;\n        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n        &lt;version&gt;2.5&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n  &lt;version&gt;3.4.1&lt;/version&gt;\n&lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;mysql&lt;/groupId&gt;\n          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n          &lt;version&gt;8.0.11&lt;/version&gt;\n      &lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;com.mchange&lt;/groupId&gt;\n          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;\n          &lt;version&gt;0.9.5.2&lt;/version&gt;\n      &lt;/dependency&gt;\n      &lt;dependency&gt;\n          &lt;groupId&gt;aopalliance&lt;/groupId&gt;\n          &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;\n          &lt;version&gt;1.0&lt;/version&gt;\n          &lt;type&gt;pom.lastUpdated&lt;/type&gt;\n      &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n</code></pre><hr>\n<ul>\n<li><strong>配置spring</strong></li>\n</ul>\n<p>为dao、service、transaction等层分别创建配置文件，方便管理。<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwe0l9i9lnj3080055wei.jpg\" alt=\"\"></p>\n<p><strong>applicationContext-dao.xml：</strong></p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\nxmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;\nxmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\nxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\nxsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-4.3.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-4.3.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop-4.3.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;\n\n&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;\n\n&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;\n    &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\n    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n    &lt;property name=&quot;basePackage&quot; value=&quot;com.me.mapper&quot; /&gt;\n    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;\n&lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre><p><strong>applicationContext-service.xml：</strong></p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\nxmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;\nxmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\nxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\nxsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-4.3.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-4.3.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop-4.3.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;\n\n&lt;context:component-scan base-package=&quot;com.me.service&quot; /&gt;\n\n&lt;/beans&gt;\n</code></pre><p><strong>applicationContext-trans.xml</strong>：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\nxmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;\nxmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\nxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\nxsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans-4.3.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-4.3.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop-4.3.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;\n\n&lt;!-- 配置事务 --&gt;\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;\n    &lt;!-- 切面aop\n&lt;aop:config&gt;\n    &lt;aop:pointcut expression=&quot;execution(* com.me.entity.TestClass.*(..))&quot; id=&quot;pointcut1&quot;/&gt;\n    &lt;aop:aspect ref=&quot;incretestclass&quot;&gt;\n        &lt;aop:before method=&quot;inc&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;\n        &lt;aop:after method=&quot;afterturning&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;\n\n\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt; --&gt;\n&lt;/beans&gt;\n</code></pre><hr>\n<ul>\n<li><p><strong>数据库配置文件</strong><br><strong>db.properties</strong></p>\n<pre><code>jdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc\\:mysql\\://localhost\\:3306/photo?characterEncoding\\=utf-8\njdbc.username=root\njdbc.password=olonn\n</code></pre></li>\n</ul>\n<hr>\n<p>##mybatis</p>\n<ul>\n<li><strong>SqlMapConfig.xml</strong></li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\n&lt;configuration&gt;\n    &lt;settings&gt;\n        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;\n        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;\n        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;\n</code></pre><hr>\n<h2 id=\"springmvc\"><a href=\"#springmvc\" class=\"headerlink\" title=\"springmvc\"></a>springmvc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans \n         http://www.springframework.org/schema/beans/spring-beans.xsd \n         http://www.springframework.org/schema/context \n         http://www.springframework.org/schema/context/spring-context.xsd \n         http://www.springframework.org/schema/tx         \n         http://www.springframework.org/schema/tx/spring-tx.xsd\n         http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n       &lt;!-- 配置扫描的包 --&gt;\n       &lt;context:component-scan base-package=&quot;com.me.controller&quot; /&gt;\n\n       &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;\n       &lt;mvc:annotation-driven /&gt;\n\n        &lt;!--访问静态资源 --&gt;\n       &lt;mvc:default-servlet-handler /&gt;\n\n       &lt;!-- 视图解析器 --&gt;\n       &lt;bean\n           class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n           &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;\n           &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;\n       &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre><hr>\n<h2 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;\n&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt;\n\n  &lt;context-param&gt;\n    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;\n  &lt;/context-param&gt;\n  &lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n  &lt;/listener&gt;\n\n  &lt;filter&gt;\n      &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n      &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n  &lt;/filter&gt;\n  &lt;filter-mapping&gt;\n      &lt;filter-name&gt;encoding&lt;/filter-name&gt;\n      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n  &lt;/filter-mapping&gt;\n\n  &lt;servlet&gt;\n      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n      &lt;init-param&gt;\n          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n          &lt;param-value&gt;classpath:springmvc/springmvc.xml&lt;/param-value&gt;\n      &lt;/init-param&gt;\n  &lt;/servlet&gt;\n  &lt;servlet-mapping&gt;\n      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n      &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n  &lt;/servlet-mapping&gt;\n\n    &lt;welcome-file-list&gt;\n    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\n    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\n    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\n    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\n    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\n    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\n  &lt;/welcome-file-list&gt;\n\n&lt;/web-app&gt;\n</code></pre><hr>\n<p>可使用逆向工程生成对应数据库下的pojo类和mapper配置文件及接口，复制到对应的包下。</p>\n<hr>\n<hr>\n<h2 id=\"测试一下\"><a href=\"#测试一下\" class=\"headerlink\" title=\"测试一下\"></a>测试一下</h2><p>创建一个service类</p>\n<pre><code>package com.me.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport com.me.mapper.UserMapper;\nimport com.me.pojo.User;\n\n@Service\npublic class UserService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    public User selectUser(int i) {\n        return userMapper.selectByPrimaryKey(i);\n    }\n}\n</code></pre><p>创建一个controller</p>\n<pre><code>package com.me.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport com.me.service.UserService;\n\n@Controller\npublic class LoginController {\n\n    @Autowired\n    private UserService uService;\n\n    @RequestMapping(value=&quot;/login&quot;)\n    public ModelAndView login() {\n        ModelAndView modelAndView=new ModelAndView();\n        modelAndView.setViewName(&quot;/login&quot;);\n        modelAndView.addObject(&quot;user&quot;, uService.selectUser(101));\n        return modelAndView;\n    }\n}\n</code></pre><p>view目录下创建一个login.jsp</p>\n<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;\n    pageEncoding=&quot;utf-8&quot;%&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    hahaha+${user.name}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><hr>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1fwe14h61gsj30m906tdg9.jpg\" alt=\"\"></p>\n<hr>\n<ul>\n<li><strong>配置中遇到的异常和错误</strong><blockquote>\n<p><a href=\"https://blog.csdn.net/u014805893/article/details/52016570\" target=\"_blank\" rel=\"noopener\">通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明</a><br><a href=\"https://blog.csdn.net/eacter/article/details/44624505\" target=\"_blank\" rel=\"noopener\">关于spring”通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明“的错误</a></p>\n</blockquote>\n</li>\n</ul>\n<p>其实都是spring配置中的schema配置错误，当缺少哪条时就应该补上对应的xsd文件，具体可以在org.springframework.context.config包下找到，但添加内容并不在这里面，如缺少context的xsd，就加</p>\n<pre><code>http://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context-4.3.xsd\n</code></pre><p>配对存在，第二条后面加上具体内容和版本（导入什么包，就加写什么版本）。</p>\n<hr>\n<p>ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ…</p>\n","categories":["spring"],"tags":["mybatis","springmvc","spring","ssm"]},{"title":"【shiro】SpringBoot整合shiro实例","url":"/2019/03/19/%E3%80%90shiro%E3%80%91SpringBoot%E6%95%B4%E5%90%88shiro%E5%AE%9E%E4%BE%8B/","content":"<h1 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h1><p>粗暴一点，上图<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g187okinhoj309e0i20t8.jpg\" alt=\"\"></p>\n<p>展开是这样的<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g187q7hnv7j30900dtaad.jpg\" alt=\"\"></p>\n<p>由于我把用户角色和密码放在了一张用户表上，这里Role类以及Mapper并没有使用</p>\n<p>另外为了只是简单的测试，没有加上权限操作字段，使用表如下<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g187vn7di9j308o02udfo.jpg\" alt=\"\"></p>\n<hr>\n<h2 id=\"导入依赖\"><a href=\"#导入依赖\" class=\"headerlink\" title=\"导入依赖\"></a>导入依赖</h2><pre><code>&lt;dependencies&gt;\n    //controller层需要\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    //数据库连接\n    &lt;dependency&gt;\n        &lt;groupId&gt;mysql&lt;/groupId&gt;\n        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;version&gt;8.0.13&lt;/version&gt;\n    &lt;/dependency&gt;\n    //mybatis整合\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n        &lt;version&gt;1.3.1&lt;/version&gt;\n    &lt;/dependency&gt;\n    //测试\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    //shiro整合\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n        &lt;version&gt;1.3.2&lt;/version&gt;\n    &lt;/dependency&gt;\n    //lombok使用\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.18.4&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><hr>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>log4j.properties</p>\n<pre><code># Configure logging for testing: optionally with log file\nlog4j.rootLogger=info, stdout  \n# log4j.rootLogger=WARN, stdout, logfile\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender  \nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n  \n\nlog4j.appender.logfile=org.apache.log4j.FileAppender  \nlog4j.appender.logfile.File=target/spring.log  \nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout  \nlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre><p>application.properties</p>\n<pre><code>server.port=8080  \n\nspring.datasource.url=jdbc:mysql://localhost:3306/shirodemo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;&amp;serverTimezone=GMT&amp;allowPublicKeyRetrieval=true  \nspring.datasource.username=root  \nspring.datasource.password=olonn  \nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  \n\nmybatis.mapper-locations=classpath:mapper/*.xml\n</code></pre><p>UserMapper.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\n&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt;\n    &lt;!-- 开启二级缓存 --&gt;\n    &lt;!--    &lt;cache type=&quot;org.mybatis.caches.ehcache.LoggingEhcache&quot;/&gt;--&gt;\n\n    &lt;select id=&quot;selectPasswordByName&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT password FROM USER WHERE username = #{name}\n    &lt;/select&gt;\n\n    &lt;select id=&quot;selectRoleByName&quot; resultType=&quot;java.lang.String&quot;&gt;\n        SELECT role FROM USER WHERE username = #{name}\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre><hr>\n<h2 id=\"bo类\"><a href=\"#bo类\" class=\"headerlink\" title=\"bo类\"></a>bo类</h2><p>User</p>\n<pre><code>@Data\npublic class User implements Serializable {\n    private int id;\n    private String username;\n    private String password;\n    private String role;\n}\n</code></pre><h2 id=\"shiro配置\"><a href=\"#shiro配置\" class=\"headerlink\" title=\"shiro配置\"></a>shiro配置</h2><p>ShiroConfig<br>这是shiro配置的核心，我们要把自定义realm、加密方式等注入securityManager对象，然后把该对象放入shiroFilterFactoryBean，并配置请求的url需要用户登陆或者有无权限，权限信息为<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188f9apoqj30qv0ckq4i.jpg\" alt=\"\"></p>\n<pre><code>@Configuration\npublic class ShiroConfig {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ShiroConfig.class);\n\n    @Bean\n    public UserRealm getRealm(){\n        return new UserRealm();\n    }\n\n    @Bean(name = &quot;securityManager&quot;)\n    public SecurityManager securityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(getRealm());\n        return securityManager;\n    }\n\n    //这里可以进行加密方式配置\n    @Bean\n    public HashedCredentialsMatcher credentialsMatcher(){\n        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();\n\n        hashedCredentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);\n        hashedCredentialsMatcher.setHashIterations(3);\n        return hashedCredentialsMatcher;\n    }\n\n    @Bean\n    public ShiroFilterFactoryBean shiroFilter(@Qualifier(&quot;securityManager&quot;) SecurityManager securityManager){\n        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n\n        shiroFilterFactoryBean.setSecurityManager(securityManager);\n        //setLoginUrl 如果不设置值，默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 或 &quot;/login&quot; 映射\n        shiroFilterFactoryBean.setLoginUrl(&quot;/notLogin&quot;);\n        //无权限时的跳转\n        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/noRole&quot;);\n\n        //设置拦截器\n        Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();\n        //游客，开发权限\n        filterChainDefinitionMap.put(&quot;/guest/**&quot;,&quot;anon&quot;);\n        //用户\n        filterChainDefinitionMap.put(&quot;/user/**&quot;,&quot;roles[user]&quot;);\n        //管理员\n        filterChainDefinitionMap.put(&quot;/admin/**&quot;,&quot;roles[admin]&quot;);\n        //登陆接口\n        filterChainDefinitionMap.put(&quot;/login/**&quot;,&quot;anon&quot;);\n        //拦截所有其他接口，必须放在所有权限验证的最后，不然会把所有url全部拦截\n        filterChainDefinitionMap.put(&quot;/**&quot;,&quot;authc&quot;);\n\n        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\n        LOGGER.info(&quot;shiro拦截工厂类启动成功&quot;);\n        return shiroFilterFactoryBean;\n    }\n}\n</code></pre><h2 id=\"Mapper接口（一般要用service操作）\"><a href=\"#Mapper接口（一般要用service操作）\" class=\"headerlink\" title=\"Mapper接口（一般要用service操作）\"></a>Mapper接口（一般要用service操作）</h2><pre><code>@Mapper\npublic interface UserMapper {\n    /**\n     * fetch data by rule id\n     *\n     * @param username\n     * @return Result&lt;String&gt;\n     */\n    String selectPasswordByName(@Param(&quot;name&quot;) String username);\n\n    /**\n     * fetch data by rule id\n     *\n     * @param username\n     * @return Result&lt;String&gt;\n     */\n    String selectRoleByName(@Param(&quot;name&quot;) String username);\n}\n</code></pre><h2 id=\"自定义Realm\"><a href=\"#自定义Realm\" class=\"headerlink\" title=\"自定义Realm\"></a>自定义Realm</h2><pre><code>@Component\npublic class UserRealm extends AuthorizingRealm {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(UserRealm.class);\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        LOGGER.info(&quot;-----权限验证-----&quot;);\n        String username = (String) principals.getPrimaryPrincipal();\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        info.addRole(userMapper.selectRoleByName(username));\n        return info;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        LOGGER.info(&quot;-----身份验证-----&quot;);\n        String username = (String) token.getPrincipal();\n        String password = userMapper.selectPasswordByName(username);\n        if (null==password){\n            throw new AccountException(&quot;用户名不正确&quot;);\n        }\n        return new SimpleAuthenticationInfo(username,password,getName());\n    }\n\n    private ByteSource generateSalt(String salt){\n        return ByteSource.Util.bytes(salt);\n    }\n}\n</code></pre><p>为了简单示例，没有加加密操作，另外登陆失败的异常没有处理</p>\n<h2 id=\"控制层\"><a href=\"#控制层\" class=\"headerlink\" title=\"控制层\"></a>控制层</h2><p>LoginController</p>\n<pre><code>@RestController\npublic class LoginController {\n\n    private static HashMap&lt;String,String&gt; myp = new HashMap&lt;&gt;(16);\n\n    @RequestMapping(&quot;/notLogin&quot;)\n    @ResponseBody\n    public HashMap&lt;String, String&gt; notlogin(){\n        myp.put(&quot;hello&quot;,&quot;world&quot;);\n        return myp;\n    }\n\n    @RequestMapping(&quot;/login/{username}/{password}&quot;)\n    @ResponseBody\n    public HashMap&lt;String, String&gt; login(@PathVariable(&quot;username&quot;)String username,@PathVariable(&quot;password&quot;)String password){\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(username,password);\n        subject.login(token);\n\n        myp.put(&quot;for&quot;,&quot;login&quot;);\n        return myp;\n    }\n\n    @RequestMapping(&quot;/noRole&quot;)\n    @ResponseBody\n    public HashMap&lt;String, String&gt; noRole(){\n        myp.put(&quot;for&quot;,&quot;login&quot;);\n        return myp;\n    }\n}\n</code></pre><p>UserController</p>\n<pre><code>@RestController\npublic class UserController {\n\n    private static HashMap&lt;String ,String &gt; mymap = new HashMap&lt;&gt;(16);\n\n    @RequestMapping(&quot;/admin/{admin}&quot;)\n    @ResponseBody\n    public HashMap admin(@PathVariable(&quot;admin&quot;)String admin){\n        mymap.put(&quot;admin&quot;,admin);\n        return mymap;\n    }\n\n    @RequestMapping(&quot;/user/{user}&quot;)\n    @ResponseBody\n    public HashMap user(@PathVariable(&quot;user&quot;)String user){\n        mymap.put(&quot;user&quot;,user);\n        return mymap;\n    }\n\n    @RequestMapping(&quot;/guest/{guest}&quot;)\n    @ResponseBody\n    public HashMap guest(@PathVariable(&quot;guest&quot;)String guest){\n        mymap.put(&quot;guest&quot;,guest);\n        return mymap;\n    }\n}\n</code></pre><hr>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>上面代码算是全部写完了，接下来验证</p>\n<p>运行springboot启动类</p>\n<p>访问<a href=\"http://localhost:8080/xxxxxx\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/xxxxxx</a><br>自动跳转到/notLogin<br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188jn6zyhj30dm04h3yh.jpg\" alt=\"\"></p>\n<p>访问<a href=\"http://localhost:8080/guest/xxxx\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/guest/xxxx</a><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188kz7r0gj30ck02q748.jpg\" alt=\"\"></p>\n<p>访问<a href=\"http://localhost:8080/user/zzzz同样跳转到notLogin\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/user/zzzz同样跳转到notLogin</a></p>\n<p>访问<a href=\"http://localhost:8080/login/ccc/123\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/login/ccc/123</a><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188ngkd4ij30h3076jru.jpg\" alt=\"\"><br>找不到用户，后台抛出异常未处理</p>\n<p>访问<a href=\"http://localhost:8080/login/bbb/123\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/login/bbb/123</a><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188pbjdvej30br03dt8o.jpg\" alt=\"\"><br>登陆成功</p>\n<p>然后访问<a href=\"http://localhost:8080/user/我登陆了\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/user/我登陆了</a><br><img src=\"http://ww1.sinaimg.cn/large/006azB5Sly1g188qiwempj30ae037weg.jpg\" alt=\"\"><br>可以成功访问</p>\n<p>访问<a href=\"http://localhost:8080/admin/mmmm\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/admin/mmmm</a><br>自动跳转到/noRole</p>\n<hr>\n","categories":["shiro"],"tags":["springboot"]},{"title":"【数据结构】基础结构实现集合","url":"/2018/10/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/","content":"<p>一些我早期学数据结构的时候用C++实现的代码。<del>指针在实现上比较方便</del></p>\n<hr>\n<h2 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"(1)栈\"></a>(1)栈</h2><pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n\ntypedef int SElemType;\ntypedef struct StackNode{\n    SElemType data;\n    struct StackNode *next;\n}StackNode,*LinkStack;\n\nint InitStack(LinkStack &amp;top){\n    top = (StackNode*)malloc(sizeof(StackNode));\n    if(top!=NULL){\n        top = NULL;\n    }\n    return OK;\n}\n\nint Push(LinkStack &amp;top,SElemType e){\n    LinkStack p =(StackNode*)malloc(sizeof(StackNode));\n    p-&gt;data=e;\n    p-&gt;next=top;\n    top=p;\n    return OK;\n}\n\nint CreateStack(LinkStack &amp;top){\n    int n;\n    cout &lt;&lt; &quot;输入入栈元素个数:&quot;;\n    cin&gt;&gt;n;\n    for(int i=0;i&lt;n;i++){\n        int m;\n        cout&lt;&lt;&quot;输入进栈元素:&quot;;\n        cin&gt;&gt;m;\n        Push(top,m);\n    }\n    return OK;\n}\n\nint Pop(LinkStack &amp;top,SElemType &amp;e){\n    LinkStack p;\n    if(top!=NULL){\n        p=top;\n        e = top-&gt;data;\n        top = top-&gt;next;\n        free(p);\n    }\n    else\n        return ERROR;\n    return OK;\n}\n\nint GetTop(LinkStack top,SElemType &amp;e){\n    if(top!=NULL)\n        e = top-&gt;data;\n    else\n        return ERROR;\n    return OK;\n}\n\nvoid outStack(LinkStack top){\n    while(top!=NULL){\n        cout&lt;&lt;top-&gt;data&lt;&lt;endl;\n        top=top-&gt;next;\n    }\n}\n\n\nint main(){\n    LinkStack top;\n    InitStack(top);\n    CreateStack(top);\n    outStack(top);\n    int e;\n    cout&lt;&lt;&quot;出栈一次;&quot;;\n    Pop(top,e);\n    cout&lt;&lt;&quot;出栈元素:&quot;&lt;&lt;e&lt;&lt;endl;\n    outStack(top);\n    GetTop(top,e);\n    cout&lt;&lt;&quot;栈顶元素为:&quot;&lt;&lt;e&lt;&lt;endl;\n\n    return 0;\n}\n</code></pre><h2 id=\"2-静态链表\"><a href=\"#2-静态链表\" class=\"headerlink\" title=\"(2)静态链表\"></a>(2)静态链表</h2><pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\n#define MAXSIZE 1000\n#define OK 1\n#define ERROR 0\n#define FALSE 0\n#define TRUE 1\n\ntypedef int status;\n\ntypedef struct{\n    status data;\n    int cur;\n}\ncomponent,    SLinkList[MAXSIZE];\n\n//初始化\nstatus InitList(SLinkList space){\n    int i;\n    for(i=0;i&lt;MAXSIZE-1;i++)\n        space[i].cur = i+1;\n    space[MAXSIZE-1].cur=0;\n    return OK;\n}\n\n//若备用空间链表非空，返回分配的结点下标\nint Malloc_SLL(SLinkList space){\n    int i = space[0].cur;\n\n    if(space[0].cur)\n        space[0].cur = space[i].cur;\n\n    return i;\n}\n\nint ListLength(SLinkList sl){\n    int j=0;\n    int i=sl[MAXSIZE-1].cur;\n    while(i){\n        i=sl[i].cur;\n        j++;\n    }\n    return j;\n}\n\n\n//插入\nstatus ListInsert(SLinkList L,int i,status e){\n    int j,k,l;\n    k=MAXSIZE-1;\n    if(i&lt;1||i&gt;ListLength(L)+1)\n        return ERROR;\n    j=Malloc_SLL(L);\n    if(j){\n        L[j].data=e;\n        for(l=1;l&lt;=i-1;l++)\n            k=L[k].cur;\n        L[j].cur=L[k].cur;\n        L[k].cur=j;\n        return OK;\n    }\n    return ERROR;\n}\n\n//回收空闲结点\nvoid Free_SSL(SLinkList space,int k){\n    space[k].cur=space[0].cur;\n    space[0].cur=k;\n}\n//删除\nstatus ListDelete(SLinkList L,int i){\n    int j,k;\n    if(i&lt;1||i&gt;ListLength(L))\n        return ERROR;\n    k = MAXSIZE-1;\n    for(j=1;j&lt;=i-1;j++)\n        k=L[k].cur;\n    j=L[k].cur;\n    L[k].cur=L[j].cur;\n    Free_SSL(L,j);\n    return OK;\n}\n\n\nint main(){\n    return 0;\n}\n</code></pre><p>(3)链式存储结构表及表间操作</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\nusing namespace std;\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n\ntypedef int Status;\n\ntypedef struct LNode{\n    Status data;\n    struct LNode *next;                \n}LNode ,*LinkList;\n\nStatus InitList(LinkList &amp;L){\n    L = (LNode*)malloc(sizeof(LNode));\n\n    if(L == NULL)\n        return ERROR;\n    L-&gt;next=NULL;\n    return OK;\n}\n\nStatus GetElem(LinkList L,int i,Status *e){\n    int j;\n    LinkList p;\n    p = L-&gt;next;\n    j = 1;\n    while(p&amp;&amp;j&lt;i){\n        p = p-&gt;next;\n        ++j;\n    }\n    if(!p||j&gt;i)\n        return ERROR;\n    *e = p-&gt;data;\n    return OK;\n}\n\nStatus ListInsert(LinkList &amp;L,int i,Status e){\n    int j;\n    LinkList p,s;\n    p = L;\n    j=1;\n    while( p &amp;&amp; j&lt;i ){\n        p=p-&gt;next;\n        ++j;\n    }\n    if(!p||j&gt;i)\n        return ERROR;\n    s =(LinkList)malloc(sizeof(LNode));\n    s-&gt;data = e;\n    s-&gt;next = p-&gt;next;\n\n    p-&gt;next = s;  \n    return OK;\n}\n\nStatus ListDelete(LinkList &amp;L,int i,Status *e){\n    int j;\n    LinkList p,q;\n\n    p = L;\n    j = 1;\n    while(p-&gt;next&amp;&amp;j&lt;i){\n        p = p-&gt;next;\n        ++j;\n    }\n    if(!(p-&gt;next)||j&gt;i)\n        return ERROR;\n    q=p-&gt;next;\n    p-&gt;next=q-&gt;next;\n    *e = q-&gt;data;\n    free(q);\n    return OK;\n}\n\nvoid CreateList(LinkList &amp;L,int n){\n    LinkList p ;\n    int i;\n    srand(time(0));\n    L-&gt;next=NULL;\n    for(i=0;i&lt;n;i++){\n        p=(LinkList) malloc(sizeof(LNode));\n        p-&gt;data=rand()%100+1;\n        p-&gt;next=L-&gt;next;\n        L-&gt;next = p;\n    }\n}\n\nStatus ClearList(LinkList &amp;L){\n    LinkList p,q;\n    p=L-&gt;next;\n    while(p){\n        q=p-&gt;next;\n        free(p);\n        p=q;\n    }\n    L-&gt;next=NULL;\n    return OK;\n}\n\nvoid unionList(LinkList &amp;L,LinkList L1){\n    LinkList p;\n    p=L;\n    L=p;\n    while(p-&gt;next){\n        p = p-&gt;next;\n    }\n    p-&gt;next=L1-&gt;next;\n}\n\nvoid outList(LinkList L){\n    L=L-&gt;next;\n    while(L!=NULL){\n        cout&lt;&lt;L-&gt;data&lt;&lt;&quot; &quot;;\n        L=L-&gt;next;\n    }\n    cout&lt;&lt;endl;\n}\n\nint main(){\n    LinkList p;\n    InitList(p);\n    CreateList(p,4);\n    outList(p);\n\n    cout &lt;&lt; &quot;请输入插入元素位置：&quot;;\n    int i;\n    cin&gt;&gt;i;\n    cout&lt;&lt;&quot;请输入插入元素:&quot;;\n    int e;\n    cin&gt;&gt;e;\n    ListInsert(p,i,e);\n    outList(p);\n\n    cout&lt;&lt;&quot;请输入删除元素位置:&quot;;\n    int j;\n    int num;\n    cin&gt;&gt;j;\n    ListDelete(p,j,&amp;num);\n    outList(p);\n    cout&lt;&lt;&quot;删除元素为:&quot;&lt;&lt;num&lt;&lt;endl;\n\n    cout &lt;&lt; &quot;表2:&quot;;\n    LinkList p1;\n    InitList(p1);\n    CreateList(p1,7);\n    outList(p1);\n\n    cout &lt;&lt; &quot;合并得:&quot;&lt;&lt;endl;\n    unionList(p,p1);\n    outList(p);\n\n    return 0;\n}\n</code></pre><h2 id=\"4-堆实现字符串\"><a href=\"#4-堆实现字符串\" class=\"headerlink\" title=\"(4)堆实现字符串\"></a>(4)堆实现字符串</h2><pre><code>//字符串的堆分配表示与实现\n#include&lt;iostream&gt;\n\nusing namespace std;\n\n#define MAXISIZE 100\n#define ERROR 0\n#define OK 1\n\ntypedef struct string \n{\n    char *str;\n    int length;\n}HeapString;\n\n//初始化串\nint initString(HeapString &amp;pH)\n{\n    pH.str =&apos;\\0&apos;;\n    pH.length = 0;\n    return OK;\n}\n\n//给指定的字符串赋值\nint strAssign(HeapString &amp;pH,char cstr[])\n{\n    int i;\n    int len;\n    if(pH.str)\n        free(pH.str);\n    for( i = 0;cstr[i]!=&apos;\\0&apos;;i++);\n        len = i;\n    if(!cstr)\n    {\n        pH.length = 0;\n        pH.str = &apos;\\0&apos;;\n    }\n    else\n    {\n        pH.str = (char * )malloc(len*sizeof(char));\n        if(!pH.str)\n        {\n            return ERROR;\n        }\n        for(i = 0;i&lt;len;i++)\n        {\n            pH.str[i] = cstr[i];\n        }\n        pH.length = len;\n    }\n    return OK;\n}\n\n//字符串的插入\nint strInsert(HeapString &amp;pH,int pos,HeapString S)\n{\n    int i;\n    if(pos&lt;1||pos&gt;pH.length+1)\n        return ERROR;\n    pH.str = (char *)realloc(pH.str,(pH.length+S.length)*sizeof(char));\n    if(!pH.str)\n        return ERROR;\n    for(i = pH.length-1;i&gt;=pos-1;i--)\n    {\n        pH.str[i+S.length] = pH.str[i];\n    }\n\n    for(i = 0;i&lt;S.length;i++)\n    {\n        pH.str[i+pos-1]= S.str[i];\n    }\n\n    pH.length = pH.length+ S.length;\n    return OK;\n\n}\n\n//字符串的复制\nint strCopy(HeapString pH,HeapString &amp;T)\n{\n    int i;\n    int len = pH.length;\n    T.str = (char * )malloc(len*sizeof(char));\n    if(!T.str)\n    {\n        return ERROR;\n    }\n    for( i = 0;i&lt;pH.length;i++)\n    {\n        T.str[i] = pH.str[i];\n    }\n    T.length = pH.length;\n    return OK;\n}\n\n//字符串的输出\nint outStr(HeapString pH)\n{\n    int i;\n    for(i = 0;i&lt;pH.length;i++)\n    {\n        cout&lt;&lt;pH.str[i];\n    }\n    cout&lt;&lt;endl;\n    return OK;\n}\n\nint main()\n{\n    HeapString pH;\n    char cstr[MAXISIZE];\n    initString(pH);\n    cout&lt;&lt;&quot;请输入一个字符串:&quot;;\n    gets(cstr);\n    strAssign(pH,cstr);\n    cout &lt;&lt; &quot;串1:&quot;;\n    outStr(pH);\n\n    HeapString pH1;\n    initString(pH1);\n    strCopy(pH,pH1);\n    cout &lt;&lt; &quot;串2:&quot;;\n    outStr(pH1);\n    int pos;\n    cout&lt;&lt;&quot;请输入插入位置:&quot;;\n    cin&gt;&gt;pos;\n    strInsert(pH,pos,pH1);\n    cout&lt;&lt;&quot;插入操作后的串1:&quot;;\n    outStr(pH);\n\n    return 0;\n}\n</code></pre><h2 id=\"5-队列\"><a href=\"#5-队列\" class=\"headerlink\" title=\"(5)队列\"></a>(5)队列</h2><pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\n#define ERROR 0\n#define OK 1\n\ntypedef int QElemType;\ntypedef struct QNode{\n    QElemType data;\n    struct QNode *next;\n}QNode,*QueuePtr;\n\ntypedef struct{\n    QueuePtr front,rear;\n}LinkQueue;\n\nint InitDL(LinkQueue &amp;Q){\n    Q.front = Q.rear=(QNode*)malloc(sizeof(QNode));\n    if(!Q.front)\n        return ERROR;\n    Q.front-&gt;next=NULL;\n    return OK;\n} \n\nint InDL(LinkQueue &amp;Q,QElemType e){\n    QueuePtr p;\n    p=(QueuePtr)malloc(sizeof(QNode));\n    if(!p)\n        return ERROR;\n    p-&gt;data=e;\n    p-&gt;next=NULL;\n    Q.rear-&gt;next=p;\n    Q.rear=p;\n    return OK;\n}\n\nint OutDL(LinkQueue &amp;Q,QElemType &amp;e){\n    QueuePtr p;\n    if(Q.front==Q.rear)\n        return ERROR;\n    p = Q.front-&gt;next;\n    e=p-&gt;data;\n    Q.front-&gt;next=p-&gt;next;\n    if(Q.rear==p)\n        Q.rear=Q.front;\n    free(p);\n    return OK;\n}\n\nint getheadDL(LinkQueue Q,QElemType &amp;e){\n    e=Q.front-&gt;next-&gt;data;\n    return OK;\n}\n\nint prinftDL(LinkQueue Q){\n    QueuePtr p;\n    p=Q.front-&gt;next;\n    while(p){\n        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;  &quot;;\n        p=p-&gt;next;\n    }\n    cout &lt;&lt; endl;\n    return OK;\n}\n\nint main(){\n    LinkQueue Q;\n    InitDL(Q);\n    int m,n,e;\n    cout&lt;&lt;&quot;输入进队元素个数:&quot;;\n    cin&gt;&gt;m;\n    for(int i=0;i&lt;m;i++){\n        cout &lt;&lt; &quot;输入入队元素:&quot;;\n        cin&gt;&gt;n;\n        InDL(Q,n);\n    }\n    prinftDL(Q);\n    getheadDL(Q,e);\n    cout &lt;&lt; &quot;队头元素为:&quot;&lt;&lt;e&lt;&lt;endl;\n    OutDL(Q,e);    \n    cout &lt;&lt; &quot;出队一次，出队元素为:&quot;&lt;&lt;e&lt;&lt;endl;\n    prinftDL(Q);\n    return 0;\n}\n</code></pre><p>循环队列:</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\n#define MAXSIZE 5\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\ntypedef int QElemType;\n\ntypedef struct{\n    QElemType data[MAXSIZE];\n    int front;\n    int rear;\n}SqQueue;\n\n//初始化\nint InitQueue(SqQueue *Q){\n    Q-&gt;front=0;\n    Q-&gt;rear=0;\n    return OK;\n}\n\n//返回长度\nint QueueLength(SqQueue Q){\n    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;\n}\n\n//插入元素e到队尾\nint EnQueue(SqQueue *Q,QElemType e){\n    if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)\n        return ERROR;\n    Q-&gt;data[Q-&gt;rear]=e;\n    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;\n\n    return OK;\n}\n\n//若队列不空，则删除队头元素，用e返回其值\nint DeQueue(SqQueue *Q,QElemType *e){\n    if(Q-&gt;front==Q-&gt;rear)\n        return ERROR;\n    *e=Q-&gt;data[Q-&gt;front];\n    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;\n\n    return OK;\n}\n\n//输出队列\nvoid outQueue(SqQueue Q){\n    int j = (Q.rear-1+MAXSIZE)%MAXSIZE;\n    for(int i=0;i&lt;QueueLength(Q);i++){\n        cout &lt;&lt; (Q.data[j])&lt;&lt;&quot; &quot;;\n        j=((--j) + MAXSIZE)%MAXSIZE;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main(){\n    SqQueue sq;\n    InitQueue(&amp;sq);\n    int a;\n    int count;\n    cout&lt;&lt;&quot;输入插入元素个数:&quot;;\n    cin&gt;&gt;count;\n    for(int i=0;i&lt;count;i++){\n        cout &lt;&lt; &quot;输入插入元素:&quot;;\n        cin&gt;&gt;a;\n        EnQueue(&amp;sq,a);        \n    }\n\n    outQueue(sq);\n\n    int e;\n    int num;\n    cout &lt;&lt; &quot;删除元素个数:&quot;;\n    cin &gt;&gt; num;\n    for(int n=0;n&lt;num;n++){\n        DeQueue(&amp;sq,&amp;e);\n        cout &lt;&lt; &quot;删除元素:&quot;&lt;&lt; e &lt;&lt; endl;        \n    }\n    outQueue(sq);\n\n    cout&lt;&lt;&quot;输入插入元素个数:&quot;;\n    cin&gt;&gt;count;\n    for(int m=0;m&lt;count;m++){\n        cout &lt;&lt; &quot;输入插入元素:&quot;;\n        cin&gt;&gt;a;\n        EnQueue(&amp;sq,a);        \n    }\n\n    outQueue(sq);\n\n\n    cout &lt;&lt; &quot;队列长度:&quot; &lt;&lt; QueueLength(sq) &lt;&lt;endl;\n\n\n    return 0;\n}\n</code></pre><h2 id=\"6-二叉树\"><a href=\"#6-二叉树\" class=\"headerlink\" title=\"(6)二叉树\"></a>(6)二叉树</h2><pre><code>#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\n\n#define TRUE 1\n#define FALSE 0\ntypedef struct BiTNode{\n    int data;\n    struct BiTNode *lchild,*rchild;\n}BiTNode,*BiTree;\n\nint SearchBST(BiTree T,int key,BiTree f,BiTree &amp;p){\n    if(T==NULL){\n        p = f;\n        return FALSE;\n    }\n    else if(key == T-&gt;data){\n        p=T;\n        return TRUE;\n    }\n    else if(key&lt;T-&gt;data)\n        return SearchBST(T-&gt;lchild,key,T,p);\n    else \n        return SearchBST(T-&gt;rchild,key,T,p);\n}\n\nint InsertBST(BiTree &amp;T,int key){\n    BiTree p,s;\n    if(!SearchBST(T,key,NULL,p))\n    {\n        s = (BiTree)malloc(sizeof(BiTree));\n        s-&gt;data=key;\n        s-&gt;lchild=s-&gt;rchild=NULL;\n        if(!p)\n            T=s;\n        else if(key&lt;p-&gt;data)\n            p-&gt;lchild=s;\n        else\n            p-&gt;rchild=s;\n        return TRUE;\n    }\n    else\n        return FALSE;\n}\n\nint Delete(BiTree *p){\n    BiTree q,s;\n    if((*p)-&gt;lchild==NULL&amp;&amp;(*p)-&gt;rchild==NULL)\n        *p=NULL;\n    else if((*p)-&gt;rchild==NULL){\n        q=(*p);\n        (*p)=(*p)-&gt;lchild;\n        free(q);\n    }\n    else if((*p)-&gt;lchild==NULL){\n        q=(*p);\n        (*p)=(*p)-&gt;rchild;\n        free(q);\n    }\n    else{\n        q=(*p);\n        s=(*p)-&gt;lchild;\n        while(s-&gt;rchild!=NULL){\n            q=s;\n            s=s-&gt;rchild;\n        }\n        (*p)-&gt;data=s-&gt;data;\n        if(!s-&gt;lchild){\n            if(q!=(*p))\n                (q)-&gt;rchild=s-&gt;lchild;\n            else\n                (q)-&gt;lchild=s-&gt;lchild;\n            }\n        free(s);\n    }\n    return TRUE;\n}\n\nint DeleteBST(BiTree *T,int key){\n    if(!*T)\n        return FALSE;\n    else{\n        if(key==(*T)-&gt;data)\n            return Delete(T);\n        else if(key&lt;(*T)-&gt;data)\n            return DeleteBST(&amp;(*T)-&gt;lchild,key);\n        else\n            return DeleteBST(&amp;(*T)-&gt;rchild,key);\n    }\n}\n\nint CreateBST(BiTree &amp;T){\n\n    int n;\n    cout &lt;&lt; &quot;输入树的结点个数:&quot;;\n    cin&gt;&gt;n;\n    T=NULL;\n    for(int i=0;i&lt;n;i++){\n        int m;\n        cout &lt;&lt; &quot;输入元素:&quot;;\n        cin&gt;&gt;m;\n        InsertBST(T,m);\n    }\n    return TRUE;\n}\n\nint main(){\n    BiTree T;\n    CreateBST(T);\n    BiTree f=NULL;\n    BiTree    p;\n    int key;\n    cout &lt;&lt; &quot;请输入查找元素:&quot;;\n    cin&gt;&gt;key;\n    if(SearchBST(T,key,f,p)){\n        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;\n    }\n    else\n        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;\n\n    int key1;\n    cout&lt;&lt;&quot;请输入删除元素:&quot;;\n    cin&gt;&gt;key1;\n    DeleteBST(&amp;T,key1);\n    int key2;\n    cout &lt;&lt; &quot;请输入查找元素:&quot;;\n    cin&gt;&gt;key2;\n    if(SearchBST(T,key2,f,p)){\n        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;\n    }\n    else\n        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;\n    return 0;\n}\n</code></pre><h2 id=\"7-图\"><a href=\"#7-图\" class=\"headerlink\" title=\"(7)图\"></a>(7)图</h2><pre><code>#include&lt;iostream&gt;\n#include &quot;DL.h&quot;\n\nusing namespace std;\n\n#define ERROR 0\n#define OK 1\n#define MAXVEX 100\n#define INFINITY 65535\ntypedef int Boolean;\nBoolean visited[MAXVEX];\ntypedef char VertexType;\ntypedef int EdgeType;\n\n//邻接矩阵\ntypedef struct{\n    VertexType vexs[MAXVEX];\n    EdgeType arc[MAXVEX][MAXVEX];\n    int numVertexes,numEdges;\n}MGraph;\n\nvoid CreateMGraph(MGraph *G){\n    int i,j,k,w;\n    cout&lt;&lt;&quot;输入顶点数和边数:\\n&quot;;\n    cin&gt;&gt;G-&gt;numVertexes;\n    cin&gt;&gt;G-&gt;numEdges;\n    for(i=0;i&lt;G-&gt;numVertexes;i++){\n        cout &lt;&lt; &quot;输入顶点:&quot;;\n        cin&gt;&gt;G-&gt;vexs[i];\n    }\n    for(i=0;i&lt;G-&gt;numVertexes;i++){\n        for(j=0;j&lt;G-&gt;numVertexes;j++){\n            G-&gt;arc[i][j]=INFINITY;\n        }\n    }\n    for(k=0;k&lt;G-&gt;numEdges;k++){\n        cout&lt;&lt;&quot;输入边（vi,vj）上的下标i，下标j和权w:&quot;&lt;&lt;endl;\n        cin&gt;&gt;i;\n        cin&gt;&gt;j;\n        cin&gt;&gt;w;\n        G-&gt;arc[i][j]=w;\n        G-&gt;arc[j][i]=G-&gt;arc[i][j];\n    }\n}\n\n//深度优先\nvoid DFS(MGraph G,int i){\n    int j;\n    visited[i]=1;\n    cout&lt;&lt;G.vexs[i];\n    for(j=0;j&lt;G.numVertexes;j++)\n        if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j])\n            DFS(G,j);\n}\nvoid DFSTraverse(MGraph G){\n    int i;\n    for(i=0;i&lt;G.numVertexes;i++)\n        visited[i]=0;\n    for(i=0;i&lt;G.numVertexes;i++)\n        if(!visited[i])\n            DFS(G,i);\n}\n\n//广度遍历\nvoid BFSTraverse(MGraph G){\n    int i,j;\n    LinkQueue Q;\n    for(i=0;i&lt;G.numVertexes;i++)\n        visited[i]=0;\n    InitDL(Q);\n    for(i=0;i&lt;G.numVertexes;i++){\n        if(!visited[i]){\n            visited[i]=1;\n            cout&lt;&lt;G.vexs[i];\n            InDL(Q,i);\n            while(!DLEmpty(Q)){\n                OutDL(Q,i);\n                for(j=0;j&lt;G.numVertexes;j++){\n                    if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j]){\n                        visited[j]=1;\n                        cout &lt;&lt;G.vexs[j];\n                        OutDL(Q,j);\n                    }\n                }\n            }\n        }\n    }\n}\n\n//普里姆算法\nvoid MiniSpanTree_Prim(MGraph G){\n    int min,i,j,k;\n    int adjvex[MAXVEX];\n    int lowcost[MAXVEX];\n    lowcost[0]=0;\n    adjvex[0]=0;\n    for(i=1;i&lt;G.numVertexes;i++){\n        lowcost[i]=G.arc[0][i];\n        adjvex[i]=0;\n    }\n    for(i=1;i&lt;G.numVertexes;i++){\n        min = INFINITY;\n\n        j=1;\n        k=0;\n        while(j&lt;G.numVertexes){\n            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min){\n                min = lowcost[j];\n                k=j;\n            }\n            j++;\n        }\n        cout&lt;&lt;&quot;(&quot;&lt;&lt;adjvex[k]&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;)&quot;;\n        lowcost[k]=0;\n        for(j=1;j&lt;G.numVertexes;j++){\n            if(lowcost[j]!=0&amp;&amp;G.arc[k][j]&lt;lowcost[j]){\n                lowcost[j]=G.arc[k][j];\n                adjvex[j]=k;\n            }\n        }\n    }\n}\n\nint main(){\n    MGraph G;\n    CreateMGraph(&amp;G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;深度遍历&quot;&lt;&lt;endl;\n    DFSTraverse(G);\n    cout &lt;&lt; endl;\n    cout &lt;&lt; &quot;广度遍历&quot;&lt;&lt;endl;\n    BFSTraverse(G); \n    cout &lt;&lt; endl;\n    MiniSpanTree_Prim(G);\n    return 0;\n}\n</code></pre><hr>\n<p>这些结构里也包含它们对应的遍历、插入、删除算法（<del>有些还未经优化</del>）….<br>当然这里还漏了很多基本结构类型，之后再补吧。<br>….</p>\n<hr>\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"【转】一文学会索引设计技巧","url":"/2020/07/24/%E3%80%90%E8%BD%AC%E3%80%91%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/","content":"<blockquote>\n<p>本文来源于微信公众号码海  ，作者码海</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>生产上为了高效地查询数据库中的数据，我们常常会给表中的字段添加索引，大家是否有考虑过如何添加索引才能使索引更高效，考虑如下问题：</p>\n<ul>\n<li><p>添加的索引是越多越好吗？</p>\n</li>\n<li><p>为啥有时候明明添加了索引却不生效？</p>\n</li>\n<li><p>索引有哪些类型？</p>\n</li>\n<li><p>如何评判一个索引设计的好坏？</p>\n</li>\n</ul>\n<p>看了本文相信你会对索引的原理有更清晰的认识。本文将会从以下几个方面来讲述索引的相关知识，相信大家耐心看了之后肯定有收获。</p>\n<ul>\n<li><p>什么是索引，索引的作用</p>\n</li>\n<li><p>索引的种类</p>\n</li>\n<li><p>高性能索引策略</p>\n</li>\n<li><p>索引设计准则：三星索引</p>\n</li>\n</ul>\n<h2 id=\"什么是索引，索引的作用\"><a href=\"#什么是索引，索引的作用\" class=\"headerlink\" title=\"什么是索引，索引的作用\"></a>什么是索引，索引的作用</h2><p>当我们要在新华字典里查某个字（如「先」）具体含义的时候，通常都会拿起一本新华字典来查，你可以先从头到尾查询每一页是否有「先」这个字，这样做（对应数据库中的全表扫描）确实能找到，但效率无疑是非常低下的，更高效的方法相信大家也都知道，就是在首页的索引里先查找「先」对应的页数，然后直接跳到相应的页面查找，这样查询时间大大减少了，可以是 O(1)。</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/24/UXghLR.jpg\" alt=\"UXghLR.jpg\"></p>\n<p>数据库中的索引也是类似的，通过索引定位到要读取的页，大大减少了需要扫描的行数，能极大地提升效率。简而言之，索引主要有以下几个作用：</p>\n<ol>\n<li><p>即上述所说，索引能极大地减少扫描行数。</p>\n</li>\n<li><p>索引可以帮助服务器避免排序和临时表。</p>\n</li>\n<li><p>索引可以将随机 IO 变成顺序 IO。</p>\n</li>\n</ol>\n<p>第一点上文已经解释了，我们来看下第二点和第三点。</p>\n<p>先来看第二点，假设我们不用索引，试想运行如下语句：</p>\n<p><code>SELECT * FROM user order by age desc;</code></p>\n<p>则 MySQL 的流程是这样的，扫描所有行，把所有行加载到内存后，再按 age 排序生成一张临时表，再把这表排序后将相应行返回给客户端，更糟的，如果这张临时表的大小大于 tmp_table_size 的值（默认为 16 M），内存临时表会转为磁盘临时表，性能会更差，如果加了索引，索引本身是有序的 ，所以从磁盘读的行数本身就是按 age 排序好的，也就不会生成临时表，就不用再额外排序 ，无疑提升了性能。</p>\n<p>再来看随机 IO 和顺序 IO。先来解释下这两个概念。</p>\n<p>相信不少人应该吃过旋转火锅，服务员把一盘盘的菜放在旋转传输带上，然后等到这些菜转到我们面前，我们就可以拿到菜了。假设转一圈需要 4 分钟，则最短等待时间是 0（即菜就在你跟前），最长等待时间是 4 分钟（菜刚好在你跟前错过），那么平均等待时间即为 2 分钟。假设我们现在要拿四盘菜，这四盘菜<strong>随机分配</strong>在传输带上，则可知拿到这四盘菜的平均等待时间是 8 分钟（随机 IO），如果这四盘菜刚好紧邻着排在一起，则等待时间只需 2 分钟（顺序 IO）。</p>\n<p>上述中传输带就类比磁道，磁道上的菜就类比扇区（sector）中的信息，磁盘块（block）是由多个相邻的扇区组成的，是操作系统读取的最小单元，这样如果信息能以 block 的形式聚集在一起，就能极大减少磁盘 IO 时间，这就是顺序 IO 带来的性能提升，下文中我们将会看到 B+ 树索引就起到这样的作用。</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/24/UX29Ff.png\" alt=\"UX29Ff.png\"></p>\n<p><em>如图示：多个扇区组成了一个 block，如果要读的信息都在这个 block 中，则只需一次 IO 读</em></p>\n<p>而如果信息在一个磁道中分散地分布在各个扇区中，或者分布在不同磁道的扇区上（寻道时间是随机IO主要瓶颈所在），将会造成随机 IO，影响性能。</p>\n<p>我们来看一下一个随机 IO 的时间分布：</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/24/UX21l4.png\" alt=\"UX21l4.png\"></p>\n<ol>\n<li><p>seek Time: 寻道时间，磁头移动到扇区所在的磁道。</p>\n</li>\n<li><p>Rotational Latency：完成步骤 1 后，磁头移动到同一磁道扇区对应的位置所需求时间。</p>\n</li>\n<li><p>Transfer Time 从磁盘读取信息传入内存时间。</p>\n</li>\n</ol>\n<p>这其中寻道时间占据了绝大多数的时间（大概占据随机 IO 时间的40%）。</p>\n<p>随机 IO 和顺序 IO 大概相差百倍 (随机 IO：10 ms/ page，顺序 IO：0.1ms / page)，可见顺序 IO 性能之高，索引带来的性能提升显而易见！</p>\n<h2 id=\"索引的种类\"><a href=\"#索引的种类\" class=\"headerlink\" title=\"索引的种类\"></a>索引的种类</h2><p>索引主要分为以下几类：</p>\n<ul>\n<li><p>B+树索引</p>\n</li>\n<li><p>哈希索引</p>\n</li>\n</ul>\n<h3 id=\"B-树索引\"><a href=\"#B-树索引\" class=\"headerlink\" title=\"B+树索引\"></a>B+树索引</h3><p>B+ 树索引如下图所示：</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/24/UX2Uk6.png\" alt=\"UX2Uk6.png\"></p>\n<p>B+ 树是以 N 叉树的形式存在的，这样有效降低了树的高度，查找数据也不需要全表扫描了，顺着根节点层层往下查找能很快地找到我们的目标数据，每个节点的大小即一个磁盘块的大小，一次 IO 会将一个页（每页包含多个磁盘块）的数据都读入（即磁盘预读，程序局部性原理：读到了某个值，很大可能这个值周围的数据也会被用到，干脆一起读入内存），叶子节点通过指针的相互指向连接，能有效减少顺序遍历时的随机 IO，而且我们也可以看到，叶子节点都是按索引的顺序排序好的，这也意味着根据索引查找或排序都是排序好了的，不会再在内存中形成临时表。</p>\n<h3 id=\"哈希索引\"><a href=\"#哈希索引\" class=\"headerlink\" title=\"哈希索引\"></a>哈希索引</h3><p>哈希索引基本散列表实现，散列表（也称哈希表）是根据关键码值(Key value)而直接进行访问的数据结构，它让码值经过哈希函数的转换映射到散列表对应的位置上，查找效率非常高。假设我们对名字建立了哈希索引，则查找过程如下图所示：</p>\n<p><img src=\"https://s1.ax1x.com/2020/07/24/UX260I.png\" alt=\"UX260I.png\"></p>\n<p>对于每一行数据，存储引擎都会对所有的索引列（上图中的 name 列）计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引查找速度非常快！</p>\n<p>当然了，哈希表的劣势也是比较明显的，不支持区间查找，不支持排序，所以更多的时候哈希表是与 B Tree等一起使用的。在 InnoDB 引擎中就有一种名为「自适应哈希索引」的特殊索引，当 innoDB 注意到某些索引值使用非常频繁时，就会在内存中基于 B-Tree 索引之上再创建哈希索引，这样也就让 B+ 树索引也有了哈希索引的快速查找等优点，这是完全自动的内部的行为，用户无法控制或配置，不过如果有必要，可以关闭该功能。</p>\n<p>innoDB 引擎本身是不支持显式创建哈希索引的，我们可以在 B+ 树的基础上创建一个伪哈希索引，它与真正的哈希索引不是一回事，它是以哈希值而非键本身来进行索引查找的，这种伪哈希索引的使用场景是怎样的呢？假设我们在 db 某张表中有个 url 字段，我们知道每个 url 的长度都很长，如果以 url 这个字段创建索引，无疑要占用很大的存储空间，如果能通过哈希（比如CRC32）把此 url 映射成 4 个字节，再以此哈希值作索引 ，索引占用无疑大大缩短！不过在查询的时候要记得同时带上 url 和 url_crc，主要是为了避免哈希冲突，导致 url_crc 的值可能一样：</p>\n<p><code>SELECT id FROM url WHERE url = &quot;http://www.baidu.com&quot;  AND url_crc = CRC32(&quot;http://www.baidu.com&quot;)</code></p>\n<p>这样做把基于 url 的字符串索引改成了基于 url_crc 的整型索引，效率更高，同时索引占用的空间也大大减少，一举两得，当然有人可能会说需要手动维护索引太麻烦了，那可以改进触发器实现。</p>\n<p>除了上文说的两个索引 ，还有空间索引（R-Tree），全文索引等，由于生产中不是很常用，这里不作过多阐述。</p>\n<h2 id=\"高性能索引策略\"><a href=\"#高性能索引策略\" class=\"headerlink\" title=\"高性能索引策略\"></a>高性能索引策略</h2><p>不同的索引设计选择能对性能产生很大的影响，有人可能会发现生产中明明加了索引却不生效，有时候加了虽然生效但对搜索性能并没有提升多少，对于多列联合索引，哪列在前，哪列在后也是有讲究的，我们一起来看看。</p>\n<h3 id=\"加了索引，为何却不生效\"><a href=\"#加了索引，为何却不生效\" class=\"headerlink\" title=\"加了索引，为何却不生效\"></a>加了索引，为何却不生效</h3><p>加了索引却不生效可能会有以下几种原因。</p>\n<p>1、索引列是表示式的一部分，或是函数的一部分。</p>\n<p>如下 SQL：</p>\n<p><code>SELECT book_id FROM BOOK WHERE book_id + 1 = 5;</code></p>\n<p>或者</p>\n<p><code>SELECT book_id FROM BOOK WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(gmt_create) &lt;= 10</code></p>\n<p>上述两个 SQL 虽然在列 book_id 和 gmt_create 设置了索引 ，但由于它们是表达式或函数的一部分，导致索引无法生效，最终导致全表扫描。</p>\n<p>2、隐式类型转换</p>\n<p>以上两种情况相信不少人都知道索引不能生效，但下面这种隐式类型转换估计会让不少人栽跟头，来看下面这个例子。</p>\n<p>假设有以下表:</p>\n<p><code>CREATE TABLE `tradelog` (  \n  `id` int(11) NOT NULL,  \n  `tradeid` varchar(32) DEFAULT NULL,  \n  `operator` int(11) DEFAULT NULL,  \n  `t_modified` datetime DEFAULT NULL,  \n   PRIMARY KEY (`id`),  \n   KEY `tradeid` (`tradeid`),  \n   KEY `t_modified` (`t_modified`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</code></p>\n<p>执行 SQL 语句：</p>\n<p><code>SELECT * FROM tradelog WHERE tradeid=110717;</code></p>\n<p>交易编号 tradeid 上有索引，但用 EXPLAIN 执行却发现使用了全表扫描，为啥呢，tradeid 的类型是 varchar(32)，而此 SQL 用 tradeid 一个数字类型进行比较，发生了隐形转换，会隐式地将字符串转成整型，如下:</p>\n<p><code>mysql&gt; SELECT * FROM tradelog WHERE CAST(tradid AS signed int) = 110717;</code></p>\n<p>这样也就触发了上文中第一条的规则 ，即：索引列不能是函数的一部分。</p>\n<p>3、隐式编码转换</p>\n<p>这种情况非常隐蔽，来看下面这个例子。</p>\n<p><code>CREATE TABLE `trade_detail` (   \n `id` int(11) NOT NULL,   \n `tradeid` varchar(32) DEFAULT NULL,   \n `trade_step` int(11) DEFAULT NULL, /*操作步骤*/   \n `step_info` varchar(32) DEFAULT NULL, /*步骤信息*/   \n   PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`)  \n) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></p>\n<p>trade_detail 是交易详情， tradelog 是操作此交易详情的记录，现在要查询 id=2 的交易的所有操作步骤信息，则我们会采用如下方式：</p>\n<p><code>SELECT d.* FROM tradelog l, trade_detail d WHERE d.tradeid=l.tradeid AND l.id=2;</code></p>\n<p>由于 tradelog 与 trade_detail 这两个表的字符集不同，且 tradelog 的字符集是 utf8mb4，而 trade_detail 字符集是 utf8，utf8mb4 是 utf8 的超集，所以会自动将 utf8 转成 utf8mb4。即上述语句会发生如下转换：</p>\n<p><code>SELECT d.* FROM tradelog l, trade_detail d WHERE (CONVERT(d.traideid USING utf8mb4)))=l.tradeid AND l.id=2;</code></p>\n<p>自然也就触发了 「索引列不能是函数的一部分」这条规则。怎么解决呢？第一种方案当然是把两个表的字符集改成一样，如果业务量比较大，生产上不方便改的话，还有一种方案是把 utf8mb4 转成 utf8，如下：</p>\n<p><code>mysql&gt; SELECT d.* FROM tradelog l , trade_detail d WHERE d.tradeid=CONVERT(l.tradeid USING utf8) AND l.id=2;</code> </p>\n<p>这样索引列就生效了。</p>\n<p>4、使用 order by 造成的全表扫描</p>\n<p><code>SELECT * FROM user ORDER BY age DESC</code></p>\n<p>上述语句在 age 上加了索引，但依然造成了全表扫描，这是因为我们使用了 SELECT * 导致回表查询，MySQL 认为回表的代价比全表扫描更大，所以不选择使用索引，如果想使用到 age 的索引，我们可以用覆盖索引来代替：</p>\n<p><code>SELECT age FROM user ORDER BY age DESC</code></p>\n<p>或者加上 limit 的条件（数据比较小）：</p>\n<p><code>SELECT * FROM user ORDER BY age DESC limit 10</code></p>\n<p>这样就能利用到索引。</p>\n<h3 id=\"无法避免对索引列使用函数，怎么使用索引\"><a href=\"#无法避免对索引列使用函数，怎么使用索引\" class=\"headerlink\" title=\"无法避免对索引列使用函数，怎么使用索引\"></a>无法避免对索引列使用函数，怎么使用索引</h3><p>有时候我们无法避免对索引列使用函数，但这样做会导致全表索引，是否有更好的方式呢。</p>\n<p>比如我现在就是想记录 2016 ~ 2018 所有年份 7月份的交易记录总数：</p>\n<p><code>mysql&gt; SELECT count(*) FROM tradelog WHERE month(t_modified)=7;</code></p>\n<p>由于索引列是函数的参数，所以显然无法用到索引，我们可以将它改造成基本字段区间的查找如下：</p>\n<p><code>SELECT count(*) FROM tradelog WHERE  \n    -&gt; (t_modified &gt;= &#39;2016-7-1&#39; AND t_modified&lt;&#39;2016-8-1&#39;) or  \n    -&gt; (t_modified &gt;= &#39;2017-7-1&#39; AND t_modified&lt;&#39;2017-8-1&#39;) or   \n    -&gt; (t_modified &gt;= &#39;2018-7-1&#39; AND t_modified&lt;&#39;2018-8-1&#39;);</code></p>\n<h3 id=\"前缀索引与索引选择性\"><a href=\"#前缀索引与索引选择性\" class=\"headerlink\" title=\"前缀索引与索引选择性\"></a>前缀索引与索引选择性</h3><p>之前我们说过，如于长字符串的字段（如 url），我们可以用伪哈希索引的形式来创建索引，以避免索引变得既大又慢，除此之外其实还可以用前缀索引（字符串的部分字符）的形式来达到我们的目的，那么这个前缀索引应该如何选取呢，这就涉及到一个叫索引选择性的概念。</p>\n<blockquote>\n<p>索引选择性：不重复的索引值（也称为基数，cardinality）和数据表的记录总数的比值，比值越高，代表索引的选择性越好，唯一索引的选择性是最好的，比值是 1。</p>\n</blockquote>\n<p>画外音：我们可以通过  <strong>SHOW INDEXES FROM table</strong>  来查看每个索引 cardinality 的值以评估索引设计的合理性。</p>\n<p>怎么选择这个比例呢，我们可以分别取前 3，4，5，6，7 的前缀索引，然后再比较下选择这几个前缀索引的选择性，执行以下语句：</p>\n<p><code>SELECT   \n COUNT(DISTINCT LEFT(city,3))/COUNT(*) as sel3,  \n COUNT(DISTINCT LEFT(city,4))/COUNT(*) as sel4,  \n COUNT(DISTINCT LEFT(city,5))/COUNT(*) as sel5,  \n COUNT(DISTINCT LEFT(city,6))/COUNT(*) as sel6,  \n COUNT(DISTINCT LEFT(city,7))/COUNT(*) as sel7  \nFROM city_demo</code></p>\n<p>得结果如下：</p>\n<p>sel3</p>\n<p>sel4</p>\n<p>sel5</p>\n<p>sel6</p>\n<p>sel7</p>\n<p>0.0239</p>\n<p>0.0293</p>\n<p>0.0305</p>\n<p>0.0309</p>\n<p>0.0310</p>\n<p>可以看到当前缀长度为 7 时，索引选择性提升的比例已经很小了，也就是说应该选择 city 的前六个字符作为前缀索引，如下：</p>\n<p><code>ALTER TABLE city_demo ADD KEY(city(6))</code></p>\n<p>我们当前是以平均选择性为指标的，有时候这样是不够的，还得考虑最坏情况下的选择性，以这个 demo 为例，可能一些人看到选择 4，5 的前缀索引与选择 6，7 的选择性相差不大，那就得看下选择 4，5 的前缀索引分布是否均匀了：</p>\n<p><code>SELECT   \n    COUNT(*) AS  cnt,   \n    LEFT(city, 4) AS pref  \n  FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 5</code></p>\n<p>可能会出现以下结果：</p>\n<p>cnt</p>\n<p>pref</p>\n<p>305</p>\n<p>Sant</p>\n<p>200</p>\n<p>Toul</p>\n<p>90</p>\n<p>Chic</p>\n<p>20</p>\n<p>Chan</p>\n<p>可以看到分布极不均匀，以 Sant，Toul 为前缀索引的数量极多，这两者的选择性都不是很理想，所以要选择前缀索引时也要考虑最差的选择性的情况。</p>\n<p>前缀索引虽然能实现索引占用空间小且快的效果，但它也有明显的弱点，MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY ，而且也无法使用前缀索引做覆盖扫描，前缀索引也有可能增加扫描行数。</p>\n<p>假设有以下表数据及要执行的 SQL：</p>\n<p>id</p>\n<p>email</p>\n<p>1</p>\n<p><a href=\"mailto:zhangssxyz@163.com\" target=\"_blank\" rel=\"noopener\">zhangssxyz@163.com</a></p>\n<p>2</p>\n<p><a href=\"mailto:zhangs1@163.com\" target=\"_blank\" rel=\"noopener\">zhangs1@163.com</a></p>\n<p>3</p>\n<p><a href=\"mailto:zhangs1@163.com\" target=\"_blank\" rel=\"noopener\">zhangs1@163.com</a></p>\n<p>4</p>\n<p><a href=\"mailto:zhangs1@163.com\" target=\"_blank\" rel=\"noopener\">zhangs1@163.com</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT id,email FROM user WHERE email=&apos;zhangssxyz@xxx.com&apos;;</span><br></pre></td></tr></table></figure>\n<p>如果我们针对 email 设置的是整个字段的索引，则上表中根据 「<a href=\"mailto:zhangssxyz@163.com\" target=\"_blank\" rel=\"noopener\">zhangssxyz@163.com</a>」查询到相关记记录后，再查询此记录的下一条记录，发现没有，停止扫描，此时可知<strong>只扫描一行记录</strong>，如果我们以前六个字符（即 email(6)）作为前缀索引，则显然要扫描四行记录，并且获得行记录后不得不回到主键索引再判断 email 字段的值，所以使用前缀索引要评估它带来的这些开销。</p>\n<p>另外有一种情况我们可能需要考虑一下，如果前缀基本都是相同的该怎么办，比如现在我们为某市的市民建立一个人口信息表，则这个市人口的身份证虽然不同，但身份证前面的几位数都是相同的，这种情况该怎么建立前缀索引呢。</p>\n<p>一种方式就是我们上文说的，针对身份证建立哈希索引，另一种方式比较巧妙，将身份证倒序存储，查的时候可以按如下方式查询:</p>\n<p><code>SELECT field_list FROM t WHERE id_card = reverse(&#39;input_id_card_string&#39;);</code></p>\n<p>这样就可以用身份证的后六位作前缀索引了，是不是很巧妙 ^_^</p>\n<p>实际上上文所述的索引选择性同样适用于联合索引的设计，如果没有特殊情况，我们一般建议在建立联合索引时，把选择性最高的列放在最前面，比如，对于以下语句：</p>\n<p><code>SELECT * FROM payment WHERE staff_id = xxx AND customer_id = xxx;</code></p>\n<p>单就这个语句而言， (staff_id，customer_id) 和 (customer_id，staff_id) 这两个联合索引我们应该建哪一个呢，可以统计下这两者的选择性。</p>\n<p><code>SELECT   \n COUNT(DISTINCT staff_id)/COUNT(*) as staff_id_selectivity,  \n COUNT(DISTINCT customer_id)/COUNT(*) as customer_id_selectivity,  \n COUNT(*)  \nFROM payment</code></p>\n<p>结果为：</p>\n<p><code>staff_id_selectivity: 0.0001  \ncustomer_id_selectivity: 0.0373  \nCOUNT(*): 16049</code></p>\n<p>从中可以看出 customer_id 的选择性更高，所以应该选择 customer_id 作为第一列。</p>\n<h2 id=\"索引设计准则：三星索引\"><a href=\"#索引设计准则：三星索引\" class=\"headerlink\" title=\"索引设计准则：三星索引\"></a>索引设计准则：三星索引</h2><p>上文我们得出了一个索引列顺序的经验法则：将选择性最高的列放在索引的最前列，这种建立在某些场景可能有用，但通常不如避免随机 IO 和排序那么重要，这里引入索引设计中非常著名的一个准则：三星索引。</p>\n<p>如果一个查询满足三星索引中三颗星的所有索引条件，<strong>理论上</strong>可以认为我们设计的索引是最好的索引。什么是三星索引：</p>\n<ol>\n<li><p>第一颗星：WHERE 后面参与查询的列可以组成单列索引或联合索引。</p>\n</li>\n<li><p>第二颗星：避免排序，即如果 SQL 语句中出现 order by colulmn，那么取出的结果集就已经是按照 column 排序好的，不需要再生成临时表。</p>\n</li>\n<li><p>第三颗星：SELECT 对应的列应该尽量是索引列，即尽量避免回表查询。</p>\n</li>\n</ol>\n<p>所以对于如下语句:</p>\n<p><code>SELECT age, name, city where age = xxx and name = xxx order by age</code></p>\n<p>设计的索引应该是 (age, name,city) 或者 (name, age,city)</p>\n<p>当然了，三星索引是一个比较理想化的标准，实际操作往往只能满足期望中的一颗或两颗星，考虑如下语句:</p>\n<p><code>SELECT age, name, city where age &gt;= 10 AND age &lt;= 20 and city = xxx order by name desc</code></p>\n<p>假设我们分别为这三列建了联合索引，则显然它符合第三颗星（使用了覆盖索引），如果索引是（city, age, name)，则虽然满足了第一颗星，但排序无法用到索引，不满足第二颗星，如果索引是 (city, name, age)，则第二颗星满足了，但此时 age 在 WHERE 中的搜索条件又无法满足第一星。</p>\n<p>另外第三颗星（尽量使用覆盖索引）也无法完全满足，试想我要 SELECT 多列，要把这多列都设置为联合索引吗，这对索引的维护是个问题，因为每一次表的 CURD 都伴随着索引的更新，很可能频繁伴随着页分裂与页合并。</p>\n<p>综上所述，三星索引只是给我们构建索引提供了一个参考，索引设计应该尽量靠近三星索引的标准，但实际场景我们一般无法同时满足三星索引，一般我们会优先选择满足第三颗星（因为回表代价较大）至于第一，二颗星就要依赖于实际的成本及实际的业务场景考虑。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简述了索引的基本原理，索引的几种类型，以及分析了一下设计索引尽量应该遵循的一些准则，相信我们对索引的理解又更深了一步。另外强烈建议大家去学习一下附录中的几本书。文中的挺多例子都是在文末的参考资料中总结出来的，读经典书籍，相信大家会受益匪浅！</p>\n<p><strong>巨人的肩膀</strong></p>\n<p>《高性能 MySQL》</p>\n<p>《Relational Database index design and the optimizers》</p>\n<p>《MySQL实战45讲》<a href=\"https://time.geekbang.org/column/article/71492\" target=\"_blank\" rel=\"noopener\">https://time.geekbang.org/column/article/71492</a></p>\n","categories":["数据库"],"tags":["索引"]}]