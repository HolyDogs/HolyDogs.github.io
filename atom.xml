<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XFF&#39;s blog</title>
  
  <subtitle>BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xfff.xyz/"/>
  <updated>2019-01-02T02:03:13.228Z</updated>
  <id>http://xfff.xyz/</id>
  
  <author>
    <name>XFF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Messenger通关</title>
    <link href="http://xfff.xyz/2019/01/02/The-Messenger%E9%80%9A%E5%85%B3/"/>
    <id>http://xfff.xyz/2019/01/02/The-Messenger通关/</id>
    <published>2019-01-02T01:02:26.000Z</published>
    <updated>2019-01-02T02:03:13.228Z</updated>
    
    <content type="html"><![CDATA[<p>元旦通关了一款2018年出的解密复古风小游戏，感觉还蛮有意思的。<br>《The Messenger》中译叫信使。</p><p>游戏中会记录死亡数。</p><p>有只恶魔在旁边负责复活你，复活之后会把你吃的碎片（类似金币）给吞掉。并且，每死一次都要嘲讽你，特别烦人啊hhh</p><p>然后，后期来了一个叫堕落的未来的地方，遇到一直巨大的怪，bgm全变了，感觉有点恐怖。这个时候你死了，恶魔也不说话了，直接默默把你复活，感觉设计的还是很有意思。</p><p>就是下面这个东西。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fyrzpn1xzvj311y0lcqau.jpg" alt=""></p><p>就在我截图出来后回去，发现居然出bug了，大怪兽不知道为什么不追我了， 然后</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys07btpkhj311y0lcwmj.jpg" alt=""></p><p>调戏一下</p><p>要不是这个bug，我可能又要多死几十次</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys08upvhqj311y0lcgr7.jpg" alt=""></p><p>八音盒解锁</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys09oh8gyj311y0lctdj.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0a79ckmj311y0lcdks.jpg" alt=""></p><p>场景设计的很有意思</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0atb7ovj311y0lcnau.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0b5vij7j311y0lc0z7.jpg" alt=""></p><p>死了400+次总算是通关了。</p><p>最难拿的一个封印</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys0c3502xj311y0lcdh6.jpg" alt=""></p><p>辛辛苦苦拿了四十几个封印，居然只是解锁一个回旋镖，这个做的太伤人心了叭！</p><hr><hr><p>通关还是蛮有成就感的233</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;元旦通关了一款2018年出的解密复古风小游戏，感觉还蛮有意思的。&lt;br&gt;《The Messenger》中译叫信使。&lt;/p&gt;
&lt;p&gt;游戏中会记录死亡数。&lt;/p&gt;
&lt;p&gt;有只恶魔在旁边负责复活你，复活之后会把你吃的碎片（类似金币）给吞掉。并且，每死一次都要嘲讽你，特别烦人啊hh
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记，游戏" scheme="http://xfff.xyz/tags/%E6%9D%82%E8%AE%B0%EF%BC%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux&amp;shell学习</title>
    <link href="http://xfff.xyz/2018/12/27/linux-shell%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xfff.xyz/2018/12/27/linux-shell学习/</id>
    <published>2018-12-27T01:18:08.000Z</published>
    <updated>2018-12-27T01:26:26.107Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1m3hagrj321c10w1ca.jpg" alt=""></p><hr><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mmoq4jj32cg168nld.jpg" alt=""></p><hr><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mw2ld7j321c10wwyg.jpg" alt=""></p><p>….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sly1fyl1m3hagrj321c10w1ca.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006
      
    
    </summary>
    
      <category term="linux" scheme="http://xfff.xyz/categories/linux/"/>
    
    
      <category term="linux" scheme="http://xfff.xyz/tags/linux/"/>
    
      <category term="shell" scheme="http://xfff.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记2</title>
    <link href="http://xfff.xyz/2018/12/25/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://xfff.xyz/2018/12/25/Oracle学习笔记2/</id>
    <published>2018-12-25T05:13:32.000Z</published>
    <updated>2018-12-26T02:36:30.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDL（database-define-language）数据库定义语言"><a href="#DDL（database-define-language）数据库定义语言" class="headerlink" title="DDL（database define language）数据库定义语言"></a>DDL（database define language）数据库定义语言</h2><p>创建表：create table tablename（….）</p><p>修改表：alter table tablename add（columnname type …）;<br>alter table tablename modify …</p><p>删除表：drop table tablename</p><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>主键Primary key</li><li>非空约束NOT NULL</li><li>唯一约束Unique</li><li>外键约束foreign key</li><li>检查性约束check（加在列后写上对列条件）</li></ul><hr><h2 id="DML（database-manager-language）数据库操作语言"><a href="#DML（database-manager-language）数据库操作语言" class="headerlink" title="DML（database manager language）数据库操作语言"></a>DML（database manager language）数据库操作语言</h2><p>INSERT INTO TABLENAME() VALUES()</p><p>UPDATE TABLENAME SET COLUMN=VALUE… WHERE 条件</p><p>DELETE FROM TABLENAME WHERE 条件</p><hr><h2 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h2><p>简化复杂的查询，查询部分数据作为一个视图<br>create view view_name as (查询语句)<br>create or replace view view_name as ….</p><hr><h2 id="序列SEQUENCE"><a href="#序列SEQUENCE" class="headerlink" title="序列SEQUENCE"></a>序列SEQUENCE</h2><p>若想和mysql等数据库一样实现某列自动增长的功能，可以利用序列</p><p>其中有两个变量：<br>nextval：取得序列的下一个内容<br>currval：取得序列的当前内容<br>先创建序列：<br>CREATE SEQUENCE SEQUENCENAME<br>                                     INCREMENT BY 10<br>                                    START WITH 120<br>                                    MAXVALUE 9999<br>                                    NOCACHE<br>                                    NOCYCLE;</p><p>自增这样写：insert into tablename values(列名.nextval….)</p><h2 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h2><p>单列索引：<br>create index indexname on tablename(columnname)</p><p>复合索引<br>create index indexname on tablename(…)</p><p>当数据量较大的时候，索引能加快查询速度。</p><h2 id="同义词SYNONYM"><a href="#同义词SYNONYM" class="headerlink" title="同义词SYNONYM"></a>同义词SYNONYM</h2><p>CREATE PUBLIC SYNONYM synonymname for othertable.emp</p><hr><h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><p>declare<br>这里写一些说明（变量定义什么的。。。）<br>begin<br>代码部分，语句序列，DML<br>exception<br>例外语句，类似异常处理<br>End;</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvio5aq1j30ev09dt9p.jpg" alt=""></p><p><strong>选择</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvj6bwbgj309u0ant9h.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvji4pvvj30e4064q3j.jpg" alt=""><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvjw7525j30hy07tmyb.jpg" alt=""></p><p><strong>循环</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvk97rujj30bt0frwg5.jpg" alt=""></p><hr><h2 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvr2tozmj30gd05edhp.jpg" alt=""><br>使用</p><p>例：</p><pre><code>declare    //声明部分    cursor cl is  //声明游标        select * from emp;  //游标指向    pemp emp%rowtype;    //声明变量，类型为emp表begin      open cl;    //打开游标        loop                fetch cl    //取一行游标的值                into pemp;    //放入pemp变量中            exit when cl%notfound;    //当游标为空的时候跳出循环            dbms_output.put_line(pemp.empno || &apos; &apos; || pemp.ename);    //打印变量所指行的信息        end loop    close cl    //关闭游标end; </code></pre><p>也可以指定游标的类型为特定的某一行<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjw17a91wj30f801imxv.jpg" alt=""></p><hr><h2 id="例外exception"><a href="#例外exception" class="headerlink" title="例外exception"></a>例外exception</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjw41x9ltj30a103s3yz.jpg" alt=""></p><p>类似与java，也可以自己手动抛出异常。</p><p>自定义异常需要在declare中定义，然后使用时可以加入条件控制中，如果不正确可以抛出（raise）一个异常，然后进入exception块中</p><pre><code>exception     when   自定义异常名   then         处理语句</code></pre><hr><h2 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwafrjz7j30de08gaav.jpg" alt=""><br>在AS或者IS后可以加变量定义。<br>调用<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwifmffyj309f04hmxo.jpg" alt=""></p><h2 id="存储函数function"><a href="#存储函数function" class="headerlink" title="存储函数function"></a>存储函数function</h2><p>存储函数和存储过程一般来说没有什么区别，返回结果的数量可以通过参数里的<strong>out</strong>指定</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwpj3k0kj30gp04iwf7.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwu2zddoj30b1013aa1.jpg" alt=""></p><pre><code>create or replace function  empincome (eno in emp.empno%type) return number is  //声明存储过程    psal emp.sal%type;  //定义薪水变量    pcomm emp.comm%type;  //定义奖金变量begin    select t.sal,t.pcomm into psal,pcomm from emp t where t.empno=eno;    return psal*12+nvl(pcomm,0);end</code></pre><p>用存储过程实现<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx0o7by5j30i60bvadt.jpg" alt=""></p><hr><h2 id="java调用存储过程"><a href="#java调用存储过程" class="headerlink" title="java调用存储过程"></a>java调用存储过程</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx2q44rzj30ga0bk415.jpg" alt=""></p><p>若使用游标<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx6rz4flj30g305rq4e.jpg" alt=""><br>只需要将游标提取，然后用ResultSet类型转换即可查询游标所指内容</p><p>另外，写在过程中out语句后的用来返回结果集的游标类型应该为sys_refcursor，具体可以查看</p><blockquote><p><a href="https://www.cnblogs.com/liuqiyun/p/6796740.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuqiyun/p/6796740.html</a></p></blockquote><hr><h2 id="触发器TRIGGER"><a href="#触发器TRIGGER" class="headerlink" title="触发器TRIGGER"></a>触发器TRIGGER</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxr3dooij309p06674r.jpg" alt=""></p><p>触发器自带变量<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxsqbtsuj30hx047t9o.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxyacxucj30fv0dkju9.jpg" alt=""></p><p>另外一般不允许多个触发器对同一张表进行操作或者在触发器中对同一张表进行操作，容易产生递归循环触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DDL（database-define-language）数据库定义语言&quot;&gt;&lt;a href=&quot;#DDL（database-define-language）数据库定义语言&quot; class=&quot;headerlink&quot; title=&quot;DDL（database define 
      
    
    </summary>
    
      <category term="Oracle" scheme="http://xfff.xyz/categories/Oracle/"/>
    
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="oracle" scheme="http://xfff.xyz/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记1</title>
    <link href="http://xfff.xyz/2018/12/23/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://xfff.xyz/2018/12/23/Oracle学习笔记1/</id>
    <published>2018-12-23T04:34:45.000Z</published>
    <updated>2018-12-23T13:53:44.124Z</updated>
    
    <content type="html"><![CDATA[<p><em>Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。</em></p><ul><li><a href="#a">01基础</a></li><li><a href="#b">02多表查询、子查询</a></li></ul><hr><p><span id="a"></span></p><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p>Oracle中distinct可以消除重复的行，如果指定多个列名，则要保证多列的数据皆重复才会消除。</p><pre><code>select distinct name,sal from emp</code></pre><hr><p>Oracle中有独特的字符串连接符’<strong>||</strong>‘，相当于java里的’+’,MYSQL里可以用concat连接字符串。</p><pre><code>select &apos;姓名是:&apos; || NAME || &apos;的年龄为&apos; || AGE from emp;select concat(NAME,&apos;是姓名&apos;，AGE，&apos;是年龄&apos;    ) from emp;</code></pre><hr><p>查询列取别名时，若别名中有特殊字符或者关键字需要加上双引号。(其他地方大部分使用单引号）</p><pre><code>select name &quot;my name&quot; from emp;</code></pre><hr><p>LIKE关键字使用时，若匹配的字符里有特殊字符，需要使用escape关键字<br>如，要查询员工姓名里有’%’字符的员工信息。</p><pre><code>select * from emp where name like &apos;%\%%&apos; escape &apos;\&apos;;</code></pre><p>其中第一和最后一个%号都表示任意字符，而escape声明’\‘为转义字符，所以第二个%表示字符’%’。<br>也可以这样写:</p><pre><code>select * from emp where name like &apos;%#%%&apos; escape &apos;#&apos;;</code></pre><p>所以我猜想在oracle里反斜杠并不代表转义字符的意思吧。。</p><hr><p>在排序的时候，如果有空值，需要在末尾加上null的说明</p><pre><code>select * from emp order by number desc nulls last;</code></pre><p>表示null值放在末尾，还有nulls first.</p><hr><p>oracle里有一个伪表用来做返回字符或者数值，叫做<strong>dual</strong>，在MYSQL中不用加from dual；</p><p>同样的，oracle里也有很多一样的函数</p><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><ul><li><p>concat():    字符串连接</p><pre><code>select concat(&apos;hello&apos;,&apos;world&apos;) from dual;</code></pre></li><li>substr():字符串的截取substr(str,0,3)表示从索引位置0（<strong>0和1效果相同</strong>）开始截取str，截取3个字符的长度。</li><li>length()：获取字符串长度    </li><li>replace()：replace(str,’a’,’b’)表示把str里所有的a替换成b</li><li>round()：四舍五入round(num,2)，2表示保留2位小数0</li><li>ceil()：进1取整</li><li>trunc()：截断trunc(num,2)去掉小数点后2位的尾数</li><li>MOD()：求余MOD(NUM1,NUM2)</li><li>MONTHS_BETWEEN()：获得两个时间段中的月数，months_between(sysdate,finishdate)——<strong>sysdate</strong>表示系统时间</li><li>ADD_MONTHS()：获取几个月后的日期，add_months(sysdate,3)系统时间3个月后。</li><li>TO_CHAR：字符串转换函数</li><li>TO_NUMBER：数值转换函数</li><li>TO_DATE：日期转换函数<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fygwfj010wj30h407sjt2.jpg" alt=""><br>如：<br>TO_CHAR(date,’yyyy-mm-dd’)<br>TO_CHAR(date,’yyyy’)等<br>把月和日前面的0去掉要在后面的model前加上fm<br>TO_CHAR(date,’fmyyyy-mm-dd’)<br>TO_CHAR(sysdate,’d’)一个d代表一个星期的第几天，两个d代表一个月的第几天，三个d代表一年中的第几天<br>TO_CHAR(sysdate,’day’)星期几–返回monday什么的，如果是dy，则返回简写–mon之类的</li></ul><p>也就是这三种类型的相互转换函数<br>TO_CHAR(sal,’L9,999.99’),可以格式化货币，L表示本地货币</p><ul><li>NVL()：空值处理，如果为空值就取后面的值为默认值，nvl(name,’Peter’)</li><li>NVL2()：nvl2(参数1，参数2，参数3)，如果参数1为空值，就返回参数3，否则返回参数2</li><li>nullif()：nullif(参数1，参数2)如果参数1等于参数2，那么就返回null，否则返回参数1</li><li>coalesce()：这个函数传入很多参数，然后返回第一个不为null的值</li></ul><hr><p>条件表达式：在SQL语句中使用IF-THEN-ELSE</p><p><strong>CASE</strong>表达式：SQL99的语法，类似Basic，比较繁琐</p><pre><code>select    case name        when &apos;Peter&apos; then &apos;P&apos;        when &apos;Bob&apos; then &apos;B&apos;        else             &apos;C&apos;        endfrom emp;</code></pre><p>就是当name等于when里的值就改为then后面的值，这种写法通用于MYSQL和Oracle</p><p><strong>DECODE</strong>函数：Oracle自己的语法，类似java，比较简洁</p><pre><code>select decode(name,&apos;Peter&apos;,&apos;P&apos;,&apos;Bob&apos;,&apos;B&apos;,&apos;C&apos;) from emp;</code></pre><p>效果和上面一样</p><hr><h2 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h2><ul><li>max()：某列最大值</li><li>min()：某列最小值</li><li>count()：统计行数</li><li>avg()：平均数，注意空值影响</li><li>sum()：求和<br>多行函数常与分组关键字Group by配合使用，另外having关键字在group by后执行，where后不能接多行函数。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fygz2iqixhj30kg02yjtb.jpg" alt=""></li></ul><p>就是说只能这样写</p><pre><code>select 列名a，分组函数 from 表 group by 这个列名a having 条件</code></pre><hr><p><span id="b"></span></p><h2 id="多表查询、子查询"><a href="#多表查询、子查询" class="headerlink" title="多表查询、子查询"></a>多表查询、子查询</h2><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>内外连接我在前面sql写过了，就写一些oracle不同的地方</p><p>全外连接为俩表都完全匹配。不加where条件即为外连接</p><p>内连接，加where条件</p><p>左（外）连接<br>显示左边表的全部，匹配右边的表<br>select e.empno,e.ename,m.empno,m.ename from emp e,emp m where e.mgr=m.empno(+)<br>在右边加+号表示用该表匹配左表，故为左连接。</p><p>右连接反之。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>也就是在一个大的主查询里先做一个小的子查询供主查询使用。</p><p>例</p><pre><code>select name,job,sal from emp where sal=(select min(sal) from emp)</code></pre><p>子查询返回结果类型要和比较类型相同。</p><p>多行子查询<br>若子查询返回多行结果，应与多行比较符匹配：in、&gt;any….</p><p>子查询返回空值可能会报错，这个时候需要使用<strong>exists()</strong>，括号里加入子查询语句，若查询结果为空，返回false</p><pre><code>select * from emp where exists(select * from dept where deptno=1)</code></pre><p><strong>Rownum</strong><br>当要查询第几行到第几行的数据时，我们使用rownum。</p><p>rownum是oracle预处理字段，默认标序是1，只有记录集已经满足条件后才会进行后续编号。这样你查询表时遍历第一条数据时rownum是1，不符合条件，继续遍历到第二条数据rownum仍为1，仍不符合条件，直至遍历完所有数据，都无数据返回。</p><p>查询第二行之后的数据</p><pre><code>select * from(select rownum no ,id,name from student) where no&gt;2;</code></pre><p>rownum不能直接使用判断&gt;的条件。<br>另外，rownum是按照插入顺序排列的，所以要按某列排序需要使用子查询</p><pre><code>select rownum ,id,name from (select * from student order by name)</code></pre><p>查询第n行到m行的数据</p><pre><code>(select empno,ename from emp where rownum&lt;m)minus(select empno,ename from emp where rownum&lt;n)</code></pre><hr><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>就是俩条语句的结果集的运算<br>有</p><ul><li>UNION并集</li><li>intersect交集</li><li>minus差集</li></ul><p>特征：<br>两边查询的字段数量、字段类型、顺序必须一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#a&quot;&gt;01基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#b&quot;
      
    
    </summary>
    
      <category term="Oracle" scheme="http://xfff.xyz/categories/Oracle/"/>
    
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="oracle" scheme="http://xfff.xyz/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>工作第一天</title>
    <link href="http://xfff.xyz/2018/12/19/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://xfff.xyz/2018/12/19/工作第一天/</id>
    <published>2018-12-19T06:40:39.000Z</published>
    <updated>2018-12-19T06:54:02.786Z</updated>
    
    <content type="html"><![CDATA[<hr><p>经过大半个月的折腾，我找到了自己的第一份IT工作。</p><p>今天是第一天，负责带我的导师，出差了……</p><p>是的，没错，出差了。</p><p>干坐了一天，看看这个看看那个，刷刷这个刷刷那个，无聊呀…</p><p>说到无聊，我就想起了《西游记》里的无花果树。今年下半年…开拍…文体两开花…</p><p>咳咳，由于昨天一天的搬家折腾，晚上也没睡好，感冒（类似）鼻塞了，很难受，而且还很困，希望今晚能好好睡一觉，鼻塞快点好吧，明天也要元气满满。</p><p>这里就随便记一下皮一下—–</p><p>加油吧。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyc25phdx5j30xc0sqx6p.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;经过大半个月的折腾，我找到了自己的第一份IT工作。&lt;/p&gt;
&lt;p&gt;今天是第一天，负责带我的导师，出差了……&lt;/p&gt;
&lt;p&gt;是的，没错，出差了。&lt;/p&gt;
&lt;p&gt;干坐了一天，看看这个看看那个，刷刷这个刷刷那个，无聊呀…&lt;/p&gt;
&lt;p&gt;说到无聊，我就想起了《西游记》里的
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="日常生活" scheme="http://xfff.xyz/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>SQL一些基本语句使用</title>
    <link href="http://xfff.xyz/2018/11/29/SQL%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/11/29/SQL一些基本语句使用/</id>
    <published>2018-11-28T16:18:06.000Z</published>
    <updated>2018-11-28T16:26:50.363Z</updated>
    
    <content type="html"><![CDATA[<p>选出不重复的列<br>SELECT DISTINCT COLUMN FROM TABLE<br>用某列来进行排序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN<br>逆序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN DESC<br>选出开始几行<br>SELECT TOP NUMBER|PERCENT * FROM TABLE<br>MYSQL中用LIMIT关键字</p><hr><p>like关键字<br>Where column like ‘pattern’<br>_表示一位<br>%表示任何多位<br>[]表示方括号里的某一单一字符<br>[^]反向</p><hr><p>范围条件IN<br>Where column in （VALUES…）<br>BETWEEN…AND..<br>a&lt;x&lt;b</p><hr><p>内连接、左外连接、右外连接、全连接<br>Inner JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN</p><hr><p>创建索引</p><p><strong>CREATE INDEX 语句用于在表中创建索引。</strong></p><p><strong>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</strong></p><p>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引</p><p>CREATE INDEX index_name<br>ON table_name (column_name)</p><p>删除索引–MYSQL<br>ALTER TABLE table_name DROP INDEX index_name</p><p>删除表、数据库<br>DROP TABLE 表名称<br>DROP DATABASE 数据库名称</p><hr><p>创建视图</p><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p><p>注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响<br><a href="http://www.w3school.com.cn/sql/sql_view.asp" target="_blank" rel="noopener">CLICK</a></p><hr><p>关键字ALTER用于修改表以及行<br>ALTER TABLE table_name<br>ALTER COLUMN column_name datatype</p><hr><p>SQL函数<br>平均AVG()<br>例：希望找到 OrderPrice 值高于 OrderPrice 平均值的客户<br>SELECT Customer FROM Orders<br>WHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders)</p><p>计数COUNT()<br>SELECT COUNT(column_name) FROM table_name//括号里可加DISTINCT关键字</p><p>第一、最后一条记录<br>FIRST()、LAST()</p><p>最大值、最小值<br>MAX()、MIN()</p><p>计和<br>SUM()</p><p>按列分项算总和<br>例SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer</p><p>计和增加条件用关键字HAVING</p><p>转大小写<br>UCASE()、LCASE()</p><p>MID() 函数<br>MID 函数用于从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name<br>例SELECT MID(City,1,3) as SmallCity FROM Persons</p><p>LEN()<br>LEN 函数返回文本字段中值的长度。</p><p>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name</p><p>NOW()<br>NOW 函数返回当前的日期和时间</p><p>FORMAT 函数用于对字段的显示进行格式化。<br>SELECT FORMAT(column_name,format) FROM table_name</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选出不重复的列&lt;br&gt;SELECT DISTINCT COLUMN FROM TABLE&lt;br&gt;用某列来进行排序&lt;br&gt;SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN&lt;br&gt;逆序&lt;br&gt;SELECT COLUMN FROM TABLE
      
    
    </summary>
    
      <category term="SQL" scheme="http://xfff.xyz/categories/SQL/"/>
    
    
      <category term="sql" scheme="http://xfff.xyz/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>比较器Comparator和Comparable的使用</title>
    <link href="http://xfff.xyz/2018/11/23/%E6%AF%94%E8%BE%83%E5%99%A8Comparator%E5%92%8CComparable%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/11/23/比较器Comparator和Comparable的使用/</id>
    <published>2018-11-23T08:45:52.000Z</published>
    <updated>2018-11-23T09:38:59.692Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要对一些数组和集合进行排序的时候，经常会用到Arrays.sort和Collections.sort方法。<br>但当sort里的数组或集合里的对象不适合用默认的比较方法时，我们就需要手动对排序方式重新定义。</p><hr><p>比如，现在定义一个Person对象：</p><pre><code>public class Person {    private int id;    private int age;    public Person(int id,int age) {        this.age=age;        this.id=id;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }        @Override    public String toString()         return &quot;Person&quot;+id+&quot;-&gt;age:&quot;+age;    }}</code></pre><p>现在我们要对一堆person集合进行按年龄从小到大的排序或者年龄和id的和的大小的排序，这个时候默认的方法就无法实现我们的要求。</p><hr><p>一般我们有两种方法来实现：</p><h2 id="1-实现Comparable接口"><a href="#1-实现Comparable接口" class="headerlink" title="1.实现Comparable接口"></a>1.实现Comparable接口</h2><p>让需要进行特殊排序的对象实现Comparable接口，并重写其中的compareTo方法</p><pre><code>public class Person implements Comparable&lt;Person&gt;</code></pre><p>compareTo中，如果想按从小到大的顺序排列，当符合小于规定时就返回-1。否则可以反向排序返回1。</p><pre><code>@Overridepublic int compareTo(Person o) {    if (age&lt;o.age) {        return -1;    }else {        return 1;    }}</code></pre><p>测试：</p><pre><code>public class ComparaTest {    public static void main(String[] args) {        List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();        aList.add(new Person(1,13));        aList.add(new Person(2, 42));        aList.add(new Person(3, 5));        aList.add(new Person(45, 32));        aList.add(new Person(42, 88));        aList.add(new Person(4, 5));        System.out.println(&quot;排序前:&quot;);        aList.stream().forEach(System.out::println);        Collections.sort(aList);        System.out.println(&quot;排序后:&quot;);        aList.stream().forEach(System.out::println);    }}</code></pre><p>输出</p><pre><code>排序前:Person1-&gt;age:13Person2-&gt;age:42Person3-&gt;age:5Person45-&gt;age:32Person42-&gt;age:88Person4-&gt;age:5排序后:Person3-&gt;age:5Person4-&gt;age:5Person1-&gt;age:13Person45-&gt;age:32Person2-&gt;age:42Person42-&gt;age:88</code></pre><h2 id="2-创建比较类继承Comparator"><a href="#2-创建比较类继承Comparator" class="headerlink" title="2.创建比较类继承Comparator"></a>2.创建比较类继承Comparator</h2><p>Comparator位于包java.util下，而Comparable位于包java.lang下。</p><p>创建一个比较类MyComparator：<br>这里我直接创建一个静态内部类用来比较，并定义为倒序</p><pre><code>static class MyComparator implements Comparator&lt;Person&gt;{    @Override    public int compare(Person o1, Person o2) {        if (o1.getAge()&lt;o2.getAge()) {            return 1;        }else {            return -1;        }    }}</code></pre><p>测试：</p><pre><code>public static void main(String[] args) {    List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();    aList.add(new Person(1,13));    aList.add(new Person(2, 42));    aList.add(new Person(3, 5));    aList.add(new Person(45, 32));    aList.add(new Person(42, 88));    aList.add(new Person(4, 5));    System.out.println(&quot;排序前:&quot;);    aList.stream().forEach(System.out::println);    Collections.sort(aList,new MyComparator());    System.out.println(&quot;排序后:&quot;);    aList.stream().forEach(System.out::println);}</code></pre><p>输出：</p><pre><code>排序前:Person1-&gt;age:13Person2-&gt;age:42Person3-&gt;age:5Person45-&gt;age:32Person42-&gt;age:88Person4-&gt;age:5排序后:Person42-&gt;age:88Person2-&gt;age:42Person45-&gt;age:32Person1-&gt;age:13Person4-&gt;age:5Person3-&gt;age:5</code></pre><hr><p>另外，在leetcode第23题有配合优先级队列使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们需要对一些数组和集合进行排序的时候，经常会用到Arrays.sort和Collections.sort方法。&lt;br&gt;但当sort里的数组或集合里的对象不适合用默认的比较方法时，我们就需要手动对排序方式重新定义。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;比如，现在定义一个Person对
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="比较器" scheme="http://xfff.xyz/tags/%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】笔记2</title>
    <link href="http://xfff.xyz/2018/11/08/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B02/"/>
    <id>http://xfff.xyz/2018/11/08/【leetcode】笔记2/</id>
    <published>2018-11-08T08:57:46.000Z</published>
    <updated>2018-11-08T10:43:10.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><p>Given  _n_  non-negative integers  _a1_,  _a2_, …,  _an_ , where each represents a point at coordinate (_i_,  _ai_).  _n_  vertical lines are drawn such that the two endpoints of line  _i_  is at (_i_,  _ai_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note:</strong> You may not slant the container and  _n_  is at least 2.</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fx0riuv5qxj30m90anq3j.jpg" alt=""></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public int maxArea(int[] height) {        if(height.length&lt;2)return 0;        int head=0,tail=height.length-1;        int max = 0;        while (head!=tail) {            if (height[head]&gt;height[tail]) {                if((tail-head)*height[tail]&gt;max) {                    max=(tail-head)*height[tail];                }                tail--;            }else {                if((tail-head)*height[head]&gt;max) {                    max=(tail-head)*height[head];                }                head++;            }        }        return max;    }}</code></pre><p>定义两个下标变量从两端往中间遍历，比较俩下标对应的高度，若想中间的面积更大，则只改变高度较低的那一端的下标值向中间靠拢，最后通过一个变量记录最大值即可。</p><hr><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><p>Given an array  <code>nums</code>  of  _n_  integers, are there elements  _a_,  _b_,  _c_  in  <code>nums</code>  such that  _a_  +  _b_  +  _c_  = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><p>Given array nums = [-1, 0, 1, 2, -1, -4],</p><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        if(nums.length&lt;3) return Arrays.asList();        List&lt;List&lt;Integer&gt;&gt; aList=new ArrayList&lt;&gt;();        Arrays.sort(nums);        for(int i=0;i+2&lt;nums.length;i++) {            if (i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;            if (nums[i]&gt;0) break;            int target=-nums[i];            int j=i+1,k=nums.length-1;            while(k&gt;j) {                if(target==nums[j]+nums[k]) {                    aList.add(Arrays.asList(nums[i],nums[j],nums[k]));                    j++;                    k--;                    while(j&lt;k&amp;&amp;nums[j]==nums[j-1])j++;                    while(j&lt;k&amp;&amp;nums[k]==nums[k+1])k--;                }else if(target&lt;nums[j]+nums[k]){                    k--;                }else {                    j++;                }            }        }        return aList;    }}</code></pre><p>大概思想就是让每个数负数作为和，定义两个指针从这个数的右边和数组末向中间遍历，若有符合条件的加入list，跳过重复项</p><hr><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h2><p>Given a string containing digits from  <code>2-9</code>  inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p><p><strong>Example:</strong></p><p><strong>Input:</strong> “23”<br><strong>Output:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p><strong>Note:</strong></p><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {     HashMap&lt;Character, List&lt;Character&gt;&gt; map=new HashMap&lt;&gt;();     StringBuilder stringBuilder=new StringBuilder();     List&lt;String&gt; aList=new ArrayList&lt;&gt;();    public  List&lt;String&gt; letterCombinations(String digits) {        if(digits.length()==0||digits==null) return Arrays.asList();               map.put(&apos;2&apos;, Arrays.asList(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));        map.put(&apos;3&apos;, Arrays.asList(&apos;d&apos;,&apos;e&apos;,&apos;f&apos;));        map.put(&apos;4&apos;, Arrays.asList(&apos;g&apos;,&apos;h&apos;,&apos;i&apos;));        map.put(&apos;5&apos;, Arrays.asList(&apos;j&apos;,&apos;k&apos;,&apos;l&apos;));        map.put(&apos;6&apos;, Arrays.asList(&apos;m&apos;,&apos;n&apos;,&apos;o&apos;));        map.put(&apos;7&apos;, Arrays.asList(&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;));        map.put(&apos;8&apos;, Arrays.asList(&apos;t&apos;,&apos;u&apos;,&apos;v&apos;));        map.put(&apos;9&apos;, Arrays.asList(&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;));        doAdd(digits,0);        return aList;    }    private void doAdd(String digits, int i) {        if (i&lt;digits.length()) {            for (Character character : map.get(digits.charAt(i))) {                stringBuilder.append(character);                doAdd(digits, i+1);                stringBuilder.deleteCharAt(i);            }        }else {            aList.add(stringBuilder.toString());            return;        }    }}</code></pre><hr><h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode node;        if(l1.val&gt;l2.val) {            node=l2;            l2=l2.next;        }else {            node=l1;            l1=l1.next;        }        ListNode head=new ListNode(0);        head.next=node;        while(l1!=null||l2!=null) {            if(l1==null) {                node.next=l2;                break;            }else if(l2==null) {                node.next=l1;                break;            }            if (l1.val&gt;l2.val) {                node.next=l2;                l2=l2.next;            }else {                node.next=l1;                l1=l1.next;            }            node=node.next;        }        return head.next;    }}</code></pre><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>Given  _n_  pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given  _n_  = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public List&lt;String&gt; generateParenthesis(int n) {        List&lt;String&gt; aList=new ArrayList&lt;&gt;();        StringBuilder sBuilder=new StringBuilder();        doListCur(0,0,sBuilder,n,aList);        return aList;    }    private void doListCur(int left, int right, StringBuilder sBuilder,int n,List&lt;String&gt; aList) {        if(n==right) {            aList.add(sBuilder.toString());            return;        }        if (left&lt;n) {            sBuilder.append(&apos;(&apos;);            doListCur(left+1, right, sBuilder, n, aList);            sBuilder.deleteCharAt(sBuilder.length()-1);        }        if (right&lt;left) {            sBuilder.append(&apos;)&apos;);            doListCur(left, right+1, sBuilder, n, aList);            sBuilder.deleteCharAt(sBuilder.length()-1);        }    }}</code></pre><p>类似上题</p><hr><h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h2><p>Merge  _k_  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p><strong>Example:</strong></p><p><strong>Input:</strong></p><pre><code>[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><p><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public ListNode mergeKLists(ListNode[] lists) {         Comparator&lt;ListNode&gt; cmp;        cmp = new Comparator&lt;ListNode&gt;() {          @Override        public int compare(ListNode o1, ListNode o2) {            // TODO Auto-generated method stub            return o1.val-o2.val;        }        };        Queue&lt;ListNode&gt; q = new PriorityQueue&lt;ListNode&gt;(cmp);        for(ListNode l : lists){            if(l!=null){                q.add(l);            }                }        ListNode head = new ListNode(0);        ListNode point = head;        while(!q.isEmpty()){             point.next = q.poll();            point = point.next;             ListNode next = point.next;            if(next!=null){                q.add(next);            }        }        return head.next;    }}</code></pre><p>另外还可以利用第21题的两两链表合并，速度更快</p><hr><h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h2><p>Implement  <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be  <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong>  and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><p><code>1,2,3</code>  →  <code>1,3,2</code><br><code>3,2,1</code>  →  <code>1,2,3</code><br><code>1,1,5</code>  →  <code>1,5,1</code></p><pre><code>class Solution {    public void nextPermutation(int[] nums) {        if(nums.length&lt;2) return;        int n=nums.length-1;        List&lt;Integer&gt; aList=new ArrayList&lt;&gt;();        aList.add(nums[n]);        while(n&gt;0) {            int j=n-1;            for(int i=0;i&lt;aList.size();i++) {                if (aList.get(i)&gt;nums[j]) {                    int anum=nums[nums.length-1-i];                    nums[nums.length-1-i]=nums[j];                    nums[j]=anum;                    Arrays.sort(nums, j+1, nums.length);                    return;                }            }            aList.add(nums[j]);            n--;        }        Arrays.sort(nums);    }}</code></pre><p>用list里的数去和它前面一位的数比较，如果遇到某一个数大于这个数，就互换这两个数的位置，并把前面数后面的位置重新排序。否则就把这个数加入到list里，再次循环。如果一直到循环结束未发现任何后面的数大于前面的数，就把数组从小到大重新排序。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Most Water&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="算法" scheme="http://xfff.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://xfff.xyz/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://xfff.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】笔记1</title>
    <link href="http://xfff.xyz/2018/11/06/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B01/"/>
    <id>http://xfff.xyz/2018/11/06/【leetcode】笔记1/</id>
    <published>2018-11-06T06:40:33.000Z</published>
    <updated>2018-11-06T11:26:51.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p><strong>Given an array of integers, return  </strong>indices<strong>  of the two numbers such that they add up to a specific target.<br>You may assume that each input would have  </strong><em>exactly</em><strong>  one solution, and you may not use the  <em>same</em>  element twice.</strong></p><p><strong>Example:</strong></p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[**0**] + nums[**1**] = 2 + 7 = 9,return [**0**, **1**].</code></pre><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">    int[] result = new int[2];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for (int i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        if (map.containsKey(target - numbers[i])) &#123;</span><br><span class="line">            result[1] = i;</span><br><span class="line">            result[0] = map.get(target - numbers[i]);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(numbers[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Hashmap结构，将值存在key，数组索引序号存在value里，使用containsKey方法简易地寻找和为target的对应项，若存在则返回对应下标，不存在就加入到map中。</p><hr><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><p>Given a string, find the length of the  <strong>longest substring</strong>  without repeating characters.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> “abcabcbb”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is <code>&quot;abc&quot;</code>, with the length of 3. </p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> “bbbbb”<br><strong>Output:</strong> 1 <strong>Explanation:</strong> The answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3 <strong>Explanation:</strong> The answer is <code>&quot;wke&quot;</code>, with the length of 3.<br>             Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.<br>即寻找最长连续子串</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre><code>public int lengthOfLongestSubstring(String s) {    int n=s.length();    HashSet&lt;Character&gt; sett=new HashSet&lt;&gt;();    int maxlen=0,j=0,k=0;    while (j&lt;n&amp;&amp;k&lt;n) {        if(sett.contains(s.charAt(j))) {            sett.remove(s.charAt(k));            k++;        }else {            sett.add(s.charAt(j));            j++;            maxlen=Math.max(maxlen, j-k);        }    }    return maxlen;}</code></pre><p>利用HashSet结构，从字符串开始处索引，当没有重复字符时，定义的一个指针j递增，并计算最长的子串长度，当遇到重复字符时，另一指针k递增，并逐个移除Set集合里的值，直到将重复的字符移出。</p><hr><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h2><p>There are two sorted arrays  <strong>nums1</strong>  and  <strong>nums2</strong>  of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume  <strong>nums1</strong>  and  <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0</p><p><strong>Example 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>A</p><pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {    int m=nums1.length,n=nums2.length;    int slen=m+n;    int num[]=new int[slen];    int j=0,k=0,i=0;    while(j&lt;m&amp;&amp;k&lt;n){        num[i]=(nums1[j]&gt;nums2[k]?nums2[k++]:nums1[j++]);        i++;    }    while(j&lt;m){        num[i++]=nums1[j++];    }    while(k&lt;n){        num[i++]=nums2[k++];    }    if(slen%2==1){        return num[slen/2];    }else{        return (double)(num[slen/2]+num[slen/2-1])/2;    }}</code></pre><p>这个算法很容易理解，就是把两个数组重新排序到一个大数组里，再算中位数就很容易。</p><p>B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    int m = nums1.length;</span><br><span class="line">    int n = nums2.length;</span><br><span class="line">    int len = m + n;</span><br><span class="line">    if(len % 2 == 0)&#123;</span><br><span class="line">        double left =  (double)findKthHelper(nums1, 0, nums2, 0, len/2);</span><br><span class="line">        double right =  (double)findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class="line">        return (double)(left + right)/2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private int findKthHelper(int[] A, int aStart, int[] B, int bStart, int k)&#123;</span><br><span class="line">    if(aStart &gt;= A.length)&#123;</span><br><span class="line">        return B[bStart + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(bStart &gt;= B.length)&#123;</span><br><span class="line">        return A[aStart + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(k == 1)&#123;</span><br><span class="line">        return Math.min(A[aStart], B[bStart]);</span><br><span class="line">    &#125;</span><br><span class="line">    int aMid = aStart + k/2 - 1;</span><br><span class="line">    int bMid = bStart + k/2 - 1;</span><br><span class="line">    int aVal = aMid &gt;= A.length ? Integer.MAX_VALUE : A[aMid];</span><br><span class="line">    int bVal = bMid &gt;= B.length ? Integer.MAX_VALUE : B[bMid];</span><br><span class="line">    if(aVal &lt;= bVal)&#123;</span><br><span class="line">        return findKthHelper(A, aMid + 1, B, bStart, k - k/2);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return findKthHelper(A, aStart, B, bMid + 1, k - k/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于二分法，比较AMid和BMid保留应该保留的部分递归，直至K==1.</p><hr><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p>Given a string  <strong>s</strong>, find the longest palindromic substring in  <strong>s</strong>. You may assume that the maximum length of  <strong>s</strong>  is 1000.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> “babad”<br><strong>Output:</strong> “bab”<br><strong>Note:</strong> “aba” is also a valid answer.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> “cbbd”<br><strong>Output:</strong> “bb”</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><pre><code>public String longestPalindrome(String s) {    if(s.length()&lt;1) return s;    StringBuilder str=new StringBuilder(s);    StringBuilder rs=new StringBuilder(s);    rs.reverse();    int len=s.length();    String outstr=&quot;&quot;;    for(int i=0;i&lt;=len-1;i++) {        for(int n=2;n&lt;=len-i;n++) {            if(str.substring(i, n+i).equals(rs.substring(len-n-i, len-i))) {                if(str.substring(i, n+i).length()&gt;outstr.length()) {                    outstr=str.substring(i, n+i);                }             }        }    }    if(outstr.equals(&quot;&quot;)) {        outstr=str.substring(0, 1);    }    return outstr;}</code></pre><p>将原字符串反转，通过比较对应位置的子字符串</p><p>Better Solution</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int lo, maxLen;</span><br><span class="line"></span><br><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">int len = s.length();</span><br><span class="line">if (len &lt; 2)</span><br><span class="line">return s;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len-1; i++) &#123;</span><br><span class="line">     extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible</span><br><span class="line">     extendPalindrome(s, i, i+1); //assume even length.</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substring(lo, lo + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void extendPalindrome(String s, int j, int k) &#123;</span><br><span class="line">while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span><br><span class="line">j--;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">if (maxLen &lt; k - j - 1) &#123;</span><br><span class="line">lo = j + 1;</span><br><span class="line">maxLen = k - j - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extendPalindrome方法选定一个中心，以两个指针j和k分别向俩个方向延伸，遍历完字符串即可。</p><hr><h2 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for  <code>&#39;.&#39;</code>  and  <code>&#39;*&#39;</code>.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p><p>The matching should cover the  <strong>entire</strong>  input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters  <code>a-z</code>.</li><li><code>p</code>  could be empty and contains only lowercase letters  <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p><strong>Example 1:</strong></p><p><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “.</em>“ means “zero or more (*) of any character (.)”.</p><p><strong>Example 4:</strong></p><p><strong>Input:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p><p><strong>Example 5:</strong></p><p><strong>Input:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>Output:</strong> false</p><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p>正则表达式</p><pre><code>public boolean isMatch(String s, String p) {    java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(p);    java.util.regex.Matcher matcher=pattern.matcher(s);    if(matcher.matches()) {        return true;    }else {        return false;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">    if (s == null || p == null) &#123;</span><br><span class="line">        return s == p;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] sArray = s.toCharArray();</span><br><span class="line">    char[] pArray = p.toCharArray();</span><br><span class="line">    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">        if (p.charAt(j - 1) == &apos;*&apos;) &#123; // * is promised not to be the first char</span><br><span class="line">            dp[0][j] = dp[0][j - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; dp.length; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">            if (pArray[j - 1] == sArray[i - 1] || pArray[j - 1] == &apos;.&apos;) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else if (pArray[j - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                if (sArray[i - 1] == pArray[j - 2] || pArray[j - 2] == &apos;.&apos;) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[dp.length - 1][dp[0].length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Given an array of integers, retu
      
    
    </summary>
    
      <category term="算法" scheme="http://xfff.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://xfff.xyz/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://xfff.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线程池的基本使用</title>
    <link href="http://xfff.xyz/2018/10/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/30/线程池的基本使用/</id>
    <published>2018-10-30T06:23:35.000Z</published>
    <updated>2018-10-30T08:42:35.701Z</updated>
    
    <content type="html"><![CDATA[<p>要用到线程池，就要先介绍一个类：<strong>ThreadPoolExecutor</strong>.</p><p>通过查看源码发现继承及实现关系为<br><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuGh9A4fDJ0d8pyznhKXDBYt9BrBGjLDmJ2ekAKfCBe691QSMbMKcfreff5QKfEQb57FXK03IYw4dCxSW9pKtDQ-ac0kFSYkOqGv04kWo0000" alt=""></p><hr><p>在ThreadPoolExecutor类中，发现有四种构造方法，需要传入很多参数。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><h2 id="这里对常见的参数进行解释："><a href="#这里对常见的参数进行解释：" class="headerlink" title="这里对常见的参数进行解释："></a>这里对常见的参数进行解释：</h2><ul><li><strong>corePoolSize</strong>：核心池的大小</li><li><strong>maximumPoolSize</strong>：线程池大小（最大能容纳线程数）</li><li>keepAliveTime：允许线程空闲时间。当线程池中线程数大于核心池大小时，当有线程空闲时间超过keepAliveTime就会终止。如果调用了allowCoreThreadTimeOut(boolean)方法，则核心池中的空闲线程也会被终止。</li><li>unit：keepAliveTime的时间单位，格式TimeUnit.XXXX(XXXX用HOURS、MILLISECONDS等替代)</li><li><strong>workQueue</strong>：阻塞队列，一般可选三种类型<ul><li>ArrayBlockingQueue数组类型，指定大小</li><li>LinkedBlockingQueue链表类型，不用指定大小</li><li>SynchronousQueue：<a href="https://www.cnblogs.com/duanxz/p/3252267.html" target="_blank" rel="noopener">CLICK</a></li><li>PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂，主要用来创建线程</li><li>handler：指定拒绝处理任务时的策略</li></ul><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>实例化一个ThreadPoolExecutor类</p><pre><code>ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;,5));</code></pre><p>核心池大小为5，线程池大小为10，线程允许空闲200ms，阻塞队列大小5.</p><p>然后，创建20个线程并每次打印线程池中的状态</p><pre><code>for(int a=0;a&lt;20;a++) {    executor.execute(new ThreadPoolT(a));    System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());}</code></pre><p>其中线程的run方法为</p><pre><code>    @Overridepublic void run() {    // TODO Auto-generated method stub    System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);    try {        Thread.sleep(2000);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }    System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);}</code></pre><p>关闭线程池</p><pre><code>executor.shutdown();</code></pre><p>总代码</p><pre><code>package com.test;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolT implements Runnable{    private int id;    public ThreadPoolT(int id) {        super();        this.id = id;    }    public static void main(String[] args) {        ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5));        for(int a=0;a&lt;20;a++) {            executor.execute(new ThreadPoolT(a));            System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());        }        System.out.println(executor.getLargestPoolSize());        System.out.println(executor.getPoolSize());        executor.shutdown();    }    @Override    public void run() {        // TODO Auto-generated method stub        System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);    }}</code></pre><hr><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwqbapglbpj30xw0ezgnm.jpg" alt=""></p><p>可见</p><ol><li>线程池会先创建核心池大小量的线程数，并加入需运行的线程</li><li>然后再往线程池中加线程时，就会往阻塞队列里添加，等待执行</li><li>当阻塞队列满了，再往线程池里添加线程，这个时候线程池就会再创建新线程来弥补不足</li><li>当线程池满了（达到了maximumPoolSize ），再往线程池里添加线程时，线程池就会拒绝任务，而拒绝策略和之前参数的设置有关，这里是抛出RejectedExecutionException异常，并停止添加更多线程执行。</li><li>等待线程运行完</li></ol><hr><p>如果把前面的队列里的参数5去掉，并在线程池结束前加下列代码：</p><pre><code>Thread.sleep(10000);System.out.println(executor.getPoolSize()+&quot;AAAAAAAAAAAAAAA&quot;);executor.shutdown();</code></pre><p>则运行结果为：</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwqbr9olgfj30rn0hwgnk.jpg" alt=""></p><p>可见线程全部运行结束后核心池仍有5个线程，这便是线程池使用的优点，不用频繁开线程关线程，而是提供一些线程代理运行需要运行的线程，提高了程序效率。</p><hr><p>另外，其实一般使用线程池不用我们每次指定那么多参数。一般使用Executors类中提供的静态方法来创建线程池：</p><pre><code>//corePoolSize和maximumPoolSize值相等，它使用LinkedBlockingQueuepublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;(),                                  threadFactory);}//corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueuepublic static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}//corePoolSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><hr><h2 id="合理设置线程池大小"><a href="#合理设置线程池大小" class="headerlink" title="合理设置线程池大小"></a>合理设置线程池大小</h2><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看：<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务 （2*cpu核心）<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要用到线程池，就要先介绍一个类：&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;通过查看源码发现继承及实现关系为&lt;br&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAS
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="多线程" scheme="http://xfff.xyz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="http://xfff.xyz/tags/java/"/>
    
      <category term="线程池" scheme="http://xfff.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>文件上传解析冲突问题</title>
    <link href="http://xfff.xyz/2018/10/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xfff.xyz/2018/10/25/文件上传解析冲突问题/</id>
    <published>2018-10-25T13:27:07.000Z</published>
    <updated>2018-10-25T13:56:21.182Z</updated>
    
    <content type="html"><![CDATA[<p>由于在上一篇写ajax提交表单时，在springmvc.xml里配置了<strong>MultipartResolver</strong>，导致我引入的图片上传插件失效（上传显示成功，但是后台没有接收到），在利用各种搜索引擎查找问题之后，终于找到了原因。</p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>文件上传有两种方式，spring框架里的<strong>MultipartResolver</strong>解析以及传统的<strong>ServletFileUpload</strong>。<br>由于我引入的图片上传插件是第二种方式，而上篇写到的ajax提交表单需要MultipartResolver解析，<strong>两种方式一起使用会产生冲突</strong>。传统方式上传文件的请求会被multipartResolver拦截，导致没有解析出文件。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>统一使用同一种方式上传请求</li><li>继承MultipartResolver，并重写其中的方法，当遇到某些url请求的时候跳过</li></ol><p>由于我引入的插件代码稍微封装的有点麻烦，改起来肯定不方便，而另一边虽然可以改成传统方式发送表单数据，但是需要更多js代码来解析表单数据发送，所以我选择第二种方法。</p><p>事实证明第二种方法确实也更方便。</p><hr><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li><p>创建一个类MyMultipartResolver并让它继承MultipartResolver，下面代码贴出：</p><pre><code>package com.me.resolver;import javax.servlet.http.HttpServletRequest;import org.springframework.web.multipart.commons.CommonsMultipartResolver;public class MyMultipartResolver extends CommonsMultipartResolver {    //单url过滤以及多url过滤    private String excludeUrls;    private String[] excludeUrlArray;    public String getExcludeUrls() {        return excludeUrls;    }    //以逗号分隔    public void setExcludeUrls(String excludeUrls) {        this.excludeUrls=excludeUrls;        this.excludeUrlArray=excludeUrls.split(&quot;,&quot;);    }    //重写的方法，判断url是否需要multipartResolver解析    @Override    public boolean isMultipart(HttpServletRequest request) {        for(String url:excludeUrlArray) {            if(request.getRequestURI().contains(url)) {                return false;            }        }        return super.isMultipart(request);    }}</code></pre></li></ul><p>关键在于isMultipart里的判断</p><ul><li><p>接下来在springmvc.xml配置，删除之前MultipartResolver 的配置内容，修改为</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;com.me.resolver.MyMultipartResolver&quot;&gt;     &lt;property name=&quot;excludeUrls&quot; value=&quot;update&quot; /&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxUploadSize&quot; value=&quot;2097152&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;由此，两种方法就能和睦相处啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于在上一篇写ajax提交表单时，在springmvc.xml里配置了&lt;strong&gt;MultipartResolver&lt;/strong&gt;，导致我引入的图片上传插件失效（上传显示成功，但是后台没有接收到），在利用各种搜索引擎查找问题之后，终于找到了原因。&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="error" scheme="http://xfff.xyz/tags/error/"/>
    
      <category term="resolver" scheme="http://xfff.xyz/tags/resolver/"/>
    
      <category term="文件上传" scheme="http://xfff.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>【ajax】springmvc下使用</title>
    <link href="http://xfff.xyz/2018/10/25/%E3%80%90ajax%E3%80%91springmvc%E4%B8%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/25/【ajax】springmvc下使用/</id>
    <published>2018-10-25T10:02:04.000Z</published>
    <updated>2018-10-25T10:29:02.855Z</updated>
    
    <content type="html"><![CDATA[<p>在做ssm项目的时候用到ajax的记录…</p><hr><p>post方法：<br>动态获取div的value，隐藏对应的div项</p><pre><code>var str=this.value;$.post(&quot;lover/deleteL&quot;,{&quot;id&quot;:str},function(data){    alert(data);    $(&quot;#div&quot;+str).hide();});</code></pre><p>data为后台printwriter.write数据</p><hr><p>当用ajax提交form表单的时候<br>直接：</p><pre><code>$(&quot;#btntj&quot;).click(function(){    var form=new FormData(document.getElementById(&quot;forml&quot;));    $.ajax({        url:&quot;lover/addl&quot;,        type:&quot;post&quot;,         processData:false,        contentType:false,        data:form,        success:function(data){            alert(&quot;添加成功&quot;);            window.location.reload()        },        error:function(){            alert(&quot;添加失败&quot;);        }    }); });</code></pre><p>FormData类能自动把表单内的数据封装好，后台用request.getparemeter(“”)就能获得对应的值，可以说是十分方便了。另外，<strong>表单支持file文件上传类型</strong>。</p><p>后台代码（我这个项目暂时用到的提取方法）：</p><pre><code>@RequestMapping(&quot;/addl&quot;)public void addl(@RequestParam(&quot;lname&quot;) String name,@RequestParam(&quot;month&quot;) String month,@RequestParam(&quot;day&quot;) String day,@RequestParam(&quot;year&quot;)String year,HttpServletRequest request,PrintWriter writer) throws ParseException {    User user=(User) request.getSession().getAttribute(&quot;user&quot;);    Lover lover=new Lover();    lover.setUserid(user.getId());    lover.setName(name);    lover.setBirth(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(year+&quot;-&quot;+month+&quot;-&quot;+day));    loverServiece.saveLover(lover);    writer.write(name);}</code></pre><hr><p><strong>另外</strong>，由于表单提交的是request payload，要在springmvc配置文件中添加</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;10240000&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>才能生效。</p><p>可以通过maxUploadSize设置上传文件的总大小上限，maxInMemorySize设置上传时允许写到内存中的最大值（默认为10240字节）</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做ssm项目的时候用到ajax的记录…&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;post方法：&lt;br&gt;动态获取div的value，隐藏对应的div项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var str=this.value;
$.post(&amp;quot;lover/deleteL&amp;quot;,{
      
    
    </summary>
    
      <category term="ajax" scheme="http://xfff.xyz/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>mybatis操作text等长文本类型</title>
    <link href="http://xfff.xyz/2018/10/24/mybatis%E6%93%8D%E4%BD%9Ctext%E7%AD%89%E9%95%BF%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xfff.xyz/2018/10/24/mybatis操作text等长文本类型/</id>
    <published>2018-10-24T06:41:17.000Z</published>
    <updated>2018-10-24T08:13:25.860Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在实现将图片以base64编码为字符串存入数据库时，我遇到了这个问题。<br>由于字符串过长，创建表时我用text类型来存放图片对应的base64编码字符串。</p><hr><p><strong>最初，我以为是事务配置有问题，导致对表数据修改没有提交，在我试了各种配置方法。</strong></p><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;        &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.me.service.*.*(..))&quot;/&gt;&lt;/aop:config&gt;</code></pre><p>注解扫描配置：</p><pre><code>&lt;bean id=&quot;transactionManager&quot;  class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;/bean&gt;  &lt;!--使用注释事务 --&gt;  &lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; /&gt;</code></pre><hr><p>检验无误后我又认为是字符串不够长，把数据库的text类型改为mediumtext类型</p><pre><code>ALTER TABLE tableName modify column columnName 类型</code></pre><p>发现还是没用，问题依然不出在这。</p><p>网上说现在不推荐使用text类型，建议改为varchar(MAX)类型，于是我又尝试，发现mysql里没有该类型。</p><hr><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>最后终于发现，mybatis对于text这些大文本类型，有特殊的操作方法接口。在逆向工程生成的方法里，有一些方法后面带有WithBloBs字样，这些就是针对这些类型的方法。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdmuerbcj309x00ma9u.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdnupkygj30bw00rjr6.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdon8yb8j30jk00sdfo.jpg" alt=""></p><p>使用这些方法后，终于成功。</p><p>其中xml中的实现如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdpyqowxj30gf033t8s.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;在实现将图片以base64编码为字符串存入数据库时，我遇到了这个问题。&lt;br&gt;由于字符串过长，创建表时我用text类型来存放图片对应的base64编码字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;最初，我以为是事务配置有问题，导致对表数据修改没有提交，在我试了
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="图片" scheme="http://xfff.xyz/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>图片的上传和下载以及存入数据库</title>
    <link href="http://xfff.xyz/2018/10/22/%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://xfff.xyz/2018/10/22/图片的上传和下载以及存入数据库/</id>
    <published>2018-10-22T14:55:10.000Z</published>
    <updated>2018-10-22T15:55:21.684Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先添加jar包"><a href="#首先添加jar包" class="headerlink" title="首先添加jar包"></a>首先添加jar包</h2><p>这里我直接写maven依赖<br><span id="a"></span></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-logging&lt;/groupId&gt;    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;    &lt;type&gt;pom.lastUpdated&lt;/type&gt;&lt;/dependency&gt;</code></pre><hr><h2 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：</h2><pre><code>&lt;form action=&quot;Aservlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;tname&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;tfile&quot; /&gt;    &lt;button type=&quot;submit&quot;&gt;SSSS&lt;/button&gt;&lt;/form&gt;</code></pre><p>这里注意enctype的值</p><hr><h2 id="创建一个Servlet处理接收数据"><a href="#创建一个Servlet处理接收数据" class="headerlink" title="创建一个Servlet处理接收数据"></a>创建一个Servlet处理接收数据</h2><pre><code>PrintWriter out=response.getWriter();response.setContentType(&quot;text/html&quot;);try {    DiskFileItemFactory factory=new DiskFileItemFactory();    ServletFileUpload upload=new ServletFileUpload(factory);    upload.setHeaderEncoding(&quot;utf-8&quot;);    if(!ServletFileUpload.isMultipartContent(request)) {        return;    }    List&lt;FileItem&gt; list=upload.parseRequest(request);    for (FileItem fileItem : list) {        if(fileItem.isFormField()) {            //处理表单内非文件内容            String name=fileItem.getFieldName();            String value=fileItem.getString(&quot;UTF-8&quot;);        }else {            String filename=fileItem.getName();            if(filename.endsWith(&quot;.png&quot;)) {                //这里只接收以png结尾的文件                filename=filename.substring(filename.lastIndexOf(&quot;\\&quot;)+1);                //得到文件输入流                InputStream inputStream=fileItem.getInputStream();                        //创建一个新数组存放内容                byte data[]=new byte[inputStream.available()];                //写入数组                inputStream.read(data);                /*byte buffer[]=new byte[1024];                int len=0;                while((len=inputStream.read(buffer))&gt;0) {                    outputStream.write(buffer, 0, len);                }*/                inputStream.close();                //用base64编码为字符串，接下来就能存入数据库（未写）                String str=Base64.getEncoder().encodeToString(data);                request.getSession().setAttribute(&quot;img&quot;, str);                fileItem.delete();            }            else {                continue;            }        }    }}catch (Exception e) {    // TODO: handle exception}request.getRequestDispatcher(&quot;img.jsp&quot;).forward(request, response);</code></pre><p>这里是doget()里的内容</p><hr><h2 id="创建输出图片的servlet"><a href="#创建输出图片的servlet" class="headerlink" title="创建输出图片的servlet"></a>创建输出图片的servlet</h2><pre><code>//禁止缓存response.setDateHeader(&quot;Expires&quot;, -1);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);// 通知jsp以图片方式打开发送过去的数据response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);String str=(String) request.getSession().getAttribute(&quot;img&quot;);OutputStream outputStream=response.getOutputStream();byte data[]=Base64.getDecoder().decode(str);outputStream.write(data);outputStream.close();</code></pre><p>base64解码，用response的输出流输出</p><hr><h2 id="显示图片的jsp"><a href="#显示图片的jsp" class="headerlink" title="显示图片的jsp"></a>显示图片的jsp</h2><pre><code>&lt;label&gt;图片:&lt;/label&gt;&lt;img width=&quot;200&quot; height=&quot;200&quot; src=&quot;${pageContext.request.contextPath}/Imgg&quot;/&gt;&lt;a href=&quot;${pageContext.request.contextPath}/DownS&quot;&gt;hahah&lt;/a&gt;</code></pre><p>可以设置图片的高和宽</p><hr><h2 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h2><p>通过上面的超链接请求downs这个servlet下载图片<br>doget()内容</p><pre><code>response.setDateHeader(&quot;Expires&quot;, -1);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);response.setHeader(&quot;content-disposition&quot;, &quot;attachment;&quot;);String str=(String) request.getSession().getAttribute(&quot;img&quot;);OutputStream outputStream=response.getOutputStream();byte data[]=Base64.getDecoder().decode(str);outputStream.write(data);outputStream.close();</code></pre><hr><p>遇到的错误或异常：<br><a href="https://blog.csdn.net/xiaoye142034/article/details/78852661" target="_blank" rel="noopener">使用EL表达式标红</a><br><a href="#a">缺少commons-logging</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;首先添加jar包&quot;&gt;&lt;a href=&quot;#首先添加jar包&quot; class=&quot;headerlink&quot; title=&quot;首先添加jar包&quot;&gt;&lt;/a&gt;首先添加jar包&lt;/h2&gt;&lt;p&gt;这里我直接写maven依赖&lt;br&gt;&lt;span id=&quot;a&quot;&gt;&lt;/span&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="javaweb" scheme="http://xfff.xyz/tags/javaweb/"/>
    
      <category term="图片的上传下载" scheme="http://xfff.xyz/tags/%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【ssm】ssm整合配置</title>
    <link href="http://xfff.xyz/2018/10/19/%E3%80%90ssm%E3%80%91ssm%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"/>
    <id>http://xfff.xyz/2018/10/19/【ssm】ssm整合配置/</id>
    <published>2018-10-19T09:46:56.000Z</published>
    <updated>2018-10-19T17:25:54.902Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>导入所有需要的包（添加maven依赖）:</strong></li></ul><pre><code>&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.mybatis&lt;/groupId&gt;         &lt;artifactId&gt;mybatis&lt;/artifactId&gt;         &lt;version&gt;3.4.5&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;         &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-core&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-web&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;         &lt;version&gt;3.1.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;jstl&lt;/artifactId&gt;         &lt;version&gt;1.2&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;junit&lt;/groupId&gt;         &lt;artifactId&gt;junit&lt;/artifactId&gt;         &lt;version&gt;4.12&lt;/version&gt;         &lt;type&gt;pom.lastUpdated&lt;/type&gt;     &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;        &lt;version&gt;3.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;        &lt;type&gt;pom.lastUpdated&lt;/type&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;        &lt;version&gt;1.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;/groupId&gt;        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;8.0.11&lt;/version&gt;      &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.mchange&lt;/groupId&gt;          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;          &lt;version&gt;0.9.5.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;aopalliance&lt;/groupId&gt;          &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;          &lt;version&gt;1.0&lt;/version&gt;          &lt;type&gt;pom.lastUpdated&lt;/type&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;</code></pre><hr><ul><li><strong>配置spring</strong></li></ul><p>为dao、service、transaction等层分别创建配置文件，方便管理。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe0l9i9lnj3080055wei.jpg" alt=""></p><p><strong>applicationContext-dao.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.me.mapper&quot; /&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-service.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.me.service&quot; /&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-trans.xml</strong>：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 切面aop&lt;aop:config&gt;    &lt;aop:pointcut expression=&quot;execution(* com.me.entity.TestClass.*(..))&quot; id=&quot;pointcut1&quot;/&gt;    &lt;aop:aspect ref=&quot;incretestclass&quot;&gt;        &lt;aop:before method=&quot;inc&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;aop:after method=&quot;afterturning&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt; --&gt;&lt;/beans&gt;</code></pre><hr><ul><li><p><strong>数据库配置文件</strong><br><strong>db.properties</strong></p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://localhost\:3306/photo?characterEncoding\=utf-8jdbc.username=rootjdbc.password=olonn</code></pre></li></ul><hr><p>##mybatis</p><ul><li><strong>SqlMapConfig.xml</strong></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;       &lt;!-- 配置扫描的包 --&gt;       &lt;context:component-scan base-package=&quot;com.me.controller&quot; /&gt;       &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;       &lt;mvc:annotation-driven /&gt;        &lt;!--访问静态资源 --&gt;       &lt;mvc:default-servlet-handler /&gt;       &lt;!-- 视图解析器 --&gt;       &lt;bean           class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;           &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;           &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;filter&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:springmvc/springmvc.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><hr><p>可使用逆向工程生成对应数据库下的pojo类和mapper配置文件及接口，复制到对应的包下。</p><hr><hr><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>创建一个service类</p><pre><code>package com.me.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.me.mapper.UserMapper;import com.me.pojo.User;@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public User selectUser(int i) {        return userMapper.selectByPrimaryKey(i);    }}</code></pre><p>创建一个controller</p><pre><code>package com.me.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.me.service.UserService;@Controllerpublic class LoginController {    @Autowired    private UserService uService;    @RequestMapping(value=&quot;/login&quot;)    public ModelAndView login() {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;/login&quot;);        modelAndView.addObject(&quot;user&quot;, uService.selectUser(101));        return modelAndView;    }}</code></pre><p>view目录下创建一个login.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    hahaha+${user.name}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe14h61gsj30m906tdg9.jpg" alt=""></p><hr><ul><li><strong>配置中遇到的异常和错误</strong><blockquote><p><a href="https://blog.csdn.net/u014805893/article/details/52016570" target="_blank" rel="noopener">通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明</a><br><a href="https://blog.csdn.net/eacter/article/details/44624505" target="_blank" rel="noopener">关于spring”通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明“的错误</a></p></blockquote></li></ul><p>其实都是spring配置中的schema配置错误，当缺少哪条时就应该补上对应的xsd文件，具体可以在org.springframework.context.config包下找到，但添加内容并不在这里面，如缺少context的xsd，就加</p><pre><code>http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsd</code></pre><p>配对存在，第二条后面加上具体内容和版本（导入什么包，就加写什么版本）。</p><hr><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入所有需要的包（添加maven依赖）:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;or
      
    
    </summary>
    
      <category term="ssm" scheme="http://xfff.xyz/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="spring" scheme="http://xfff.xyz/tags/spring/"/>
    
      <category term="ssm" scheme="http://xfff.xyz/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】注解开发的详细使用</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】注解开发的详细使用/</id>
    <published>2018-10-18T07:17:03.000Z</published>
    <updated>2018-10-24T17:33:06.073Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先，所有注解都要提前在配置文件中开启扫描。</strong><br><strong>&lt; context:component-scan base-package = “” /&gt;</strong><br>\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a> //指定扫描的路径<br>\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a> //排除扫描的路径</p><p>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:include-filter type=”regex” expression=”.controller.<em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.service.</em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.dao.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>=<br>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:exclude-filter type=”regex” expression=”.model.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>无论哪种情况\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a>和\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a>都不能同时存在</p><hr><p><strong>@Controller</strong><br>注册一个bean到spring，标记一个类为controller，这样才能被外界访问到</p><p><strong>@RequestMapping(“/xxx”)</strong><br>注册xxx请求绑定注解下面的类或方法.<br>该注解一共有六个属性，分别为value、method、consumes、produces、 params、headers。<br><strong>value</strong>：指定请求的实际地址，指定的地址可以是URI Template 模式，即请求的URI中可以包含变量，如<br>/test/{variable}/log.jsp,当请求/test/haha/log.jsp时，variable1对应为’haha’，配合@PathVariable使用。<br>另外，该注解还支持通配符</p><p><strong>method</strong>：指定请求的method类型， GET、POST、PUT、DELETE等</p><pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })public String testMethod() {        return &quot;method&quot; ;    }</code></pre><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法</p><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html<br><strong>produces</strong>：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br><strong>params</strong>：指定request中必须包含某些参数值时，才让该方法处理</p><pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })public String testParams() {       System. out .println( &quot;test Params...........&quot; ); return &quot;testParams&quot; ;    }</code></pre><p>上面代码表面当/aa.action?后面有param1=value&amp;param2={something}且无param3时才能成功访问下面的方法</p><p><strong>headers</strong>：指定request中必须包含某些指定的header值，才能让该方法处理请求<br>与params类似</p><pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; }) public String testHeaders() {         return &quot;headers&quot; ;    }</code></pre><p>在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法</p><hr><p><strong>@Resource和@Autowired</strong><br>两者都用来注入bean，@Resource其实并不是spring的注解，仔细看import部分可以看到是javax.annotation.*下的包。<br>共同点：可以写在bean的声明或者setter方法上，如果写在字段上，就不用写setter方法。<br>不同点：<br>@Autowired是按照类型装配对象，默认要求依赖对象必须存在，如果允许存在，设置required属性为false。按名称装配时要加@Qualifier(“xxx”)<br>@Resource默认按名称装配，需要配置name属性@Resource(name=”xxx”)，也可以设置type属性来按类型装配。</p><hr><p><strong>attribute类型{</strong><br><strong>@ModelAttribute</strong><br>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p><pre><code>@ModelAttribute ( &quot;hello&quot; ) public String getModel() {      System. out .println( &quot;-------------Hello---------&quot; );      return &quot;world&quot; ;   }</code></pre><p>上面代码会在访问方法执行前执行，打印，并把字符串”world”存入model对象中，对应关键字为”hello”<br>也可以在另外的方法参数前加上@ModelAttribute(“xxx”)即可把model里的xxx值映射到这个参数里</p><p><strong>@SessionAttributes</strong><br>将值放到session作用域中，写在class上面。</p><pre><code>@SessionAttributes(value={&quot;name&quot;,&quot;theid&quot;},type={User.class})public class MyController{    //xxxxxx....}</code></pre><p>上面的代码指定了遇到属性name或者theid或者User类型使用modelattribute注解存放的时候，都会存放到session对象里。当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称<br><strong>}</strong></p><hr><p><strong>request uri部分</strong>(variable/)<br><strong>@PathVariable</strong><br>用来将URL中的变量映射到方法的参数里</p><pre><code>@RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId,      @PathVariable(&quot;roleId&quot;) String roleId){      System.out.println(&quot;User Id : &quot; + userId);      System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;;  }</code></pre><hr><p><strong>request body部分</strong>{</p><p><strong>@RequestParam</strong><br>主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型</p><pre><code>public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {      //xxx  }    </code></pre><p><strong>@ResponseBody</strong><br>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT) public void handle(@RequestBody String body, Writer writer) throws IOException {    writer.write(body);  }</code></pre><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><p><strong>}</strong></p><hr><p><strong>request header部分{</strong><br><strong>@RequestHeader</strong></p><pre><code>public  void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,@RequestHeader(&quot;Keep-Alive&quot;)   long  keepAlive) {}</code></pre><p>这段代码把request header部分的Accept-Encoding和Keep-Alive值映射到对应的参数里。</p><p><strong>@CookieValue</strong></p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  }</code></pre><p>上面代码把cookie里的JSESSIONID值映射到对应的参数里。</p><p><strong>}</strong></p><hr><p>@Component<br>通用的注解，当不知道一个类归于哪层时，使用。不推荐使用。</p><p>@Repository<br>注解dao层，在daoImpl类上注解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;首先，所有注解都要提前在配置文件中开启扫描。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&amp;lt; context:component-scan base-package = “” /&amp;gt;&lt;/strong&gt;&lt;br&gt;\&lt;a href=&quot;context:incl
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="注解" scheme="http://xfff.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】配置和使用(二)</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】配置和使用-二/</id>
    <published>2018-10-18T03:38:00.000Z</published>
    <updated>2018-10-18T07:06:10.242Z</updated>
    
    <content type="html"><![CDATA[<p>根据前面描述的工作流程，现在来对springmvc进行配置。</p><ul><li>首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。</li></ul><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;  &lt;/dependency&gt;</code></pre><hr><ul><li><p>创建springmvc的配置文件springmvc.xml (<del>可以任意，最好规范</del>)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;/beans&gt;</code></pre></li></ul><hr><ul><li><p>在web.xml中配置前端控制器。</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li></ul><p>注意param-value中的路径无误，<br>在url-pattern中有两种配置方式：<br>第一种:  *.action  ,访问以.action结尾，由DispatcherServlet进行解析<br><strong>第二种:  \/  ,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方式实现RESTful风格的url</strong></p><p> 错误配置:  \/*  ,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错404</p><hr><ul><li><p>配置处理器映射器</p><pre><code>&lt;bean  class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre></li></ul><ul><li><p>配置处理器适配器</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;</code></pre></li><li><p><strong>注解方式配置</strong></p><pre><code>&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;&lt;mvc:annotation-driven /&gt;</code></pre></li></ul><hr><ul><li>配置处理器Handler(controller)</li></ul><pre><code>&lt;bean  name=&quot;/xxx.action&quot;  class=&quot;com.iot.ssm.controller.xxx&quot;/&gt;</code></pre><ul><li><p><strong>注解批量扫描法</strong></p><pre><code>&lt;!-- 配置扫描的包 --&gt;&lt;context:component-scan base-package=&quot;com.springdemo.*&quot; /&gt;</code></pre></li></ul><hr><ul><li><p><strong>配置视图解析器</strong></p><pre><code>&lt;!-- 视图解析器 --&gt;&lt;bean    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><p>property中prefix对应要查找的目录，suffix对应自动添加的后缀</p><hr><hr><p>测试：</p><p>controller:</p><pre><code>package com.springdemo.controller;import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.swing.text.View;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.springdemo.domain.User;@Controller@RequestMapping(&quot;/demo&quot;)public class TestController implements org.springframework.web.servlet.mvc.Controller{    @RequestMapping(&quot;/demo&quot;)    public String index() {        return &quot;index&quot;;    }    @Override    @RequestMapping(&quot;/test&quot;)    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception {        Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;();         User user=new User();        user.setName(&quot;梁非凡&quot;);        user.setId(&quot;123&quot;);        map.put(&quot;user&quot;, user);        String str=&quot;刘醒&quot;;        map.put(&quot;str&quot;, str);        ModelAndView modelAndView=new ModelAndView();        modelAndView.addAllObjects(map);        modelAndView.setViewName(&quot;test&quot;);        return modelAndView;    }}</code></pre><p>test.jsp :</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${user.name}Hbbbbbbbbb&lt;/body&gt;&lt;/html&gt;</code></pre><p>配置到tomcat上，启动tomcat，打开浏览器，输入地址<br><a href="http://localhost:8888/SpringMVCTest/demo/test" target="_blank" rel="noopener">http://localhost:8888/SpringMVCTest/demo/test</a></p><p>得到：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwce2yvwflj311n0a7aan.jpg" alt=""></p><p>成功…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据前面描述的工作流程，现在来对springmvc进行配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
     
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="springmvc配置" scheme="http://xfff.xyz/tags/springmvc%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】与spring整合</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E4%B8%8Espring%E6%95%B4%E5%90%88/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】与spring整合/</id>
    <published>2018-10-16T15:36:19.445Z</published>
    <updated>2018-10-17T15:34:32.313Z</updated>
    
    <content type="html"><![CDATA[<p><em>只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。</em></p><hr><p>导入相应的整合包后，首先将数据库的配置交给spring配置：</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis的配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>使用mapper代理开发时，在spring容器中配置mapper的接口生成代理对象：</p><pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        //mapperInterface指定mapper接口        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过MapperScannerConfigurer进行mapper扫描可以实现批量配置：</p><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 指定扫描的包名    如果扫描多个包，每个包中间使用半角逗号分隔    --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><hr><p>这样，要使用mapper时，只需要通过注解的方式：</p><pre><code>@Autowiredprivate UserMapper userMapper;</code></pre><p>或加载spring配置文件的方式（Test方法里使用）:</p><pre><code>private ApplicationContext applicationContext;applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);UserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;导入相应的整合包
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】逆向工程及详解</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】逆向工程及详解/</id>
    <published>2018-10-16T13:35:53.952Z</published>
    <updated>2018-10-17T15:49:13.171Z</updated>
    
    <content type="html"><![CDATA[<p>逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理<a href="https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433?fr=aladdin" target="_blank" rel="noopener">^1</a>。</p><hr><ol><li><p>最好先创建一个新的空项目</p></li><li><p>引入Maven依赖</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwaecl9jgvj308w038dfr.jpg" alt=""></p><ol start="3"><li>创建逆向工程配置文件</li><li><p>文件配置内容</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatist&quot;             userId=&quot;root&quot;            password=&quot;olonn&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.me&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;buser&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;bcard&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;ctou&quot;&gt;&lt;/table&gt;        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>创建一个类用来运行生成文件</p><pre><code>package com.mapper;import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class Zzz {    public void generate() throws Exception {        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        boolean overwrite = true;        File configFile = new File(&quot;src/main/resources/GeneratorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        myBatisGenerator.generate(null);    }    public static void main(String[] args) throws Exception {        try {            Zzz zzz=new Zzz();            zzz.generate();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre></li></ol><p>注意配置文件的目录，相对根路径是从项目根目录开始的。运行即可。</p><p>运行完刷新目录，见：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwael724nzj306s0av0sx.jpg" alt=""></p><p>我们就得到了想要的Mapper接口、配置文件和pojo类。</p><hr><hr><p>select主要通过criteria对象<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafj73fpkj30ds02jdfu.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafimt96uj305n06hglo.jpg" alt=""></p><hr><p>总的来说，还是非常方便的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="逆向工程" scheme="http://xfff.xyz/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(三)</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】学习总结-三/</id>
    <published>2018-10-16T07:32:59.850Z</published>
    <updated>2018-10-17T15:36:32.912Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查询的语句，然后在之后才对这个数据进行使用（比如输出），那么在输出的时候，数据库才会真正去运行这条语句返回查询的对象。</p><p>开启延迟加载的方式：</p><ul><li><strong>使用association实现延迟加载</strong></li></ul><p>在association标签里加入select和column属性，select指向查询关联数据的方法，column指向在主表中关联的列（外键那列）。</p><ul><li><p><strong>在全局配置文件中配置</strong></p><pre><code>&lt;settings&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre></li></ul><p>settings标签配置在property下面，typeAlias上面。</p><table><thead><tr><th style="text-align:left">延迟加载开关</th><th style="text-align:left">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</th><th style="text-align:right">lazyLoadingEnabled</th><th style="text-align:center">默认为false</th></tr></thead><tbody><tr><td style="text-align:left">消极加载</td><td style="text-align:left">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td><td style="text-align:right">aggressiveLazyLoading</td><td style="text-align:center">默认为true</td></tr><tr><td style="text-align:left">二级缓存</td><td style="text-align:left"><a href="#a">CLICK</a></td><td style="text-align:right">cacheEnabled</td><td style="text-align:center">默认为false</td></tr></tbody></table><ul><li><strong>一级缓存</strong></li></ul><p>Mybatis默认开启一级缓存，在同一个SqlSession中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则SqlSession的缓存清空。<br>SqlSession关闭也清空，比如一个service调用的结束，会关闭一个sqlsession，则缓存结束。</p><p><span id="a"></span></p><ul><li><strong>二级缓存</strong></li></ul><p>Mybatis需要手动设置启动二级缓存，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存,添加：</p><pre><code>&lt;cache/&gt;</code></pre><p>二级缓存的作用域是同一个namespace下的mapper映射文件内容（HashMap），多个SqlSession共享。<br>在同一个namespace下的mapper文件中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则二级缓存清空。<br>一个SqlSession关闭不会导致二级缓存清空，如果设置了二级缓存，service重复被调用查询同一条记录，只会一直从二级缓存中查询。</p><p><strong>实现序列化</strong></p><p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。</p><p>如果该类存在父类，那么父类也要实现序列化。</p><p><strong>设置禁用二级缓存</strong></p><p>在select中添加属性useCache=”false”默认为true。</p><p><strong>设置刷新二级缓存</strong></p><p>在select中添加属性flushCache=”true”。</p><h2 id="mybatis整合ehcache"><a href="#mybatis整合ehcache" class="headerlink" title="mybatis整合ehcache"></a>mybatis整合ehcache</h2><p>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。</p><p>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。</p><p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><ul><li><strong>整合方法：</strong></li></ul><p>整合ehcache所需包：</p><ul><li>ehcache-core-2.6.11.jar</li><li>mybatis-ehcache-1.1.0.jar</li></ul><p>设置mapper配置文件中</p><pre><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><p>加入ehcache的配置文件ehcache.xml（classpath下）：</p><pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt;    &lt;defaultCache         maxElementsInMemory=&quot;1000&quot;         maxElementsOnDisk=&quot;10000000&quot;        eternal=&quot;false&quot;         overflowToDisk=&quot;false&quot;         timeToIdleSeconds=&quot;120&quot;        timeToLiveSeconds=&quot;120&quot;         diskExpiryThreadIntervalSeconds=&quot;120&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;延迟加载&quot;&gt;&lt;a href=&quot;#延迟加载&quot; class=&quot;headerlink&quot; title=&quot;延迟加载&quot;&gt;&lt;/a&gt;延迟加载&lt;/h2&gt;&lt;p&gt;为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】多对多关系</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】多对多关系/</id>
    <published>2018-10-16T06:50:23.956Z</published>
    <updated>2018-10-17T15:37:15.763Z</updated>
    
    <content type="html"><![CDATA[<p><em>关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。</em></p><hr><ul><li><strong>首先，创建表，建立连接关系。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2l7b67ej30ib0e8jrg.jpg" alt=""></li></ul><ul><li><strong>然后，插入示例数据。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2mq19o5j30ib0e8q30.jpg" alt=""></li></ul><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2n7k9vwj30ib0e8glp.jpg" alt=""></p><p>打印一下，记录<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2nxp4o4j30ib0kiaa1.jpg" alt=""></p><p>分别为三张表，一张银行用户表，简单起见，只有id和name两列，一张银行卡表，有id和money两列，最后是一张关系维护表，有三列，id、对应用户的buserid、对应卡的bcardid。</p><p>我设定的银行卡为家庭卡，可以多个人用一个账号，一个人可以用多张卡。</p><h2 id="前提准备做完了，开始建立多对多关系映射。"><a href="#前提准备做完了，开始建立多对多关系映射。" class="headerlink" title="前提准备做完了，开始建立多对多关系映射。"></a>前提准备做完了，开始建立多对多关系映射。</h2><ol><li>创建用户和卡的表对应的实体类，并设置对应的映射属性，分别加入一个list\<t>属性。如下：</t></li></ol><pre><code>package com.test.domain;import java.util.List;public class Buser {    private int id;    private String name;    private List&lt;Bcard&gt; bcards;    public List&lt;Bcard&gt; getBcards() {        return bcards;    }    public void setBcards(List&lt;Bcard&gt; bcards) {        this.bcards = bcards;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><ol start="2"><li><p>创建并配置对应的mapper映射文件</p><pre><code>&lt;mapper namespace=&quot;com.test.mapper.BuserMapper&quot;&gt;    &lt;resultMap type=&quot;buser&quot; id=&quot;resultUmap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;&lt;!--         &lt;collection property=&quot;uList&quot; ofType=&quot;com.test.domain.Ctou&quot;&gt;            &lt;id column=&quot;c_id&quot; property=&quot;id&quot; /&gt;            &lt;result column=&quot;buserid&quot; property=&quot;buserid&quot; /&gt;            &lt;result column=&quot;bcardid&quot; property=&quot;bcardid&quot; /&gt;        &lt;/collection&gt; --&gt;        &lt;collection property=&quot;bcards&quot; ofType=&quot;com.test.domain.Bcard&quot;&gt;                &lt;id column=&quot;b_id&quot; property=&quot;id&quot; /&gt;                &lt;result column=&quot;money&quot; property=&quot;money&quot; /&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectMtoM&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;resultUmap&quot;&gt;        SELECT buser.*,bcard.id b_id,bcard.money from buser,ctou,bcard        where buser.id=#{value} and buser.id=ctou.buserid and ctou.bcardid=bcard.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li></ol><ol start="3"><li>创建对应接口和方法</li></ol><pre><code>public interface BuserMapper {    public Buser selectMtoM(Integer value) throws Exception;}</code></pre><ol start="4"><li><p>记得在总配置文件里配置</p><pre><code>&lt;typeAliases&gt;    &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;package name=&quot;com.test.domain&quot;/&gt;&lt;/typeAliases&gt;&lt;mappers&gt;    &lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; --&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;     &lt;package name=&quot;com.test.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre></li><li><p>测试</p><pre><code>Buser buser=buserMapper.selectMtoM(111);System.out.println(buser.getName());for (Bcard bcard : buser.getBcards()) {    System.out.println(bcard.getId()+&quot; &quot;+bcard.getMoney());}</code></pre></li></ol><ol start="6"><li>结果输出：<br>胡歌<br>1002 0<br>1003 10000</li></ol><hr><p>反过来从bcard来查buser也一样的步骤。</p><p>over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先，创建表，建立连接关系。&lt;/stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(二)</title>
    <link href="http://xfff.xyz/2018/10/15/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://xfff.xyz/2018/10/15/【mybatis】学习总结(二)/</id>
    <published>2018-10-15T07:38:30.030Z</published>
    <updated>2018-10-17T15:37:35.815Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="动态Sql"><a href="#动态Sql" class="headerlink" title="动态Sql"></a>动态Sql</h2><p>mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。</p><ul><li><strong>if语句</strong></li></ul><p>在mapper映射文件中可以使用\<if>标签来对语句接收的参数进行判断，从而动态改变sql语句。</if></p><p>为了避免多次遇到同一段判断代码时的累赘，可以使用<strong>SQL片段</strong>来重复利用代码。<br>如下：</p><pre><code>&lt;sql id=&quot;thereissqlblock&quot;&gt;        &lt;if test=&quot;goods!=null and user!=null&quot;&gt;            &lt;if test=&quot;user.name!=null and user.name!=&apos;&apos; &quot;&gt;                AND user.password=#{goods.price}            &lt;/if&gt;        &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;selectUseIf&quot; parameterType=&quot;userQuery&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM USER    &lt;where&gt;        &lt;include refid=&quot;thereissqlblock&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p><strong>具体分析：</strong><br>if标签\&lt;&gt;里的test判断的是输入的参数的值，而\&lt;&gt;外则是相应的sql语句块（另外，#表示占位符,$为匹配符）。若不符合if test里的条件，则会执行select * from user，及不设置条件会查询出所有记录，若符合，则会把sql片段拼接到原语句。</p><ul><li><strong>foreach语句</strong></li></ul><p>foreach对应sql语句为：</p><pre><code>SELECT * FROM USER WHERE userid=1 OR userid=2 OR userid=3SELECT * FROM USER WHERE userid IN(1,2,3)</code></pre><p>对于多个对象的输入查询，foreach可以解决遍历参数数组的问题。首先在参数对象中定义一个list集合并生成set和get方法，</p><pre><code>private    List&lt;T&gt; list;//set和get方法 </code></pre><p>在mapper参数类型parameterType设置为list存放对象类型，接着：</p><pre><code>&lt;if test=&quot;users!=null&quot;&gt;    &lt;foreach collection=&quot;users&quot; item=&quot;theuser&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;        userid=#{theuser.userid}    &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>使用：</p><pre><code>User user1=new User();User user2=new User();user1.setUserid(1111);user2.setUserid(1112);List&lt;User&gt; users=new ArrayList&lt;&gt;();users.add(user1);users.add(user2);userQuery.setUsers(users);userMapper.selectForeach(userQuery).stream().forEach(System.out::println);</code></pre><p>即可查出id为1111,1112的俩条记录。</p><hr><h2 id="sql的一对一、一对多"><a href="#sql的一对一、一对多" class="headerlink" title="sql的一对一、一对多"></a>sql的一对一、一对多</h2><p>定义表，orders：订单，custom：用户。外键关联<br>一个用户可发起多个订单，一个订单对应一个用户。<br>在对应类里添加属性。<br>orders:private Custom custom；<br>custom:private List\<orders> orders;</orders></p><ul><li><strong>一对一：</strong></li></ul><pre><code>订单对用户为一对一关系，则根据订单查用户有如下几种方法：</code></pre><ol><li><p>创建一个新类继承Orders,在该类里添加custom的属性并生成set和get方法。然后直接使用该类查询即可，实际应用中应该加上一个输入的参数ordersid<del>这里我懒没加</del></p><pre><code>&lt;mapper namespace=&quot;com.me.mapper.OrdersMapper&quot;&gt;    &lt;select id=&quot;findCO&quot; resultType=&quot;customOrders&quot;&gt;        SELECT custom.*,orders.* FROM custom,orders WHERE orders.customid=custom.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li>上面方法是在没有设置private Custom custom属性时候用的，所以其实可以直接把resultType改成orders，但得不到custom对象，不会把写在mapper里的custom.*映射到orders里的custom属性。</li><li><p>怎么解决2的问题呢？使用resultMap添加association标签关联即可解决</p><pre><code>&lt;resultMap type=&quot;orders&quot; id=&quot;resultmap1&quot;&gt;    &lt;id column=&quot;orderid&quot; property=&quot;orderid&quot; /&gt;    &lt;result column=&quot;thing&quot; property=&quot;thing&quot;/&gt;    &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;association property=&quot;custom&quot; javaType=&quot;com.me.domain.Custom&quot;&gt;        &lt;id column=&quot;customid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findCCO&quot; resultMap=&quot;resultmap1&quot;&gt;    SELECT orders.*,custom.* FROM custom,orders WHERE orders.customid=custom.id&lt;/select&gt;</code></pre><p>这里，在resultMap里少添加或者在select后面少写一项属性，得到的对象属性就会少一项属性的值（<del>所以不要偷懒少写属性</del>）。</p></li></ol><hr><ul><li><strong>一对多：</strong></li></ul><p>上面的一对一反过来，问题就变成了一对多，即一个custom对应多个orders。<br>对于一对多关系，我直接介绍最有效率的方法：<br>使用resultMap：</p><pre><code>&lt;resultMap type=&quot;custom&quot; id=&quot;ccus&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;    &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;com.me.domain.Orders&quot;&gt;        &lt;id column=&quot;order_id&quot; property=&quot;orderid&quot;/&gt;        &lt;result column=&quot;thing&quot; property=&quot;thing&quot; /&gt;        &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectCus&quot; resultMap=&quot;ccus&quot;&gt;    SELECT c.*,o.orderid order_id,o.thing,o.customid FROM custom c,orders o WHERE c.id=o.customid&lt;/select&gt;</code></pre><p>注意这里是collection，执行后会把符合条件的orders一条一条映射到custom的list\<orders>属性。</orders></p><p><strong>注意事项：</strong>如果关联表中有列名和主表列名相同，必须要设置别名，否则查询结果会有问题。</p><blockquote><p><a href="https://blog.csdn.net/xzm_rainbow/article/details/15336933" target="_blank" rel="noopener">具体可以看这里</a></p></blockquote><hr><ul><li><strong>多对多：</strong></li></ul><p><a href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/">具体看这篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;动态Sql&quot;&gt;&lt;a href=&quot;#动态Sql&quot; class=&quot;headerlink&quot; title=&quot;动态Sql&quot;&gt;&lt;/a&gt;动态Sql&lt;/h2&gt;&lt;p&gt;mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】大概总结(一)</title>
    <link href="http://xfff.xyz/2018/10/15/%E3%80%90mybatis%E3%80%91%E5%A4%A7%E6%A6%82%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://xfff.xyz/2018/10/15/【mybatis】大概总结(一)/</id>
    <published>2018-10-15T05:41:46.178Z</published>
    <updated>2018-10-17T15:37:06.599Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#c">原生访问数据库方法</a><br><a href="#a">总配置文件</a><br><a href="#mapper">mapper配置</a><br><a href="#mapperj">mapper接口</a><br><a href="#mapperc">使用示例</a></p><hr><p><span id="c"></span></p><h2 id="原生访问数据库方法-jdbc"><a href="#原生访问数据库方法-jdbc" class="headerlink" title="原生访问数据库方法:jdbc"></a>原生访问数据库方法:jdbc</h2><p><strong>jdbc编程步骤:</strong></p><ol><li>加载数据库驱动</li><li>创建并获取数据库链接</li><li>创建jdbc statement对象</li><li>设置sql语句</li><li>设置sql语句中的参数(使用preparedStatement)</li><li>通过statement执行sql并获取结果</li><li>对sql执行结果进行解析处理</li><li>释放资源(resultSet、preparedstatement、connection)</li></ol><p><strong>缺点</strong>：每次对数据库操作时就得建立连接，用完又得释放，非常不方便，且对数据库造成压力较大。不灵活， 程序耦合度高。</p><hr><h1 id="–Mybatis–"><a href="#–Mybatis–" class="headerlink" title="–Mybatis–"></a>–Mybatis–</h1><p>与hibernate类似，mybatis也让表和java类产生映射关系，通过配置映射文件实现。</p><p>可创建相应实体类.xml，并在mybatis配置文件中加载（这里省略这种方法）。</p><p><span id="a"></span></p><h2 id="首先配置mybatis总配置文件SqlMapConfig-xml"><a href="#首先配置mybatis总配置文件SqlMapConfig-xml" class="headerlink" title="首先配置mybatis总配置文件SqlMapConfig.xml"></a>首先配置mybatis总配置文件SqlMapConfig.xml</h2><p><strong>注意事项:</strong></p><ul><li><strong>标签有固定的配置顺序</strong>：<br>properties（属性）<br>settings（全局配置参数）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）</li><li><strong>mybatis使用自带的数据库连接池，不支持第三方连接池（网上有添加方法）</strong></li></ul><p><strong>配置建议：</strong></p><ul><li><p><strong>别名配置typeAliases</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.domain&quot;/&gt;</code></pre><p>其中com.me.domain是你要自动配置的包里类的别名（用对应类名配置）</p></li></ul><ul><li><p><strong>mappers映射器配置</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.mapper&quot;/&gt;</code></pre><p>其中com.me.mapper对应配置的mapper的包名（同上）</p></li></ul><hr><p>示例（只配置了部分配置）:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><p><span id="mapper"></span></p><h2 id="mapper映射器配置"><a href="#mapper映射器配置" class="headerlink" title="mapper映射器配置"></a>mapper映射器配置</h2><p><strong>输入映射：</strong><br>resultType指定输入参数类型：</p><ul><li>简单类型(直接使用)</li><li>hashmap(直接使用)</li><li>pojo的包装类型（<strong>常用</strong>）：<br>通过创建一个新的类，在这个类里创建想用来操作的输入参数，并生成set和get方法</li></ul><p><strong>输出映射：</strong></p><ul><li><strong>resultType</strong>：列名与属性名一致才能成功映射<ul><li>输出简单类型</li><li>输出pojo对象和列表</li></ul></li><li><strong>resultMap</strong>：可以定义列的别名，通过别名来映射<ul><li>输出配置的resultMap的id对应的对象</li></ul></li></ul><p>resultMap需要先在mapper里配置resultMap（使用时若要用其他mapper里的resultMap配置，需要在前面加上对应mapper的namespace）示例：</p><pre><code>&lt;!-- 定义resultMap将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系type：resultMap最终映射的java对象类型,可以使用别名id：对resultMap的唯一标识 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;    &lt;!-- id表示查询结果集中唯一标识     column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）    --&gt;    &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;    &lt;!--     result：对普通名映射定义    column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）     --&gt;    &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt;</code></pre><p>使用示例:</p><pre><code>&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    SELECT id id_,username username_ FROM USER WHERE id=#{value}&lt;/select&gt;</code></pre><p>另外在接口中，返回类型写map对应实体类就OK</p><hr><p>Mapper配置示例:</p><pre><code>&lt;!DOCTYPE mapper    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.me.mapper.GoodsMapper&quot;&gt;&lt;resultMap type=&quot;goods&quot; id=&quot;goodsResultMap&quot;&gt;    &lt;id column=&quot;gname_haha&quot; property=&quot;gname&quot; /&gt;    &lt;result column=&quot;price_haha&quot; property=&quot;price&quot; /&gt;&lt;/resultMap&gt;&lt;insert id=&quot;insertGoods&quot; parameterType=&quot;goods&quot;&gt;    INSERT INTO GOODS(gname,price) VALUE(#{gname},#{price})&lt;/insert&gt;&lt;select id=&quot;selectall&quot; resultMap=&quot;goodsResultMap&quot;&gt;    SELECT gname gname_haha,price price_haha FROM goods&lt;/select&gt;</code></pre><p></p><hr><p><span id="mapperj"></span></p><h2 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a><strong>Mapper接口：</strong></h2><p>创建mapper.xml映射器对应的接口。<br>在mapper.xml中配置的方法，需要在mapper接口类里配置:<br>其中必须符合以下<strong>四</strong>个规范:</p><ul><li>mapper接口类和映射文件在同一包下</li><li>mapper接口里方法名与映射文件配置id一致</li><li>mapper接口方法参数和映射文件配置参数类型一致</li><li>mapper接口方法返回类型和映射文件配置参数类型一致（可以用list&lt;类&gt;，会自动调用selectlist返回对应对象的list集合）</li></ul><p>示例:</p><pre><code>package com.me.mapper;import java.util.List;import com.me.domain.User;import com.me.domain.UserQuery;public interface UserMapper {    public User findUserById(Integer userid) throws Exception;    public User selectUserQuery(UserQuery userQuery) throws Exception;    public void updateUser(User user) throws Exception;    public List&lt;User&gt; findUserByName(String string) throws Exception;    public List&lt;User&gt; selectUserList(UserQuery userQuery) throws Exception;}</code></pre><hr><p><span id="mapperc"></span></p><h2 id="使用mapper操作数据："><a href="#使用mapper操作数据：" class="headerlink" title="使用mapper操作数据："></a>使用mapper操作数据：</h2><p>示例:</p><pre><code>import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.me.domain.Goods;import com.me.domain.User;import com.me.domain.UserQuery;import com.me.mapper.GoodsMapper;import com.me.mapper.UserMapper;public class Tmybati {    SqlSessionFactory sessionFactory;    //这个注解会让这个方法在test方法前执行    @Before    public void a() throws IOException {        String string=&quot;SqlMapConfig.xml&quot;;        InputStream inputStream=Resources.getResourceAsStream(string);        sessionFactory=new SqlSessionFactoryBuilder().build(inputStream);    }    //测试方法    @Test    public void tess() throws Exception {        SqlSession session=sessionFactory.openSession();        UserMapper userMapper=session.getMapper(UserMapper.class);/*                User user2=new User();        user2.setUserid(1111);        Goods goods=new Goods();        goods.setGname(&quot;吴克&quot;);        goods.setPrice(1111);        UserQuery userQuery=new UserQuery();        userQuery.setUser(user2);        userQuery.setGoods(goods);        List&lt;User&gt; users=userMapper.selectUserList(userQuery);        users.stream().forEach(System.out::println);        User user=userMapper.findUserById(1111);        System.out.println(user);*/        Goods dGoods =new Goods();        dGoods.setGname(&quot;吴克5&quot;);        dGoods.setPrice(1111);        GoodsMapper goodsMapper=session.getMapper(GoodsMapper.class);        List&lt;Goods&gt; goods=goodsMapper.selectall();        goods.stream().filter(n-&gt;n.getPrice()==123).forEach(System.out::println);        session.commit();        session.close();    }}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#c&quot;&gt;原生访问数据库方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#a&quot;&gt;总配置文件&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapper&quot;&gt;mapper配置&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapperj&quot;&gt;mapper接口&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#ma
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【ajax】请求服务器+参数双向传递</title>
    <link href="http://xfff.xyz/2018/10/14/%E3%80%90ajax%E3%80%91%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8F%82%E6%95%B0%E5%8F%8C%E5%90%91%E4%BC%A0%E9%80%92/"/>
    <id>http://xfff.xyz/2018/10/14/【ajax】请求服务器-参数双向传递/</id>
    <published>2018-10-13T17:13:37.207Z</published>
    <updated>2018-10-17T15:48:49.290Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。</strong></p><hr><p> <strong>1. GET方式</strong></p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;GET&quot;,&quot;ajax!findRecord.action?&quot;+str,true);        xmlhttp.send();    });});</code></pre><p>通过在请求的URL”？”后加参数而达到传参的目的。<br>对于URL尾部的参数，后台action中只要通过request域对象即可取值。</p><pre><code>HttpServletRequest request=ServletActionContext.getRequest();HttpServletResponse response=ServletActionContext.getResponse();response.setContentType(&quot;text/html&quot;);response.setCharacterEncoding(&quot;UTF-8&quot;);Integer cardId=Integer.parseInt(request.getParameter(&quot;cardId&quot;));String date=request.getParameter(&quot;date&quot;);</code></pre><p>struts2里配置为:</p><pre><code>&lt;package name=&quot;actionA&quot; extends=&quot;json-default&quot;&gt;    &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt;    &lt;action name=&quot;ajax!*&quot; class=&quot;ajaxAction&quot; method=&quot;{1}&quot;&gt;        &lt;result type=&quot;json&quot;&gt;&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;</code></pre><hr><p> <strong>2. —- POST方式</strong><br>    &nbsp;post请求方式相对于get请求方式更加安全（数据信息不会显示在URL中），发送请求能提交的数据也更大。</p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;POST&quot;,&quot;ajax!findRecord.action&quot;,true);        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);        xmlhttp.send(str);    });});</code></pre><p>后台action内获取ajax发送来的数据参数方式同上。</p><hr><hr><h3 id="Ajax-ajax"><a href="#Ajax-ajax" class="headerlink" title="Ajax-ajax()"></a><strong>Ajax-ajax()</strong></h3><p>它是最底层、功能最强大的请求服务器数据方式，它的调用格式为：</p><pre><code>$.ajax([settings]);</code></pre><p>接下来是实际使用:</p><pre><code>$(document).ready(function(){    function doappend(list){        var tbody=&quot;&quot;;        for(i in list){            tbody+=&quot;&lt;tr&gt;&lt;td&gt;&quot;+list[i].userId+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].userName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].password+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].cards+&quot;&lt;/td&gt;&lt;td&gt;&lt;a href=\&quot;#\&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=\&quot;#\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;        }         document.getElementById(&quot;divtable&quot;).innerHTML=tbody;    };    $(&quot;#btnSend&quot;).click(function(){        $(this).attr(&quot;disabled&quot;,true);        var pag=document.getElementById(&quot;thepage&quot;).innerText;        $.ajax({            type:&quot;POST&quot;,            url:&quot;ajax!findall.action&quot;,            data:{&quot;page&quot;:pag},            dataType:&quot;json&quot;,            success:function(data){                var a=eval(&apos;(&apos;+data+&apos;)&apos;);                var am=a.aMap;                var list=am.user;                doappend(list);            }        });    });});</code></pre><p>data:标签对应为发送给服务器后台的数据，必须要使用json格式｛”name”:name,”id”:id｝。type对应请求方式，url为请求的定位，dataType为服务器返回数据的类型，success为成功获取服务器返回数据后可以执行的操作（这里我正在做分页，把页数发送给服务器，服务器查询数据库后返回相应条数的数据）。<br>function里的data为服务器返回的数据，这里是一个hashmap类型，先对data用eval方法进行json格式解析，aMap为当时hashmap设置的name值，在hashmap格式里，key值为‘user’对应的对象，为一个list<user>类型，具体可以看下面的后台代码，然后执行doappend方法，将数据一条一条加入到表格格式里。</user></p><pre><code>private String page;HashMap&lt;String, Object&gt; aMap=new HashMap&lt;String,Object&gt;();public HashMap&lt;String, Object&gt; getaMap() {    return aMap;}public String getPage() {    return page;}public void setPage(String page) {    this.page = page;}public String findall() {    int c=userService.count();    int d;    if(0==c%5) {        d=c/5;    }else {        d=(c/5)+1;    }    aMap.clear();    int p=Integer.parseInt(page);    if(p&lt;1||p&gt;d) {        return NONE;    }else {        int begin=(p-1)*5;        List&lt;User&gt; pList=userService.findPage(begin, 5);        List&lt;UserForAjax&gt; uList=new ArrayList&lt;UserForAjax&gt;();        for (User user : pList) {            StringBuffer sv=new StringBuffer(&quot;&quot;);            for(BankCard bCard:user.getSetBank()) {                sv.append(bCard.getCardId()+&quot; &quot;);            }            String str=sv.toString();            UserForAjax userForAjax=new UserForAjax();            userForAjax.setUserId(user.getUserId());            userForAjax.setEmail(user.getEmail());            userForAjax.setPassword(user.getPassword());            userForAjax.setUserName(user.getUserName());            userForAjax.setCards(str);            uList.add(userForAjax);        }        aMap.put(&quot;user&quot;, uList);        aMap.put(&quot;result&quot;, &quot;success&quot;);        return SUCCESS;    }}</code></pre><p>后台代码中，通过命名一个叫做page的string对象，并生成set和get方法，接收请求后，就能直接得到请求数据中的page对象的值（会调用set方法给this.page赋值），另外创建一个hashmap对象用来存放返回给前端的数据，并生成<strong>get</strong>方法，这样ajax那边才能得到返回的aMap，在方法中给aMap存入需要传递的值。</p><hr><p>一个简单的分页就做好啦!<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw7552c8jpj30x30at74d.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw755vane7j30x80apq30.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;strong&gt;1. GET方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(func
      
    
    </summary>
    
      <category term="ajax" scheme="http://xfff.xyz/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】基础结构实现集合</title>
    <link href="http://xfff.xyz/2018/10/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/"/>
    <id>http://xfff.xyz/2018/10/14/【数据结构】基础结构实现集合/</id>
    <published>2018-10-13T16:24:24.135Z</published>
    <updated>2018-10-17T15:38:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>一些我早期学数据结构的时候用C++实现的代码。<del>指针在实现上比较方便</del></p><hr><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="(1)栈"></a>(1)栈</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int SElemType;typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStack;int InitStack(LinkStack &amp;top){    top = (StackNode*)malloc(sizeof(StackNode));    if(top!=NULL){        top = NULL;    }    return OK;}int Push(LinkStack &amp;top,SElemType e){    LinkStack p =(StackNode*)malloc(sizeof(StackNode));    p-&gt;data=e;    p-&gt;next=top;    top=p;    return OK;}int CreateStack(LinkStack &amp;top){    int n;    cout &lt;&lt; &quot;输入入栈元素个数:&quot;;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        int m;        cout&lt;&lt;&quot;输入进栈元素:&quot;;        cin&gt;&gt;m;        Push(top,m);    }    return OK;}int Pop(LinkStack &amp;top,SElemType &amp;e){    LinkStack p;    if(top!=NULL){        p=top;        e = top-&gt;data;        top = top-&gt;next;        free(p);    }    else        return ERROR;    return OK;}int GetTop(LinkStack top,SElemType &amp;e){    if(top!=NULL)        e = top-&gt;data;    else        return ERROR;    return OK;}void outStack(LinkStack top){    while(top!=NULL){        cout&lt;&lt;top-&gt;data&lt;&lt;endl;        top=top-&gt;next;    }}int main(){    LinkStack top;    InitStack(top);    CreateStack(top);    outStack(top);    int e;    cout&lt;&lt;&quot;出栈一次;&quot;;    Pop(top,e);    cout&lt;&lt;&quot;出栈元素:&quot;&lt;&lt;e&lt;&lt;endl;    outStack(top);    GetTop(top,e);    cout&lt;&lt;&quot;栈顶元素为:&quot;&lt;&lt;e&lt;&lt;endl;    return 0;}</code></pre><h2 id="2-静态链表"><a href="#2-静态链表" class="headerlink" title="(2)静态链表"></a>(2)静态链表</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 1000#define OK 1#define ERROR 0#define FALSE 0#define TRUE 1typedef int status;typedef struct{    status data;    int cur;}component,    SLinkList[MAXSIZE];//初始化status InitList(SLinkList space){    int i;    for(i=0;i&lt;MAXSIZE-1;i++)        space[i].cur = i+1;    space[MAXSIZE-1].cur=0;    return OK;}//若备用空间链表非空，返回分配的结点下标int Malloc_SLL(SLinkList space){    int i = space[0].cur;    if(space[0].cur)        space[0].cur = space[i].cur;    return i;}int ListLength(SLinkList sl){    int j=0;    int i=sl[MAXSIZE-1].cur;    while(i){        i=sl[i].cur;        j++;    }    return j;}//插入status ListInsert(SLinkList L,int i,status e){    int j,k,l;    k=MAXSIZE-1;    if(i&lt;1||i&gt;ListLength(L)+1)        return ERROR;    j=Malloc_SLL(L);    if(j){        L[j].data=e;        for(l=1;l&lt;=i-1;l++)            k=L[k].cur;        L[j].cur=L[k].cur;        L[k].cur=j;        return OK;    }    return ERROR;}//回收空闲结点void Free_SSL(SLinkList space,int k){    space[k].cur=space[0].cur;    space[0].cur=k;}//删除status ListDelete(SLinkList L,int i){    int j,k;    if(i&lt;1||i&gt;ListLength(L))        return ERROR;    k = MAXSIZE-1;    for(j=1;j&lt;=i-1;j++)        k=L[k].cur;    j=L[k].cur;    L[k].cur=L[j].cur;    Free_SSL(L,j);    return OK;}int main(){    return 0;}</code></pre><p>(3)链式存储结构表及表间操作</p><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;using namespace std;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef struct LNode{    Status data;    struct LNode *next;                }LNode ,*LinkList;Status InitList(LinkList &amp;L){    L = (LNode*)malloc(sizeof(LNode));    if(L == NULL)        return ERROR;    L-&gt;next=NULL;    return OK;}Status GetElem(LinkList L,int i,Status *e){    int j;    LinkList p;    p = L-&gt;next;    j = 1;    while(p&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    *e = p-&gt;data;    return OK;}Status ListInsert(LinkList &amp;L,int i,Status e){    int j;    LinkList p,s;    p = L;    j=1;    while( p &amp;&amp; j&lt;i ){        p=p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    s =(LinkList)malloc(sizeof(LNode));    s-&gt;data = e;    s-&gt;next = p-&gt;next;    p-&gt;next = s;      return OK;}Status ListDelete(LinkList &amp;L,int i,Status *e){    int j;    LinkList p,q;    p = L;    j = 1;    while(p-&gt;next&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!(p-&gt;next)||j&gt;i)        return ERROR;    q=p-&gt;next;    p-&gt;next=q-&gt;next;    *e = q-&gt;data;    free(q);    return OK;}void CreateList(LinkList &amp;L,int n){    LinkList p ;    int i;    srand(time(0));    L-&gt;next=NULL;    for(i=0;i&lt;n;i++){        p=(LinkList) malloc(sizeof(LNode));        p-&gt;data=rand()%100+1;        p-&gt;next=L-&gt;next;        L-&gt;next = p;    }}Status ClearList(LinkList &amp;L){    LinkList p,q;    p=L-&gt;next;    while(p){        q=p-&gt;next;        free(p);        p=q;    }    L-&gt;next=NULL;    return OK;}void unionList(LinkList &amp;L,LinkList L1){    LinkList p;    p=L;    L=p;    while(p-&gt;next){        p = p-&gt;next;    }    p-&gt;next=L1-&gt;next;}void outList(LinkList L){    L=L-&gt;next;    while(L!=NULL){        cout&lt;&lt;L-&gt;data&lt;&lt;&quot; &quot;;        L=L-&gt;next;    }    cout&lt;&lt;endl;}int main(){    LinkList p;    InitList(p);    CreateList(p,4);    outList(p);    cout &lt;&lt; &quot;请输入插入元素位置：&quot;;    int i;    cin&gt;&gt;i;    cout&lt;&lt;&quot;请输入插入元素:&quot;;    int e;    cin&gt;&gt;e;    ListInsert(p,i,e);    outList(p);    cout&lt;&lt;&quot;请输入删除元素位置:&quot;;    int j;    int num;    cin&gt;&gt;j;    ListDelete(p,j,&amp;num);    outList(p);    cout&lt;&lt;&quot;删除元素为:&quot;&lt;&lt;num&lt;&lt;endl;    cout &lt;&lt; &quot;表2:&quot;;    LinkList p1;    InitList(p1);    CreateList(p1,7);    outList(p1);    cout &lt;&lt; &quot;合并得:&quot;&lt;&lt;endl;    unionList(p,p1);    outList(p);    return 0;}</code></pre><h2 id="4-堆实现字符串"><a href="#4-堆实现字符串" class="headerlink" title="(4)堆实现字符串"></a>(4)堆实现字符串</h2><pre><code>//字符串的堆分配表示与实现#include&lt;iostream&gt;using namespace std;#define MAXISIZE 100#define ERROR 0#define OK 1typedef struct string {    char *str;    int length;}HeapString;//初始化串int initString(HeapString &amp;pH){    pH.str =&apos;\0&apos;;    pH.length = 0;    return OK;}//给指定的字符串赋值int strAssign(HeapString &amp;pH,char cstr[]){    int i;    int len;    if(pH.str)        free(pH.str);    for( i = 0;cstr[i]!=&apos;\0&apos;;i++);        len = i;    if(!cstr)    {        pH.length = 0;        pH.str = &apos;\0&apos;;    }    else    {        pH.str = (char * )malloc(len*sizeof(char));        if(!pH.str)        {            return ERROR;        }        for(i = 0;i&lt;len;i++)        {            pH.str[i] = cstr[i];        }        pH.length = len;    }    return OK;}//字符串的插入int strInsert(HeapString &amp;pH,int pos,HeapString S){    int i;    if(pos&lt;1||pos&gt;pH.length+1)        return ERROR;    pH.str = (char *)realloc(pH.str,(pH.length+S.length)*sizeof(char));    if(!pH.str)        return ERROR;    for(i = pH.length-1;i&gt;=pos-1;i--)    {        pH.str[i+S.length] = pH.str[i];    }    for(i = 0;i&lt;S.length;i++)    {        pH.str[i+pos-1]= S.str[i];    }    pH.length = pH.length+ S.length;    return OK;}//字符串的复制int strCopy(HeapString pH,HeapString &amp;T){    int i;    int len = pH.length;    T.str = (char * )malloc(len*sizeof(char));    if(!T.str)    {        return ERROR;    }    for( i = 0;i&lt;pH.length;i++)    {        T.str[i] = pH.str[i];    }    T.length = pH.length;    return OK;}//字符串的输出int outStr(HeapString pH){    int i;    for(i = 0;i&lt;pH.length;i++)    {        cout&lt;&lt;pH.str[i];    }    cout&lt;&lt;endl;    return OK;}int main(){    HeapString pH;    char cstr[MAXISIZE];    initString(pH);    cout&lt;&lt;&quot;请输入一个字符串:&quot;;    gets(cstr);    strAssign(pH,cstr);    cout &lt;&lt; &quot;串1:&quot;;    outStr(pH);    HeapString pH1;    initString(pH1);    strCopy(pH,pH1);    cout &lt;&lt; &quot;串2:&quot;;    outStr(pH1);    int pos;    cout&lt;&lt;&quot;请输入插入位置:&quot;;    cin&gt;&gt;pos;    strInsert(pH,pos,pH1);    cout&lt;&lt;&quot;插入操作后的串1:&quot;;    outStr(pH);    return 0;}</code></pre><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="(5)队列"></a>(5)队列</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define ERROR 0#define OK 1typedef int QElemType;typedef struct QNode{    QElemType data;    struct QNode *next;}QNode,*QueuePtr;typedef struct{    QueuePtr front,rear;}LinkQueue;int InitDL(LinkQueue &amp;Q){    Q.front = Q.rear=(QNode*)malloc(sizeof(QNode));    if(!Q.front)        return ERROR;    Q.front-&gt;next=NULL;    return OK;} int InDL(LinkQueue &amp;Q,QElemType e){    QueuePtr p;    p=(QueuePtr)malloc(sizeof(QNode));    if(!p)        return ERROR;    p-&gt;data=e;    p-&gt;next=NULL;    Q.rear-&gt;next=p;    Q.rear=p;    return OK;}int OutDL(LinkQueue &amp;Q,QElemType &amp;e){    QueuePtr p;    if(Q.front==Q.rear)        return ERROR;    p = Q.front-&gt;next;    e=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)        Q.rear=Q.front;    free(p);    return OK;}int getheadDL(LinkQueue Q,QElemType &amp;e){    e=Q.front-&gt;next-&gt;data;    return OK;}int prinftDL(LinkQueue Q){    QueuePtr p;    p=Q.front-&gt;next;    while(p){        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;  &quot;;        p=p-&gt;next;    }    cout &lt;&lt; endl;    return OK;}int main(){    LinkQueue Q;    InitDL(Q);    int m,n,e;    cout&lt;&lt;&quot;输入进队元素个数:&quot;;    cin&gt;&gt;m;    for(int i=0;i&lt;m;i++){        cout &lt;&lt; &quot;输入入队元素:&quot;;        cin&gt;&gt;n;        InDL(Q,n);    }    prinftDL(Q);    getheadDL(Q,e);    cout &lt;&lt; &quot;队头元素为:&quot;&lt;&lt;e&lt;&lt;endl;    OutDL(Q,e);        cout &lt;&lt; &quot;出队一次，出队元素为:&quot;&lt;&lt;e&lt;&lt;endl;    prinftDL(Q);    return 0;}</code></pre><p>循环队列:</p><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 5#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int QElemType;typedef struct{    QElemType data[MAXSIZE];    int front;    int rear;}SqQueue;//初始化int InitQueue(SqQueue *Q){    Q-&gt;front=0;    Q-&gt;rear=0;    return OK;}//返回长度int QueueLength(SqQueue Q){    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;}//插入元素e到队尾int EnQueue(SqQueue *Q,QElemType e){    if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)        return ERROR;    Q-&gt;data[Q-&gt;rear]=e;    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;    return OK;}//若队列不空，则删除队头元素，用e返回其值int DeQueue(SqQueue *Q,QElemType *e){    if(Q-&gt;front==Q-&gt;rear)        return ERROR;    *e=Q-&gt;data[Q-&gt;front];    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;    return OK;}//输出队列void outQueue(SqQueue Q){    int j = (Q.rear-1+MAXSIZE)%MAXSIZE;    for(int i=0;i&lt;QueueLength(Q);i++){        cout &lt;&lt; (Q.data[j])&lt;&lt;&quot; &quot;;        j=((--j) + MAXSIZE)%MAXSIZE;    }    cout &lt;&lt; endl;}int main(){    SqQueue sq;    InitQueue(&amp;sq);    int a;    int count;    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int i=0;i&lt;count;i++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    int e;    int num;    cout &lt;&lt; &quot;删除元素个数:&quot;;    cin &gt;&gt; num;    for(int n=0;n&lt;num;n++){        DeQueue(&amp;sq,&amp;e);        cout &lt;&lt; &quot;删除元素:&quot;&lt;&lt; e &lt;&lt; endl;            }    outQueue(sq);    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int m=0;m&lt;count;m++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    cout &lt;&lt; &quot;队列长度:&quot; &lt;&lt; QueueLength(sq) &lt;&lt;endl;    return 0;}</code></pre><h2 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="(6)二叉树"></a>(6)二叉树</h2><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;#define TRUE 1#define FALSE 0typedef struct BiTNode{    int data;    struct BiTNode *lchild,*rchild;}BiTNode,*BiTree;int SearchBST(BiTree T,int key,BiTree f,BiTree &amp;p){    if(T==NULL){        p = f;        return FALSE;    }    else if(key == T-&gt;data){        p=T;        return TRUE;    }    else if(key&lt;T-&gt;data)        return SearchBST(T-&gt;lchild,key,T,p);    else         return SearchBST(T-&gt;rchild,key,T,p);}int InsertBST(BiTree &amp;T,int key){    BiTree p,s;    if(!SearchBST(T,key,NULL,p))    {        s = (BiTree)malloc(sizeof(BiTree));        s-&gt;data=key;        s-&gt;lchild=s-&gt;rchild=NULL;        if(!p)            T=s;        else if(key&lt;p-&gt;data)            p-&gt;lchild=s;        else            p-&gt;rchild=s;        return TRUE;    }    else        return FALSE;}int Delete(BiTree *p){    BiTree q,s;    if((*p)-&gt;lchild==NULL&amp;&amp;(*p)-&gt;rchild==NULL)        *p=NULL;    else if((*p)-&gt;rchild==NULL){        q=(*p);        (*p)=(*p)-&gt;lchild;        free(q);    }    else if((*p)-&gt;lchild==NULL){        q=(*p);        (*p)=(*p)-&gt;rchild;        free(q);    }    else{        q=(*p);        s=(*p)-&gt;lchild;        while(s-&gt;rchild!=NULL){            q=s;            s=s-&gt;rchild;        }        (*p)-&gt;data=s-&gt;data;        if(!s-&gt;lchild){            if(q!=(*p))                (q)-&gt;rchild=s-&gt;lchild;            else                (q)-&gt;lchild=s-&gt;lchild;            }        free(s);    }    return TRUE;}int DeleteBST(BiTree *T,int key){    if(!*T)        return FALSE;    else{        if(key==(*T)-&gt;data)            return Delete(T);        else if(key&lt;(*T)-&gt;data)            return DeleteBST(&amp;(*T)-&gt;lchild,key);        else            return DeleteBST(&amp;(*T)-&gt;rchild,key);    }}int CreateBST(BiTree &amp;T){    int n;    cout &lt;&lt; &quot;输入树的结点个数:&quot;;    cin&gt;&gt;n;    T=NULL;    for(int i=0;i&lt;n;i++){        int m;        cout &lt;&lt; &quot;输入元素:&quot;;        cin&gt;&gt;m;        InsertBST(T,m);    }    return TRUE;}int main(){    BiTree T;    CreateBST(T);    BiTree f=NULL;    BiTree    p;    int key;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key;    if(SearchBST(T,key,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    int key1;    cout&lt;&lt;&quot;请输入删除元素:&quot;;    cin&gt;&gt;key1;    DeleteBST(&amp;T,key1);    int key2;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key2;    if(SearchBST(T,key2,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="7-图"><a href="#7-图" class="headerlink" title="(7)图"></a>(7)图</h2><pre><code>#include&lt;iostream&gt;#include &quot;DL.h&quot;using namespace std;#define ERROR 0#define OK 1#define MAXVEX 100#define INFINITY 65535typedef int Boolean;Boolean visited[MAXVEX];typedef char VertexType;typedef int EdgeType;//邻接矩阵typedef struct{    VertexType vexs[MAXVEX];    EdgeType arc[MAXVEX][MAXVEX];    int numVertexes,numEdges;}MGraph;void CreateMGraph(MGraph *G){    int i,j,k,w;    cout&lt;&lt;&quot;输入顶点数和边数:\n&quot;;    cin&gt;&gt;G-&gt;numVertexes;    cin&gt;&gt;G-&gt;numEdges;    for(i=0;i&lt;G-&gt;numVertexes;i++){        cout &lt;&lt; &quot;输入顶点:&quot;;        cin&gt;&gt;G-&gt;vexs[i];    }    for(i=0;i&lt;G-&gt;numVertexes;i++){        for(j=0;j&lt;G-&gt;numVertexes;j++){            G-&gt;arc[i][j]=INFINITY;        }    }    for(k=0;k&lt;G-&gt;numEdges;k++){        cout&lt;&lt;&quot;输入边（vi,vj）上的下标i，下标j和权w:&quot;&lt;&lt;endl;        cin&gt;&gt;i;        cin&gt;&gt;j;        cin&gt;&gt;w;        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}//深度优先void DFS(MGraph G,int i){    int j;    visited[i]=1;    cout&lt;&lt;G.vexs[i];    for(j=0;j&lt;G.numVertexes;j++)        if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j])            DFS(G,j);}void DFSTraverse(MGraph G){    int i;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    for(i=0;i&lt;G.numVertexes;i++)        if(!visited[i])            DFS(G,i);}//广度遍历void BFSTraverse(MGraph G){    int i,j;    LinkQueue Q;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    InitDL(Q);    for(i=0;i&lt;G.numVertexes;i++){        if(!visited[i]){            visited[i]=1;            cout&lt;&lt;G.vexs[i];            InDL(Q,i);            while(!DLEmpty(Q)){                OutDL(Q,i);                for(j=0;j&lt;G.numVertexes;j++){                    if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j]){                        visited[j]=1;                        cout &lt;&lt;G.vexs[j];                        OutDL(Q,j);                    }                }            }        }    }}//普里姆算法void MiniSpanTree_Prim(MGraph G){    int min,i,j,k;    int adjvex[MAXVEX];    int lowcost[MAXVEX];    lowcost[0]=0;    adjvex[0]=0;    for(i=1;i&lt;G.numVertexes;i++){        lowcost[i]=G.arc[0][i];        adjvex[i]=0;    }    for(i=1;i&lt;G.numVertexes;i++){        min = INFINITY;        j=1;        k=0;        while(j&lt;G.numVertexes){            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min){                min = lowcost[j];                k=j;            }            j++;        }        cout&lt;&lt;&quot;(&quot;&lt;&lt;adjvex[k]&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;)&quot;;        lowcost[k]=0;        for(j=1;j&lt;G.numVertexes;j++){            if(lowcost[j]!=0&amp;&amp;G.arc[k][j]&lt;lowcost[j]){                lowcost[j]=G.arc[k][j];                adjvex[j]=k;            }        }    }}int main(){    MGraph G;    CreateMGraph(&amp;G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;深度遍历&quot;&lt;&lt;endl;    DFSTraverse(G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;广度遍历&quot;&lt;&lt;endl;    BFSTraverse(G);     cout &lt;&lt; endl;    MiniSpanTree_Prim(G);    return 0;}</code></pre><hr><p>这些结构里也包含它们对应的遍历、插入、删除算法（<del>有些还未经优化</del>）….<br>当然这里还漏了很多基本结构类型，之后再补吧。<br>….</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些我早期学数据结构的时候用C++实现的代码。&lt;del&gt;指针在实现上比较方便&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;(1)栈&quot;&gt;&lt;/a&gt;(1)栈&lt;/h2&gt;&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA8新特性】</title>
    <link href="http://xfff.xyz/2018/10/13/%E3%80%90JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/13/【JAVA8新特性】/</id>
    <published>2018-10-13T06:35:59.026Z</published>
    <updated>2018-10-18T03:32:58.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Lambda表达式"><a href="#一-Lambda表达式" class="headerlink" title="(一)Lambda表达式"></a>(一)Lambda表达式</h2><p>java8新特性支持lambda表达式，能让代码看起来更简洁。</p><pre><code>interface Aaa{public void printz(String z);}//老版本    String t=&quot;gggg&quot;;    Aaa olda=new Aaa() {        @Override        public void printz(String z) {            // TODO Auto-generated method stub            System.out.println(z);        }    };    olda.printz(t);    //JAVA 8    //变量t在只后不得更改值，否则会报错，Local variable t defined in an enclosing    //scope must be final or effectively final    //lambda表达式内部只能调用final修饰的变量    Aaa zAaa=((String z)-&gt;System.out.println(z+&quot;qq&quot;+t));    zAaa.printz(t);    //老版本    Runnable oldrunnable=new Runnable() {        @Override        public void run() {            // TODO Auto-generated method stub            System.out.println(&quot;helloWorld&quot;);        }    };    new Thread(oldrunnable).start();    //java 8    new Thread(()-&gt;System.out.print(&quot;helloWorld8&quot;)).start();</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6ltopgbuj303k01q0hu.jpg" alt=""></p><h2 id="（二）方法引用"><a href="#（二）方法引用" class="headerlink" title="（二）方法引用"></a>（二）方法引用</h2><pre><code>      List&lt;Name&gt; names = new ArrayList&lt;Name&gt;();      names.add(new Name(&quot;Bob&quot;));      names.add(new Name(&quot;JECK&quot;));      names.add(new Name(&quot;AICE&quot;));      names.add(new Name(&quot;SENCE&quot;));      names.add(new Name(&quot;MONTE&quot;));      names.forEach(Name::printz);}class Name{    private String name;    public Name(String name) {        this.name=name;    }    public void printz() {        System.out.println(name);    }}`</code></pre><p>输出<br>Bob<br>JECK<br>AICE<br>SENCE<br>MONTE</p><h2 id="（三）函数式接口"><a href="#（三）函数式接口" class="headerlink" title="（三）函数式接口"></a>（三）函数式接口</h2><p>java8新提供了很多函数式接口，具体自行搜索，这里用其中一种做例子。</p><pre><code>    public static void method1(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate) {    for (Integer integer : list) {        if(predicate.test(integer)) {            System.out.print(integer+&quot; &quot;);        }    }}    List&lt;Integer&gt; nIntegers=Arrays.asList(1,2,3,4,5,6,7,8,9,10);    //如何获取list里大于5的元素呢？    //老方法    for (Integer integer : nIntegers) {        if(integer&gt;5) {            System.out.print(integer+&quot; &quot;);        }    }    System.out.println();    //运用java8提供的函数接口    method1(nIntegers, n-&gt;n&gt;5);    System.out.println();    //运用java8新特性省略方法，更简洁    nIntegers.stream().filter(n-&gt;n&gt;5).forEach(System.out::print);</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6nh9r48ij303p01h0gw.jpg" alt=""></p><h2 id="（四）默认方法"><a href="#（四）默认方法" class="headerlink" title="（四）默认方法"></a>（四）默认方法</h2><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个default关键字即可实现默认方法<br>    为了解决接口的修改与现有的实现不兼容的问题。</p><pre><code>public class Java8Test {@Testpublic void test() {    System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));    CarS car=new CarS();    car.ss();}public interface Car{default void haha() {    System.out.println(&quot;haha&quot;);}}public interface Bus{default void haha() {    System.out.println(&quot;heihei&quot;);}}public class CarS implements Car,Bus{public void ss() {    haha();}@Overridepublic void haha() {    // TODO Auto-generated method stub    Bus.super.haha();    Car.super.haha();}}}</code></pre><h2 id="（五）Stream"><a href="#（五）Stream" class="headerlink" title="（五）Stream"></a>（五）Stream</h2><p>java8引入一种新的抽象称做流Stream，能以声明的方式来处理数据。</p><p>下面代码实现了随机产生10个数，并把大于0的数输出。</p><pre><code>Random random=new Random();random.ints().limit(10).filter(n-&gt;n&gt;0).forEach(System.out::println);</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teiaq9ij305j01g0mq.jpg" alt=""></h2><p>下面代码对list里的字符串重复拼接输出到5条记录的数组里，并输出数组。            </p><pre><code>List&lt;String&gt; sList=Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);System.out.println(sList.stream().map(n-&gt;n+n).limit(5).collect(Collectors.toList()));</code></pre><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teszddcj306w00m0cp.jpg" alt=""></p><p>另外，parallelStream()相对于stream()，是流并行处理方式。<br>统计结果的收集器</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);                 IntSummaryStatistics  stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum());System.out.println(&quot;平均数 : &quot; + stats.getAverage());</code></pre><h2 id="（六）Optional类"><a href="#（六）Optional类" class="headerlink" title="（六）Optional类"></a>（六）Optional类</h2><p>一个可以存放null的容器，解决了nullpoint空指针问题。</p><pre><code>    Integer value1 = null;Integer value2 = 222;Optional&lt;Integer&gt; a = Optional.ofNullable(value1);  // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerExceptionOptional&lt;Integer&gt; b = Optional.of(value2);System.out.println(a.orElse(555));System.out.println(b.get());</code></pre><p>输出555<br>222<br>其中a.orElse为如果为空值则取555，b若为空则抛出异常。</p><h2 id="（七）Nashorn-JavaScript"><a href="#（七）Nashorn-JavaScript" class="headerlink" title="（七）Nashorn JavaScript"></a>（七）Nashorn JavaScript</h2><p>Nashorn 一个 javascript 引擎。</p><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p><p>实现了java和JavaScript互相调用。</p><pre><code>ScriptEngineManager  scriptEngineManager = new  ScriptEngineManager(); ScriptEngine  nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); String  name = &quot;Runoob&quot;; Integer  result = null; try  {  nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;); result = (Integer)   nashorn.eval(&quot;10 + 2&quot;);  }catch(ScriptException  e){   System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());    }     System.out.println(result.toString());</code></pre><p>输出Runoob  12</p><pre><code>var  BigDecimal  =  Java.type(&apos;java.math.BigDecimal&apos;); function calculate(amount, percentage)  { var result =  new  BigDecimal(amount).multiply(  new  BigDecimal(percentage)).divide(new  BigDecimal(&quot;100&quot;),  2,  BigDecimal.ROUND_HALF_EVEN);return result.toPlainString();  }  var result = calculate(568000000000000000023,13.9);  print(result);</code></pre><p>命令行运行上诉程序 : jjs xxx.js<br>结果：78952000000000002017.94</p><h2 id="（八）日期时间API"><a href="#（八）日期时间API" class="headerlink" title="（八）日期时间API"></a>（八）日期时间API</h2><p>旧版java中，日期时间相关的类存在诸多问题：<strong>非线程安全</strong>、<strong>设计差</strong>（java.util和java.sql中日期类名相同，但对应内容不一致，前者多了具体时间）、<strong>时区处理麻烦</strong>。</p><p>java8在java.time包里引入了很多新的API：local、 zoned….</p><pre><code>    // 获取当前的日期时间LocalDateTime currentTime = LocalDateTime.now();System.out.println(&quot;LocalDateTime.now: &quot; + currentTime);LocalDate date1 = currentTime.toLocalDate();System.out.println(&quot;localdatetime.tolocaldate=localdate: &quot; + date1);Month month = currentTime.getMonth();int day = currentTime.getDayOfMonth();int seconds = currentTime.getSecond();System.out.println(&quot;localdatetime.getmonth=month: &quot; + month +&quot;, localdatetime.getdayofmonth=int: &quot; + day +&quot;, localdatetime.getseconds=int: &quot; + seconds);//用当前时间，修改天数和年份LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);System.out.println(&quot;date2: &quot; + date2);//设置一个日期对象的值LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);System.out.println(&quot;date3: &quot; + date3);//设置时间的值LocalTime date4 = LocalTime.of(22, 15);System.out.println(&quot;date4: &quot; + date4);//用另一种格式设置时间LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);System.out.println(&quot;date5: &quot; + date5);</code></pre><p>输出：LocalDateTime.now: 2018-10-13T20:14:29.390<br>localdatetime.tolocaldate=localdate: 2018-10-13<br>localdatetime.getmonth=month: OCTOBER, localdatetime.getdayofmonth=int: 13, localdatetime.getseconds=int: 29<br>date2: 2012-10-10T20:14:29.390<br>date3: 2014-12-12<br>date4: 22:15<br>date5: 20:15:30</p><p><strong>时区相关:</strong></p><pre><code>    ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);System.out.println(&quot;date1: &quot; + date1);ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);System.out.println(&quot;ZoneId: &quot; + id);ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone);ZonedDateTime dateTime=ZonedDateTime.now(currentZone);System.out.println(&quot;当前时区时间:&quot;+dateTime);</code></pre><p>输出：<br>date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]<br>ZoneId: Europe/Paris<br>当期时区: Asia/Shanghai<br>当前时区时间:2018-10-13T20:20:45.466+08:00[Asia/Shanghai]</p><hr><p>时间相关的计算:计算上个月的今天是周几?</p><pre><code>LocalDateTime currentTime = LocalDateTime.now();currentTime=currentTime.withMonth(currentTime.getMonthValue()-1);System.out.println(currentTime.getDayOfWeek());</code></pre><p>结果:THURSDAY</p><h2 id="（九）Base64"><a href="#（九）Base64" class="headerlink" title="（九）Base64"></a>（九）Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><pre><code>   try {   // 使用基本编码   String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 比那么字符串 (基本) :&quot; + base64encodedString);   // 解码   byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);   System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));   base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);   StringBuilder stringBuilder = new StringBuilder();   for (int i = 0; i &lt; 10; ++i) {      stringBuilder.append(UUID.randomUUID().toString());   }   byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);   String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);   System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);   byte[] aString=Base64.getMimeDecoder().decode(mimeEncodedString);   String aString2=new String(aString,&quot;utf-8&quot;);   System.out.println(aString2);}catch(UnsupportedEncodingException e){   System.out.println(&quot;Error :&quot; + e.getMessage());}</code></pre><p>结果:<br>Base64 比那么字符串 (基本) :cnVub29iP2phdmE4<br>原始字符串: runoob?java8<br>Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=<br>Base64 编码字符串 (MIME) :ZDEzM2E2MGEtNTllMS00ZGI5LWE5OWItNDFkNWMwZWU4ZWRlNzVkMmM5NTctMjFmNi00NTM3LWE2<br>NjQtMTUwNmJkOGU0ZWZjNDk0YjEyMTctM2RhZi00NDQ0LTgzNGItYzE0ZWFiY2ZhZWUxYzUxYjNj<br>N2MtMjQ0My00Y2UwLTlhZWItNjE0M2EzZDUzNmQ5OGNjMTgxZTgtMjg3MS00ZDY0LTg0MDktZTgw<br>MGE2OTNlZDdiM2QyOTBiNmQtYTUyYi00NzY3LWFjZmYtMWM0ODRiOGNmNGQzZjhkZjQ0MDItOWMw<br>Ni00YjMzLWEyZGUtZDcxYzc4N2NiZjBkMzQ2ZTY1OWQtMjU1OS00ZDVjLWE3ZjktMDQyMWNmYmY4<br>MjVlMmNhMDhkZGItMDU5OC00Yjk1LTg2ZjktNTdmYWRjZDBjMDBiOWYyYmMzYWMtZDAwNi00ZThk<br>LTlhNjQtNTU3OTcxODk1NjZi<br>d133a60a-59e1-4db9-a99b-41d5c0ee8ede75d2c957-21f6-4537-a664-1506bd8e4efc494b1217-3daf-4444-834b-c14eabcfaee1c51b3c7c-2443-4ce0-9aeb-6143a3d536d98cc181e8-2871-4d64-8409-e800a693ed7b3d290b6d-a52b-4767-acff-1c484b8cf4d3f8df4402-9c06-4b33-a2de-d71c787cbf0d346e659d-2559-4d5c-a7f9-0421cfbf825e2ca08ddb-0598-4b95-86f9-57fadcd0c00b9f2bc3ac-d006-4e8d-9a64-55797189566b</p><hr><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Lambda表达式&quot;&gt;&lt;a href=&quot;#一-Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;(一)Lambda表达式&quot;&gt;&lt;/a&gt;(一)Lambda表达式&lt;/h2&gt;&lt;p&gt;java8新特性支持lambda表达式，能让代码看起来更简洁。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="java8" scheme="http://xfff.xyz/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】工作流程理解（一）</title>
    <link href="http://xfff.xyz/2018/10/11/%E3%80%90springmvc%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xfff.xyz/2018/10/11/【springmvc】工作流程理解（一）/</id>
    <published>2018-10-11T06:52:21.451Z</published>
    <updated>2018-10-17T15:38:01.179Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用户通过URL发送请求，到达<strong>DispatcherServlet-前端(核心)控制器</strong>(通过在web.xml中配置)</li><li><strong>DispatcherServlet</strong>把请求转发给<strong>HandlerMapper-处理器映射器</strong>（在springmvc配置文件中注册）</li><li><strong>HandlerMapper</strong>根据请求返回映射的<strong>controller控制器对象链</strong>给<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>把<strong>controller</strong>对象处理链转发给<strong>HandlerAdapter处理器适配器（在springmvc配置文件中注册）</strong></li><li><strong>HandlerAdapter</strong>根据请求通知<strong>controller处理器</strong>应该实现的方法（配置扫描、注解）</li><li><strong>controller</strong>调用对应的方法，返回<strong>ModelAndView</strong>对象（配置注解）</li><li>经<strong>HandlerAdapter</strong>又发送回<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>对象发送给<strong>ViewResolver</strong>视图解析器（在springmvc配置文件中配置）</li><li><strong>ViewResolver</strong>对传来的<strong>Model</strong>（数据..）和<strong>View</strong>（对应的页面..）进行渲染返回给<strong>DispatcherServlet</strong></li><li><strong>Response</strong> 响应给用户</li></ol><hr><p>上诉为自己总结，可能有些错误，是我初学理解不够深刻。</p><hr><p><strong><em>网图:</em></strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw4bmgbq81j30pj09h75h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;用户通过URL发送请求，到达&lt;strong&gt;DispatcherServlet-前端(核心)控制器&lt;/strong&gt;(通过在web.xml中配置)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;把请求转发给&lt;strong&gt;
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>【好用的工具合集】</title>
    <link href="http://xfff.xyz/2018/10/10/%E3%80%90%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/10/【好用的工具合集】/</id>
    <published>2018-10-10T15:15:28.314Z</published>
    <updated>2018-10-24T17:34:37.082Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="项目开发类："><a href="#项目开发类：" class="headerlink" title="项目开发类："></a>项目开发类：</h2><ul><li><a href="https://www.cnblogs.com/xdp-gacl/p/4233289.html" target="_blank" rel="noopener">maven &gt;&gt;struts项目示例及插件</a></li><li><a href="#">git</a></li><li><a href="http://www.w3school.com.cn/tiy/t.asp?f=ajax_xml" target="_blank" rel="noopener">ajax普通请求示例</a></li><li><a href="https://blog.csdn.net/thinkscape/article/details/7467153" target="_blank" rel="noopener">ajax规范请求示例</a></li><li><a href="https://www.cnblogs.com/fjsnail/p/3491033.html" target="_blank" rel="noopener">springmvc上传文件</a>+<a href="https://www.cnblogs.com/hahaxiaoyu/p/5102900.html" target="_blank" rel="noopener">读取</a></li><li><a href="https://www.cnblogs.com/sunniest/p/4555801.html" target="_blank" rel="noopener">springmvc操作集合</a></li></ul><hr><h2 id="图形设计类"><a href="#图形设计类" class="headerlink" title="图形设计类:"></a>图形设计类:</h2><ul><li><a href="https://www.runoob.com/try/bootstrap/layoutit/#" target="_blank" rel="noopener">bootstrapHtml简易设计工具</a></li><li><a href="http://color.oulu.me/" target="_blank" rel="noopener">颜色渐变</a></li><li><a href="https://pan.baidu.com/s/1eQiXZKu" target="_blank" rel="noopener">截图工具FastStone Capture</a></li><li><a href="http://www.jq22.com/webide/" target="_blank" rel="noopener">jquery在线编辑器</a></li></ul><hr><h2 id="github："><a href="#github：" class="headerlink" title="github："></a>github：</h2><ul><li><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">hexo</a>+<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">hexo</a></li><li><a href="https://www.cnblogs.com/YingYue/p/5894680.html" target="_blank" rel="noopener">git命令集合</a></li></ul><hr><h2 id="Markdown设计："><a href="#Markdown设计：" class="headerlink" title="Markdown设计："></a>Markdown设计：</h2><ul><li><a href="https://stackedit.io/app#" target="_blank" rel="noopener">Stackedit编辑器</a></li><li><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf" target="_blank" rel="noopener">图床-用来插入图片</a></li></ul><hr><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具:"></a>其他工具:</h2><ul><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴 Tampermonkey</a>+<a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">脚本资源</a></li><li><a href="https://chrome.google.com/webstore/detail/isearch/jmalocgcmlilelcdekhigpadlhfbjpnp" target="_blank" rel="noopener">搜索引擎相关</a></li><li><a href="https://blog.csdn.net/wanwuguicang/article/details/80716178" target="_blank" rel="noopener">chrome插件伴侣</a></li><li><a href="https://pan.baidu.com/s/1XII8zxn5HAAcW2-4dLWGAg" target="_blank" rel="noopener">google学术搜索</a><br><del>这些链接咋不发光啊？？</del></li></ul><hr><p>持续更新……..<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3kxn6swfj31hc0u0wgk.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;项目开发类：&quot;&gt;&lt;a href=&quot;#项目开发类：&quot; class=&quot;headerlink&quot; title=&quot;项目开发类：&quot;&gt;&lt;/a&gt;项目开发类：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xdp-gacl/p
      
    
    </summary>
    
      <category term="tools" scheme="http://xfff.xyz/categories/tools/"/>
    
    
      <category term="tools" scheme="http://xfff.xyz/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>【Error集合】</title>
    <link href="http://xfff.xyz/2018/10/10/%E3%80%90Error%E9%9B%86%E5%90%88%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/10/【Error集合】/</id>
    <published>2018-10-10T14:50:11.441Z</published>
    <updated>2018-10-17T15:39:38.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h2><ul><li><a href="https://www.cnblogs.com/zhaideyou/p/5964509.html" target="_blank" rel="noopener">Struts2配置问题java.lang.ClassNotFoundException:org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</a></li><li><a href="https://blog.csdn.net/li7134600/article/details/78071785" target="_blank" rel="noopener">动态通配符配置Action出错</a>  </li><li><a href="https://blog.csdn.net/T_just_for_tomorrow/article/details/79504049" target="_blank" rel="noopener">动态调用action</a>  </li><li><a href="https://blog.csdn.net/cgy_workman/article/details/40862993" target="_blank" rel="noopener">关于struts2配置struts.devMode问题解释</a>  </li></ul><hr><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li><a href="https://blog.csdn.net/H_anxx/article/details/78983591" target="_blank" rel="noopener">org.springframework.web.context.ContextLoaderListener解决方法</a></li></ul><hr><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ul><li><a href="https://blog.csdn.net/u010504064/article/details/47832721" target="_blank" rel="noopener">关于Hibernate一对多关系加载方式fetch配置</a></li></ul><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><a href="https://zhidao.baidu.com/question/1894863609449400500.html" target="_blank" rel="noopener">JS中字符串与数字进行算术运算eval使用注意</a></li></ul><hr><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li><a href="https://www.cnblogs.com/bsn-huang/p/3933442.html" target="_blank" rel="noopener">githubSSHkey添加</a></li><li><a href="https://www.cnblogs.com/sheldonxu/archive/2012/09/17/2688281.html" target="_blank" rel="noopener">伴随问题</a></li></ul><hr><p>持续更新…….<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3j95uqblj31hc0u0b29.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts2&quot;&gt;&lt;a href=&quot;#Struts2&quot; class=&quot;headerlink&quot; title=&quot;Struts2&quot;&gt;&lt;/a&gt;Struts2&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaideyou/p
      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="errors" scheme="http://xfff.xyz/tags/errors/"/>
    
  </entry>
  
  <entry>
    <title>win10使用hexo搭建blog</title>
    <link href="http://xfff.xyz/2018/10/09/win10%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/"/>
    <id>http://xfff.xyz/2018/10/09/win10使用hexo搭建blog/</id>
    <published>2018-10-09T15:49:42.936Z</published>
    <updated>2018-10-17T15:38:58.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习搭建ing…"><a href="#练习搭建ing…" class="headerlink" title="练习搭建ing….."></a>练习搭建ing…..</h2><p><strong>从下列各个站点<del>边看边搭</del>…</strong></p><ul><li><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">[用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！]</a></li><li><p><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">[hexo边搭边记]</a></p><p>最後根目録下面的_config.yml文件里的deploy的type一定要設置為git~~~<br>這個問題是真磨人。。。</p></li></ul><hr><p> 模版TKL来源…</p><ul><li><p><a href="https://github.com/SuperKieran/TKL" target="_blank" rel="noopener">[TKL]</a></p></li><li><p><a href="https://github.com/SuperKieran/hexo-generator-search-zip" target="_blank" rel="noopener">[hexo搜索工具]</a></p></li></ul><hr><p><strong>模版很好看，感谢作者~</strong></p><p><del>其实这篇文章只是为了试试能不能同步到github主页hhh</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;练习搭建ing…&quot;&gt;&lt;a href=&quot;#练习搭建ing…&quot; class=&quot;headerlink&quot; title=&quot;练习搭建ing…..&quot;&gt;&lt;/a&gt;练习搭建ing…..&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;从下列各个站点&lt;del&gt;边看边搭&lt;/del&gt;…&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="hexo主题" scheme="http://xfff.xyz/categories/hexo%E4%B8%BB%E9%A2%98/"/>
    
    
      <category term="hexo" scheme="http://xfff.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xfff.xyz/2018/10/09/hello-world/"/>
    <id>http://xfff.xyz/2018/10/09/hello-world/</id>
    <published>2018-10-09T13:14:11.965Z</published>
    <updated>2018-10-09T13:14:11.965Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
