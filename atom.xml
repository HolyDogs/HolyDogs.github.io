<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XFF&#39;s blog</title>
  
  <subtitle>BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xfff.xyz/"/>
  <updated>2019-03-20T09:13:12.733Z</updated>
  <id>http://xfff.xyz/</id>
  
  <author>
    <name>XFF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【java】日志打印</title>
    <link href="http://xfff.xyz/2019/03/20/%E3%80%90java%E3%80%91%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0/"/>
    <id>http://xfff.xyz/2019/03/20/【java】日志打印/</id>
    <published>2019-03-20T08:49:25.000Z</published>
    <updated>2019-03-20T09:13:12.733Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中，想打印某些值的信息时</p><p>总是Syso=&gt;System.out.pringln(xxx)</p><p>然后在代码规范里看到了，禁止使用这种方式打印信息，可以选择日志工具打印查看</p><p>日常使用的工具有log4j、logback、slf4j</p><p>log4j必须配置配置文件log4j.properties，类似下面这样，可以指定打印级别</p><pre><code># Configure logging for testing: optionally with log filelog4j.rootLogger=INFO, stdout # log4j.rootLogger=WARN, stdout, logfilelog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.logfile=org.apache.log4j.FileAppenderlog4j.appender.logfile.File=target/spring.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre><p>一般log4j会和commons-logging搭配使用</p><p>commons-logging提供一个统一的日志接口，简单了操作，同时避免项目与某个日志实现系统紧密a耦合很贴心的帮我们自动选择适当的日志实现系统（这一点非常好！）它甚至不需要配置</p><p>在使用时，会从classpath查找commons-logging.properties文件</p><p>若找不到，则在查找是否已定义系统环境变量org.apache.commons.logging.Log，找到则使用其定义的Log实现类<br>这样使用</p><pre><code>private static Log log = LogFactory.getLog(YouClassName. class );</code></pre><hr><h2 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h2><p>主要还是用这个打印日志吧<br>不需要配置文件，只需要依赖slf4j-api即可</p><p>然后使用时直接</p><pre><code>private static final Logger LOGGER = LoggerFactory.getLogger(CheckCodeUtills.class);</code></pre><p>然后使用</p><pre><code>LOGGER.info、warn、error(xxxx)</code></pre><p>之类的</p><h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>只需要在需要使用的类上加上</p><pre><code>@Slf4j</code></pre><p>然后在使用时</p><pre><code>log.info、warn....(xxxx)</code></pre><p>即可</p><p>另外下面这篇博客说明了slf4j和log4j的好坏</p><blockquote><p><a href="https://www.oschina.net/translate/why-use-sl4j-over-log4j-for-logging" target="_blank" rel="noopener">https://www.oschina.net/translate/why-use-sl4j-over-log4j-for-logging</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常开发中，想打印某些值的信息时&lt;/p&gt;
&lt;p&gt;总是Syso=&amp;gt;System.out.pringln(xxx)&lt;/p&gt;
&lt;p&gt;然后在代码规范里看到了，禁止使用这种方式打印信息，可以选择日志工具打印查看&lt;/p&gt;
&lt;p&gt;日常使用的工具有log4j、logback、slf4
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>【shiro】shiro整合redis保存session以及RememberMe探索</title>
    <link href="http://xfff.xyz/2019/03/20/%E3%80%90shiro%E3%80%91shiro%E6%95%B4%E5%90%88redis%E4%BF%9D%E5%AD%98session%E4%BB%A5%E5%8F%8ARememberMe%E6%8E%A2%E7%B4%A2/"/>
    <id>http://xfff.xyz/2019/03/20/【shiro】shiro整合redis保存session以及RememberMe探索/</id>
    <published>2019-03-20T02:10:36.000Z</published>
    <updated>2019-03-20T02:39:00.728Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节的项目中<br>增加改进</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;    &lt;version&gt;2.4.2.1-RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.46&lt;/version&gt;&lt;/dependency&gt;</code></pre><hr><h2 id="增加如下配置"><a href="#增加如下配置" class="headerlink" title="增加如下配置"></a>增加如下配置</h2><p>shiroConfig中</p><pre><code>public RedisManager redisManager(){    RedisManager redisManager = new RedisManager();    redisManager.setHost(&quot;localhost&quot;);    redisManager.setPort(6379);    //缓存过期时间    redisManager.setExpire(1800);    redisManager.setTimeout(0);    //redisManager.setPassword();    return redisManager;}@Beanpublic RedisCacheManager cacheManager(){    //使用的是org.crazycake包下的rediscachemanager    RedisCacheManager redisCacheManager = new RedisCacheManager();    redisCacheManager.setRedisManager(redisManager());    return redisCacheManager;}@Beanpublic RedisSessionDAO redisSessionDAO(){    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();    redisSessionDAO.setRedisManager(redisManager());    return redisSessionDAO;}@Beanpublic DefaultWebSessionManager sessionManager(){    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();    sessionManager.setSessionDAO(redisSessionDAO());    return sessionManager;}</code></pre><h2 id="注入SecurityManager"><a href="#注入SecurityManager" class="headerlink" title="注入SecurityManager"></a>注入SecurityManager</h2><pre><code>@Bean(name = &quot;securityManager&quot;)public SecurityManager securityManager(){    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();    securityManager.setRealm(getRealm());    securityManager.setCacheManager(cacheManager());    securityManager.setSessionManager(sessionManager());    return securityManager;}</code></pre><hr><p>启动redis服务测试</p><p>登陆后能在redis库中看到新增的shirosession字段</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g1921b2jsej30ag01emwz.jpg" alt=""></p><hr><h2 id="Remember-Me功能探索"><a href="#Remember-Me功能探索" class="headerlink" title="Remember Me功能探索"></a>Remember Me功能探索</h2><p>默认情况下登陆时附带的Remember me值为false</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g1923btxxyj30kq06it96.jpg" alt=""></p><p>手动设置为true后，打开浏览器登陆后</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g1924eviirj30cv01w745.jpg" alt=""></p><p>能在cookie中看到多出了一个rememberMe字段</p><p>实际上并没有发挥效果，需要更改其他的配置</p><p>具体下面这篇博客讲的很清楚</p><blockquote><p><a href="https://blog.csdn.net/nsrainbow/article/details/36945267/" target="_blank" rel="noopener">https://blog.csdn.net/nsrainbow/article/details/36945267/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一节的项目中&lt;br&gt;增加改进&lt;/p&gt;
&lt;h2 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;gro
      
    
    </summary>
    
      <category term="shiro" scheme="http://xfff.xyz/categories/shiro/"/>
    
    
      <category term="redis" scheme="http://xfff.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【shiro】SpringBoot整合shiro实例</title>
    <link href="http://xfff.xyz/2019/03/19/%E3%80%90shiro%E3%80%91SpringBoot%E6%95%B4%E5%90%88shiro%E5%AE%9E%E4%BE%8B/"/>
    <id>http://xfff.xyz/2019/03/19/【shiro】SpringBoot整合shiro实例/</id>
    <published>2019-03-19T08:59:37.000Z</published>
    <updated>2019-03-19T09:41:08.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>粗暴一点，上图<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g187okinhoj309e0i20t8.jpg" alt=""></p><p>展开是这样的<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g187q7hnv7j30900dtaad.jpg" alt=""></p><p>由于我把用户角色和密码放在了一张用户表上，这里Role类以及Mapper并没有使用</p><p>另外为了只是简单的测试，没有加上权限操作字段，使用表如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g187vn7di9j308o02udfo.jpg" alt=""></p><hr><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><pre><code>&lt;dependencies&gt;    //controller层需要    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    //数据库连接    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.13&lt;/version&gt;    &lt;/dependency&gt;    //mybatis整合    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    //测试    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    //shiro整合    &lt;dependency&gt;        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;        &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    //lombok使用    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.4&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><hr><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>log4j.properties</p><pre><code># Configure logging for testing: optionally with log filelog4j.rootLogger=info, stdout  # log4j.rootLogger=WARN, stdout, logfilelog4j.appender.stdout=org.apache.log4j.ConsoleAppender  log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n  log4j.appender.logfile=org.apache.log4j.FileAppender  log4j.appender.logfile.File=target/spring.log  log4j.appender.logfile.layout=org.apache.log4j.PatternLayout  log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre><p>application.properties</p><pre><code>server.port=8080  spring.datasource.url=jdbc:mysql://localhost:3306/shirodemo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;&amp;serverTimezone=GMT&amp;allowPublicKeyRetrieval=true  spring.datasource.username=root  spring.datasource.password=olonn  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver  mybatis.mapper-locations=classpath:mapper/*.xml</code></pre><p>UserMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.UserMapper&quot;&gt;    &lt;!-- 开启二级缓存 --&gt;    &lt;!--    &lt;cache type=&quot;org.mybatis.caches.ehcache.LoggingEhcache&quot;/&gt;--&gt;    &lt;select id=&quot;selectPasswordByName&quot; resultType=&quot;java.lang.String&quot;&gt;        SELECT password FROM USER WHERE username = #{name}    &lt;/select&gt;    &lt;select id=&quot;selectRoleByName&quot; resultType=&quot;java.lang.String&quot;&gt;        SELECT role FROM USER WHERE username = #{name}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><hr><h2 id="bo类"><a href="#bo类" class="headerlink" title="bo类"></a>bo类</h2><p>User</p><pre><code>@Datapublic class User implements Serializable {    private int id;    private String username;    private String password;    private String role;}</code></pre><h2 id="shiro配置"><a href="#shiro配置" class="headerlink" title="shiro配置"></a>shiro配置</h2><p>ShiroConfig<br>这是shiro配置的核心，我们要把自定义realm、加密方式等注入securityManager对象，然后把该对象放入shiroFilterFactoryBean，并配置请求的url需要用户登陆或者有无权限，权限信息为<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188f9apoqj30qv0ckq4i.jpg" alt=""></p><pre><code>@Configurationpublic class ShiroConfig {    private static final Logger LOGGER = LoggerFactory.getLogger(ShiroConfig.class);    @Bean    public UserRealm getRealm(){        return new UserRealm();    }    @Bean(name = &quot;securityManager&quot;)    public SecurityManager securityManager(){        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        securityManager.setRealm(getRealm());        return securityManager;    }    //这里可以进行加密方式配置    @Bean    public HashedCredentialsMatcher credentialsMatcher(){        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();        hashedCredentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);        hashedCredentialsMatcher.setHashIterations(3);        return hashedCredentialsMatcher;    }    @Bean    public ShiroFilterFactoryBean shiroFilter(@Qualifier(&quot;securityManager&quot;) SecurityManager securityManager){        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        shiroFilterFactoryBean.setSecurityManager(securityManager);        //setLoginUrl 如果不设置值，默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 或 &quot;/login&quot; 映射        shiroFilterFactoryBean.setLoginUrl(&quot;/notLogin&quot;);        //无权限时的跳转        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/noRole&quot;);        //设置拦截器        Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();        //游客，开发权限        filterChainDefinitionMap.put(&quot;/guest/**&quot;,&quot;anon&quot;);        //用户        filterChainDefinitionMap.put(&quot;/user/**&quot;,&quot;roles[user]&quot;);        //管理员        filterChainDefinitionMap.put(&quot;/admin/**&quot;,&quot;roles[admin]&quot;);        //登陆接口        filterChainDefinitionMap.put(&quot;/login/**&quot;,&quot;anon&quot;);        //拦截所有其他接口，必须放在所有权限验证的最后，不然会把所有url全部拦截        filterChainDefinitionMap.put(&quot;/**&quot;,&quot;authc&quot;);        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        LOGGER.info(&quot;shiro拦截工厂类启动成功&quot;);        return shiroFilterFactoryBean;    }}</code></pre><h2 id="Mapper接口（一般要用service操作）"><a href="#Mapper接口（一般要用service操作）" class="headerlink" title="Mapper接口（一般要用service操作）"></a>Mapper接口（一般要用service操作）</h2><pre><code>@Mapperpublic interface UserMapper {    /**     * fetch data by rule id     *     * @param username     * @return Result&lt;String&gt;     */    String selectPasswordByName(@Param(&quot;name&quot;) String username);    /**     * fetch data by rule id     *     * @param username     * @return Result&lt;String&gt;     */    String selectRoleByName(@Param(&quot;name&quot;) String username);}</code></pre><h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><pre><code>@Componentpublic class UserRealm extends AuthorizingRealm {    private static final Logger LOGGER = LoggerFactory.getLogger(UserRealm.class);    @Autowired    private UserMapper userMapper;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        LOGGER.info(&quot;-----权限验证-----&quot;);        String username = (String) principals.getPrimaryPrincipal();        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        info.addRole(userMapper.selectRoleByName(username));        return info;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        LOGGER.info(&quot;-----身份验证-----&quot;);        String username = (String) token.getPrincipal();        String password = userMapper.selectPasswordByName(username);        if (null==password){            throw new AccountException(&quot;用户名不正确&quot;);        }        return new SimpleAuthenticationInfo(username,password,getName());    }    private ByteSource generateSalt(String salt){        return ByteSource.Util.bytes(salt);    }}</code></pre><p>为了简单示例，没有加加密操作，另外登陆失败的异常没有处理</p><h2 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h2><p>LoginController</p><pre><code>@RestControllerpublic class LoginController {    private static HashMap&lt;String,String&gt; myp = new HashMap&lt;&gt;(16);    @RequestMapping(&quot;/notLogin&quot;)    @ResponseBody    public HashMap&lt;String, String&gt; notlogin(){        myp.put(&quot;hello&quot;,&quot;world&quot;);        return myp;    }    @RequestMapping(&quot;/login/{username}/{password}&quot;)    @ResponseBody    public HashMap&lt;String, String&gt; login(@PathVariable(&quot;username&quot;)String username,@PathVariable(&quot;password&quot;)String password){        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken(username,password);        subject.login(token);        myp.put(&quot;for&quot;,&quot;login&quot;);        return myp;    }    @RequestMapping(&quot;/noRole&quot;)    @ResponseBody    public HashMap&lt;String, String&gt; noRole(){        myp.put(&quot;for&quot;,&quot;login&quot;);        return myp;    }}</code></pre><p>UserController</p><pre><code>@RestControllerpublic class UserController {    private static HashMap&lt;String ,String &gt; mymap = new HashMap&lt;&gt;(16);    @RequestMapping(&quot;/admin/{admin}&quot;)    @ResponseBody    public HashMap admin(@PathVariable(&quot;admin&quot;)String admin){        mymap.put(&quot;admin&quot;,admin);        return mymap;    }    @RequestMapping(&quot;/user/{user}&quot;)    @ResponseBody    public HashMap user(@PathVariable(&quot;user&quot;)String user){        mymap.put(&quot;user&quot;,user);        return mymap;    }    @RequestMapping(&quot;/guest/{guest}&quot;)    @ResponseBody    public HashMap guest(@PathVariable(&quot;guest&quot;)String guest){        mymap.put(&quot;guest&quot;,guest);        return mymap;    }}</code></pre><hr><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>上面代码算是全部写完了，接下来验证</p><p>运行springboot启动类</p><p>访问<a href="http://localhost:8080/xxxxxx" target="_blank" rel="noopener">http://localhost:8080/xxxxxx</a><br>自动跳转到/notLogin<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188jn6zyhj30dm04h3yh.jpg" alt=""></p><p>访问<a href="http://localhost:8080/guest/xxxx" target="_blank" rel="noopener">http://localhost:8080/guest/xxxx</a><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188kz7r0gj30ck02q748.jpg" alt=""></p><p>访问<a href="http://localhost:8080/user/zzzz同样跳转到notLogin" target="_blank" rel="noopener">http://localhost:8080/user/zzzz同样跳转到notLogin</a></p><p>访问<a href="http://localhost:8080/login/ccc/123" target="_blank" rel="noopener">http://localhost:8080/login/ccc/123</a><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188ngkd4ij30h3076jru.jpg" alt=""><br>找不到用户，后台抛出异常未处理</p><p>访问<a href="http://localhost:8080/login/bbb/123" target="_blank" rel="noopener">http://localhost:8080/login/bbb/123</a><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188pbjdvej30br03dt8o.jpg" alt=""><br>登陆成功</p><p>然后访问<a href="http://localhost:8080/user/我登陆了" target="_blank" rel="noopener">http://localhost:8080/user/我登陆了</a><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g188qiwempj30ae037weg.jpg" alt=""><br>可以成功访问</p><p>访问<a href="http://localhost:8080/admin/mmmm" target="_blank" rel="noopener">http://localhost:8080/admin/mmmm</a><br>自动跳转到/noRole</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h1&gt;&lt;p&gt;粗暴一点，上图&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sly1g1
      
    
    </summary>
    
      <category term="shiro" scheme="http://xfff.xyz/categories/shiro/"/>
    
    
      <category term="springboot" scheme="http://xfff.xyz/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>【shiro】初识shiro身份与权限验证</title>
    <link href="http://xfff.xyz/2019/03/18/%E3%80%90shiro%E3%80%91%E5%88%9D%E8%AF%86shiro%E8%BA%AB%E4%BB%BD%E4%B8%8E%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81/"/>
    <id>http://xfff.xyz/2019/03/18/【shiro】初识shiro身份与权限验证/</id>
    <published>2019-03-18T12:10:40.000Z</published>
    <updated>2019-03-18T13:00:40.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h2><pre><code>&lt;dependencies&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;       &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;       &lt;version&gt;1.3.2&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;commons-logging&lt;/groupId&gt;       &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;   &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;       &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;       &lt;version&gt;1.3&lt;/version&gt;   &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;       &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;       &lt;version&gt;1.7.25&lt;/version&gt;   &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>log4j.properties</p><pre><code># Configure logging for testing: optionally with log file  log4j.rootLogger=WARN, stdout  # log4j.rootLogger=WARN, stdout, logfile  log4j.appender.stdout=org.apache.log4j.ConsoleAppender  log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n  log4j.appender.logfile=org.apache.log4j.FileAppender  log4j.appender.logfile.File=target/spring.log  log4j.appender.logfile.layout=org.apache.log4j.PatternLayout  log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre><p>myshiro.ini （后期可以通过其他方式配置）</p><pre><code>[main]  myRealm=MyDefaultRealm  securityManager.realms=$myRealm</code></pre><p>MyDefaultRealm是自定义的Realm对象包全路径</p><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过shiro登陆验证的流程，如下图<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g1782tpgahj30df08qgn5.jpg" alt=""></p><p>我们先通过<strong>Subject</strong>，这是一个门面对象去“迎接”登陆的用户的信息，<br>然后把这些信息交给Shiro的核心<strong>SecurityManager</strong>的核心管理</p><p><strong>Realm</strong>数据源,用于保存从数据库获取的数据对象</p><hr><h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><pre><code>import org.apache.shiro.authc.*;  import org.apache.shiro.authc.credential.HashedCredentialsMatcher;  import org.apache.shiro.authz.AuthorizationInfo;  import org.apache.shiro.authz.SimpleAuthorizationInfo;  import org.apache.shiro.realm.AuthorizingRealm;  import org.apache.shiro.subject.PrincipalCollection;  import org.apache.shiro.util.ByteSource;  import java.util.Arrays;  /**   * @ClassName MyDefaultRealm   * @Description TODO    * @Author xufeng   * @Data 2019/3/18 16:58   * @Version 1.0   **/public class MyDefaultRealm extends AuthorizingRealm {      public MyDefaultRealm(){          HashedCredentialsMatcher passwordMatcher = new HashedCredentialsMatcher(&quot;md5&quot;);    passwordMatcher.setHashIterations(3);   this.setCredentialsMatcher(passwordMatcher);    }      //授权    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {          String myName = (String) principals.getPrimaryPrincipal();    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();    info.addRole(&quot;admin&quot;);    info.addStringPermissions(Arrays.asList(&quot;add&quot;,&quot;delete&quot;));   return info;    }      //验证    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {          String userName  = (String) token.getPrincipal();    String tSalt = &quot;盐值123&quot;;   if (&quot;xff&quot;.equals(userName)){              throw new UnknownAccountException();    }          return new SimpleAuthenticationInfo(userName, getPasswordFromDB(userName), generateSalt(tSalt), getName());    }      private String getPasswordFromDB(String userName) {          //do SomeThing    return &quot;4d7461d62743c1e852f96ac24a6d1767&quot;;    }      private ByteSource generateSalt(String salt) {          return ByteSource.Util.bytes(salt);    }  }</code></pre><p>doGetAuthorizationInfo是授权，在这个方法里查询数据库，获取用户权限并放入权限对象返回</p><p>doGetAuthenticationInfo是验证，在该方法里通过用户名从数据库查询密码，然后与token中的用户密码校验，成功会返回登陆信息，失败会抛出异常</p><p>可以在该类的构造器中声明密码的加密方法，以什么方式加密、盐值，以及，循环多少次</p><hr><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><pre><code>import org.apache.shiro.SecurityUtils;  import org.apache.shiro.authc.AuthenticationException;  import org.apache.shiro.authc.UsernamePasswordToken;  import org.apache.shiro.config.IniSecurityManagerFactory;  import org.apache.shiro.crypto.hash.Md5Hash;  import org.apache.shiro.subject.Subject;  import org.apache.shiro.util.Factory;  import org.junit.Assert;  import org.junit.Test;  import org.apache.shiro.mgt.SecurityManager;  /**   * @ClassName MyTest   * @Description TODO    * @Author xufeng   * @Data 2019/3/18 16:31   * @Version 1.0   **/public class MyTest {      @Test    public void test() {        Factory&lt;SecurityManager&gt; factory  = new IniSecurityManagerFactory(&quot;classpath:myshiro.ini&quot;);        SecurityManager sm = factory.getInstance();        SecurityUtils.setSecurityManager(sm);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken(&quot;jay&quot;,&quot;123456&quot;);       try{                  subject.login(token);        }catch (AuthenticationException a){                  System.out.println(&quot;登陆失败&quot;);        }              //断言用户已经登陆        Assert.assertEquals(true, subject.isAuthenticated());        System.out.println(subject.hasRole(&quot;admin&quot;));        subject.checkRole(&quot;admin&quot;);        System.out.println(subject.isPermitted(&quot;add&quot;));        System.out.println(subject.isPermittedAll(&quot;add&quot;,&quot;delete&quot;));        System.out.println(subject.isPermitted(&quot;update&quot;));        System.out.println(subject.getPrincipal().toString());        subject.logout();        System.out.println(subject.getPrincipal().toString());    }      @Test    public void tt(){        Md5Hash md5Hash = new Md5Hash(&quot;123456&quot;,&quot;盐值123&quot;,3);        System.out.println(md5Hash);    }  }</code></pre><p>方法内前面三行是引入shiro配置，创建subject门面对象，通过login方法验证token</p><p>在subject.login(token)这行打个断点，可以看到token里的值如下：</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g178vs0ld1j30br06kq34.jpg" alt=""></p><p>下面是对用户权限的验证，最后打印结果为：</p><pre><code>truetruetruefalsejayjava.lang.NullPointerException    at MyTest.test(MyTest.java:52)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)</code></pre><p>logout后subject对象会被销毁，抛出空指针异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;依赖导入&quot;&gt;&lt;a href=&quot;#依赖导入&quot; class=&quot;headerlink&quot; title=&quot;依赖导入&quot;&gt;&lt;/a&gt;依赖导入&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;  
 &amp;lt;dependency&amp;gt;
     &amp;lt;gr
      
    
    </summary>
    
      <category term="shiro" scheme="http://xfff.xyz/categories/shiro/"/>
    
    
  </entry>
  
  <entry>
    <title>【vue】关于push、replace、和go的使用问题</title>
    <link href="http://xfff.xyz/2019/03/09/%E3%80%90vue%E3%80%91%E5%85%B3%E4%BA%8Epush%E3%80%81replace%E3%80%81%E5%92%8Cgo%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://xfff.xyz/2019/03/09/【vue】关于push、replace、和go的使用问题/</id>
    <published>2019-03-09T09:21:32.000Z</published>
    <updated>2019-03-09T09:45:05.183Z</updated>
    
    <content type="html"><![CDATA[<p>在vue方法中跳转到另一个页面有以下三种方式</p><pre><code>this.$router.push({path:&apos;/&apos;,query.....})this.$router.replace({path:&apos;/&apos;,query.....})this.$router.go(n)</code></pre><p>其中push和replace类似，可以指定在路由里指定的路径path跳转到指定页面，可以附带query和一些参数，实际跳转后query里的参数是附带在url后面以<br>？参数名=参数值<br>的形式传递。</p><p>而go则是携带一个n值，相对于当前页面往前或者往后跳转多少个页面</p><hr><p>在push和replace的使用中，我发现push跳转会带着当前页面的缓存跳转，网上是这样解释的</p><p><strong>描述：跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面</strong></p><p><strong>当我实际使用时，发现跳转后有些控件的css样式异常，后来发现，原来是上一页面的css样式应用到了当前页面，当我改成replace之后就能显示正常。</strong></p><p>而replace网上是这么解释的</p><p><strong>同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</strong></p><hr><p>另外顺便记录一下如何用CSS画简单的箭头，再也不用图片当箭头按钮啦</p><pre><code>width: 70px;height: 70px;border-top: 20px solid #041011;border-left: 20px solid #041011;transform: rotate(-45deg);</code></pre><p>transform里的是旋转角度，可以自定义方向</p><p>显示如下</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0woo0oouej305z03j3yn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在vue方法中跳转到另一个页面有以下三种方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.$router.push({path:&amp;apos;/&amp;apos;,query.....})

this.$router.replace({path:&amp;apos;/&amp;apos;,query.
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
      <category term="error" scheme="http://xfff.xyz/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】使用mybatis查询返回map时空值不保存key的解决方法</title>
    <link href="http://xfff.xyz/2019/03/05/%E3%80%90SpringBoot%E3%80%91%E4%BD%BF%E7%94%A8mybatis%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Emap%E6%97%B6%E7%A9%BA%E5%80%BC%E4%B8%8D%E4%BF%9D%E5%AD%98key%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://xfff.xyz/2019/03/05/【SpringBoot】使用mybatis查询返回map时空值不保存key的解决方法/</id>
    <published>2019-03-05T03:53:03.000Z</published>
    <updated>2019-03-05T06:47:21.418Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在使用mybatis对数据库进行查询然后返回一个map类型的时候，如果某一列的值为空</strong></p><p><strong>那么返回的map里是会没有这个值对应的列的key，也就是map的容量会比预期小，很容易出一些问题</strong></p><p><strong>我在前端对传来的map遍历存入table时，由于缺少一些key，导致后面的列往前面推，使表格混乱</strong></p><p>为了解决这个问题，我先是找到了这篇博客,分析了一下mybatis给map类型赋值的过程</p><blockquote><p><a href="https://blog.csdn.net/zdazx/article/details/79289074" target="_blank" rel="noopener">https://blog.csdn.net/zdazx/article/details/79289074</a></p></blockquote><hr><p>但是它使用的是ssm框架，为了在springboot框架里配置mybatis配置，我新建了一个mybatis-config.xml配置文件，然后再springboot配置文件application.properties里引入</p><p>mybatis-config.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  &lt;configuration&gt;   &lt;settings&gt; &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;true&quot;/&gt;   &lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;true&quot; /&gt;   &lt;/settings&gt;&lt;/configuration&gt;</code></pre><p>接着配置</p><pre><code>mybatis-plus.mapper-locations=classpath*:/mapper/*.xml  mybatis-plus.config-location=classpath:/mybatis-setting.xml</code></pre><p>这里由于我使用的是mybatis-plus，前面需要更改为mybatis-plus</p><p>另外，直接配置mybatis.configuration.returnInstanceForEmptyRow.value=true这种是不行的，没有效果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在使用mybatis对数据库进行查询然后返回一个map类型的时候，如果某一列的值为空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么返回的map里是会没有这个值对应的列的key，也就是map的容量会比预期小，很容易出一些问题&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://xfff.xyz/categories/SpringBoot/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="error" scheme="http://xfff.xyz/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>关于热部署和切面方法的问题解决</title>
    <link href="http://xfff.xyz/2019/03/02/%E5%85%B3%E4%BA%8E%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E5%88%87%E9%9D%A2%E6%96%B9%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://xfff.xyz/2019/03/02/关于热部署和切面方法的问题解决/</id>
    <published>2019-03-02T05:16:07.000Z</published>
    <updated>2019-03-02T05:33:28.063Z</updated>
    
    <content type="html"><![CDATA[<p>今天在使用AOP切面方法对指定方法进行增强的时候有个异常问题，折腾了很久，网上找了很多博客和解答，都找不到有用的，终于，凭着自己的第六感，找到了问题所在。</p><p>原因就是 我使用JRebel热部署，然后对切面方法进行了修改，修改了方法的返回类型（不知道修改方法内容会不会，应该不会），然后运行时就会抛出以下异常：<img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0ods9stgtj30ts0fk0xx.jpg" alt=""></p><p>具体代码如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0odrojeh1j30fy0fxgmm.jpg" alt=""></p><p>我把项目停止重新运行后，成功解决</p><hr><p>这里就顺便写一下springboot使用aop的方法叭</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><pre><code>&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;  &lt;/dependency&gt;</code></pre><h2 id="创建增强类"><a href="#创建增强类" class="headerlink" title="创建增强类"></a>创建增强类</h2><p>直接粘代码叭</p><pre><code>package com.me.aspectj;  import com.me.beans.ReturnMessage;  import com.me.security.TokenCreater;  import com.me.utils.RedisUtil;  import org.aspectj.lang.ProceedingJoinPoint;  import org.aspectj.lang.annotation.Around;  import org.aspectj.lang.annotation.Aspect;  import org.aspectj.lang.annotation.Pointcut;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Component;  /**   * @ClassName TokenAspectJ   * @Description 在用户或管理员的请求前对token进行验证   * @Author xufeng   * @Data 2019/3/1 18:05   * @Version 1.0   **/ @Aspect  @Component  public class TokenAspectJ {      @Pointcut(&quot;execution(public * com.me.controller.UserController.*(..))&quot;)      private void aop1(){}      @Pointcut(&quot;execution(public * com.me.controller.ManagerController.*(..))&quot;)      private void aop2(){}      @Autowired    private RedisUtil redisUtil;    @Around(&quot;aop1() || aop2()&quot;)      public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {          Object[] obj = joinPoint.getArgs();    Object result;    String token = (String) obj[obj.length-1];   if (redisUtil.get((String) TokenCreater.parseJWT(token).get(&quot;id&quot;)).equals(token)){          result = joinPoint.proceed();          return result;    }          return new ReturnMessage(true,401);    }  }</code></pre><p><del>代码格式不知道怎么总是乱</del></p><p>pointcut注解里，可以用多种参数<br>除了最常用的execution，还有args等可以指定添加了那些注解的方法作为增强对象<br>参照</p><blockquote><p><a href="https://www.cnblogs.com/liaojie970/p/7883687.html" target="_blank" rel="noopener">https://www.cnblogs.com/liaojie970/p/7883687.html</a></p></blockquote><p>5种注解使用方式</p><blockquote><p><a href="https://blog.csdn.net/u010502101/article/details/78823056" target="_blank" rel="noopener">https://blog.csdn.net/u010502101/article/details/78823056</a></p></blockquote><p>不进入增强方法用around</p><blockquote><p><a href="https://blog.csdn.net/zhanglf02/article/details/78132304" target="_blank" rel="noopener">https://blog.csdn.net/zhanglf02/article/details/78132304</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在使用AOP切面方法对指定方法进行增强的时候有个异常问题，折腾了很久，网上找了很多博客和解答，都找不到有用的，终于，凭着自己的第六感，找到了问题所在。&lt;/p&gt;
&lt;p&gt;原因就是 我使用JRebel热部署，然后对切面方法进行了修改，修改了方法的返回类型（不知道修改方法内容会
      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="springboot" scheme="http://xfff.xyz/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】利用动态语句动态创建表和列</title>
    <link href="http://xfff.xyz/2019/02/27/%E3%80%90mybatis%E3%80%91%E5%88%A9%E7%94%A8%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%92%8C%E5%88%97/"/>
    <id>http://xfff.xyz/2019/02/27/【mybatis】利用动态语句动态创建表和列/</id>
    <published>2019-02-27T09:48:25.000Z</published>
    <updated>2019-02-28T01:43:17.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了动态从数据库中生成表以及定义属性</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="创建新的xml文件以及mapper接口类"><a href="#创建新的xml文件以及mapper接口类" class="headerlink" title="创建新的xml文件以及mapper接口类"></a>创建新的xml文件以及mapper接口类</h2><p>TabelControllerMapper.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  &lt;mapper namespace=&quot;com.me.mapper.TableControllerMapper&quot;&gt;   &lt;update id=&quot;createNewTable&quot;&gt;    CREATE TABLE ${myMap.theTableName}(            id int(10) PRIMARY KEY AUTO_INCREMENT NOT NULL            &lt;foreach collection=&quot;myMap&quot; index=&quot;key&quot; item=&quot;value&quot;&gt;   &lt;if test=&quot;key.toString() != &apos;theTableName&apos;.toString()&quot;&gt;    ,${key} ${value}   &lt;/if&gt;   &lt;/foreach&gt;  );      &lt;/update&gt;  &lt;/mapper&gt;</code></pre><p>注意第一句定义id后面不加逗号，在foreach循环里前面加上逗号是为了语句最后一次执行后面没有逗号，否则会报错</p><hr><p>TableControllerMapper接口</p><pre><code>package com.me.mapper;  import org.apache.ibatis.annotations.Mapper;  import org.apache.ibatis.annotations.Param;  import java.util.HashMap;  /**   * @author fenghere   */@Mapper  public interface TableControllerMapper {      /**       * fetch data by rule id * * @param map mymap       * @return Result&lt;XxxxDO&gt;       */    void createNewTable(@Param(value = &quot;myMap&quot;) HashMap map);  }</code></pre><p>输入的参数为hashmap类型，关于这种引入参数的方法另一篇博客有写</p><blockquote><p><a href="http://xfff.xyz/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/">http://xfff.xyz/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/</a></p></blockquote><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写一个测试类</p><pre><code>package com.me.demo;  import com.me.beans.User;  import com.me.mapper.TableControllerMapper;  import com.me.mapper.UserMapper;  import com.me.security.Md5Utils;  import com.me.service.UserService;  import org.junit.Test;  import org.springframework.beans.factory.annotation.Autowired;  import java.io.UnsupportedEncodingException;  import java.security.NoSuchAlgorithmException;  import java.util.HashMap;  /**   * @ClassName MyTest   * @Description TODO   * @Author xufeng   * @Data 2019/2/22 13:46   * @Version 1.0   **/ public class MyTest extends DemoApplicationTests{    @Autowired    TableControllerMapper tableControllerMapper;    @Test    public void myTest(){            HashMap&lt;String,String&gt; mymap = new HashMap&lt;&gt;();            mymap.put(&quot;theTableName&quot;,&quot;dsafakshfdksahlfhdashdfh&quot;);            mymap.put(&quot;text&quot;,&quot;text&quot;);            mymap.put(&quot;username&quot;,&quot;varchar(10)&quot;);            mymap.put(&quot;ididiid&quot;,&quot;int&quot;);            tableControllerMapper.createNewTable(mymap);    }  }</code></pre><p>MyTest类继承DemoApplicationTests是为了引入springboot项目的数据库和mapper配置</p><p>执行完成，进入数据库查看</p><p>如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0l4xp6jr3j30vm03mq32.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0l4yi56qfj30od05naab.jpg" alt=""></p><hr><p>另外，删除表等操作应为类似的操作.</p><pre><code>&lt;select id=&quot;existTable&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;java.lang.Integer&quot;&gt;    select count(*)    from information_schema.TABLES    where LCASE(table_name) = #{tableName}&lt;/select&gt;&lt;update id=&quot;dropTable&quot;&gt;    DROP TABLE ${tablename}&lt;/update&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;为了动态从数据库中生成表以及定义属性&lt;/p&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="动态sql" scheme="http://xfff.xyz/tags/%E5%8A%A8%E6%80%81sql/"/>
    
  </entry>
  
  <entry>
    <title>【java】关于replace字符串时特殊字符的坑</title>
    <link href="http://xfff.xyz/2019/02/25/%E3%80%90java%E3%80%91%E5%85%B3%E4%BA%8Ereplace%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%9D%91/"/>
    <id>http://xfff.xyz/2019/02/25/【java】关于replace字符串时特殊字符的坑/</id>
    <published>2019-02-25T08:30:50.000Z</published>
    <updated>2019-02-25T08:31:37.967Z</updated>
    
    <content type="html"><![CDATA[<p>刚遇到个字符串替换的坑，记录一下</p><p>实际使用时是这样的，有一个字符串里面包含\n \“等字符</p><p>现在我要把他们替换为空格和”</p><p>第一时间我想到的是</p><pre><code>str.replaceAll(&quot;\\n&quot;,&quot;&quot;);str.replaceAll(&quot;\\\&quot;&quot;,&quot;&quot;&quot;);</code></pre><p>实际上完全替换不了，还有错误</p><p>实际\n和\“在java中是这样存储的</p><pre><code>\\n 和 \\&quot;</code></pre><p>正确的替换方式:</p><pre><code>replaceAll(&quot;\\\\n&quot;,&quot;&quot;)replaceAll(&quot;\\\\\&quot;&quot;,&quot;\&quot;&quot;)</code></pre><p>居然需要4个反斜线…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚遇到个字符串替换的坑，记录一下&lt;/p&gt;
&lt;p&gt;实际使用时是这样的，有一个字符串里面包含\n \“等字符&lt;/p&gt;
&lt;p&gt;现在我要把他们替换为空格和”&lt;/p&gt;
&lt;p&gt;第一时间我想到的是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str.replaceAll(&amp;quot;\\n&amp;quot;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat控制台窗口中文乱码</title>
    <link href="http://xfff.xyz/2019/02/21/Tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://xfff.xyz/2019/02/21/Tomcat控制台窗口中文乱码/</id>
    <published>2019-02-21T07:02:35.000Z</published>
    <updated>2019-02-21T07:12:46.933Z</updated>
    
    <content type="html"><![CDATA[<p>绕了很大一个圈子<br>今天终于解决了这个问题<br>特地用一篇博客记录</p><p>按网上说的改注册表、改编码格式、加参数运行都试过，全都没有用，我又是个强迫症，看不得乱码</p><p>今天对conf目录下的logging.properties文件查看后，觉得是里面的格式UTF-8和系统的936GB2312冲突问题，于是<strong>ctrl+h把所有的UTF-8全部替换为GBK</strong></p><p>完美解决</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0e2ckpgkhj30zg0dj0uw.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;绕了很大一个圈子&lt;br&gt;今天终于解决了这个问题&lt;br&gt;特地用一篇博客记录&lt;/p&gt;
&lt;p&gt;按网上说的改注册表、改编码格式、加参数运行都试过，全都没有用，我又是个强迫症，看不得乱码&lt;/p&gt;
&lt;p&gt;今天对conf目录下的logging.properties文件查看后，觉得是里面的
      
    
    </summary>
    
      <category term="tomcat" scheme="http://xfff.xyz/categories/tomcat/"/>
    
    
      <category term="乱码" scheme="http://xfff.xyz/tags/%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>【vue】与springboot后台项目数据交互</title>
    <link href="http://xfff.xyz/2019/02/16/%E3%80%90vue%E3%80%91%E4%B8%8Espringboot%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://xfff.xyz/2019/02/16/【vue】与springboot后台项目数据交互/</id>
    <published>2019-02-16T15:12:00.000Z</published>
    <updated>2019-03-09T09:24:11.472Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用vue和springboot前后端分离的方式开发项目<br>遇到了很多问题</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>这里本可以用vuex，但是由于偏轻量级，用vuex会比较复杂，于是我在main.js里定义了一个全局变量，以达到控制身份的效果</p><pre><code>var state={    islogin:false,    manager:false,    identify:{        name:&apos;null&apos;,        email:&apos;null&apos;,    },    login(name,manager,email){        this.islogin=true;        this.identify.name=name;        this.manager=manager;        this.identify.email=email;    },    logout(){        this.islogin=false;        this.identify.name=&apos;null&apos;;        this.manager=false;        this.identify.email=&apos;null&apos;;    }}Vue.prototype.state=state</code></pre><p>在用户请求路径的时候，在create函数里判断身份信息，然后选择是否成功访问</p><hr><h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a>表单绑定</h2><p>为了将表单数据提交，可以把表单数据通过v-model绑定到一个数组里</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;login&quot;&gt;    &lt;myHeader/&gt;      &lt;form class=&quot;theform&quot; id=&quot;demo_11&quot; autocomplete=&quot;off&quot;&gt;        &lt;div class=&quot;form-group&quot;&gt;            &lt;input class=&quot;form-control&quot; v-model=&quot;theform.email&quot; placeholder=&quot;email&quot; type=&quot;email&quot;&gt;        &lt;/div&gt;        &lt;div class=&quot;form-group&quot;&gt;            &lt;input @change=&quot;changePw&quot; v-model=&quot;theform.password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; maxlength=&quot;8&quot;&gt;        &lt;/div&gt;        &lt;p style=&quot;color:red&quot; v-show=&quot;pflag&quot;&gt;{{message}}&lt;/p&gt;        &lt;button class=&quot;btn btn-success&quot; @click.prevent=&quot;login&quot; type=&quot;submit&quot;&gt;{{loginmessage}}&lt;/button&gt;        &amp;nbsp;&amp;nbsp;        &lt;button type=&quot;reset&quot; class=&quot;btn btn-danger&quot;&gt;{{reset}}&lt;/button&gt;        &amp;nbsp;&amp;nbsp;        &lt;button type=&quot;button&quot; @click=&quot;toRegister&quot; class=&quot;btn btn-primary&quot;&gt;{{register}}&lt;/button&gt;    &lt;/form&gt;    &lt;/div&gt;    &lt;myFooter/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myHeader from &apos;../components/header.vue&apos;import myFooter from &apos;../components/footer.vue&apos;import qs from &apos;qs&apos;export default {  components: { myHeader, myFooter },  data() {    return {       loginmessage:&quot;登陆&quot;,       reset:&quot;重置&quot;,       register:&quot;注册&quot;,       message:&quot;密码为3-8位字母或数字&quot;,       theform:{          email:&quot;&quot;,          password:&quot;&quot;,       },       pflag:false    }  },  created() {  },  methods: {      changePw:function(){        var reg=/[a-zA-Z0-9]{3,8}$/;        if(!reg.test(this.theform.password)){          this.pflag=true;          return;        }        this.pflag=false;      },      toRegister:function(){        this.$router.push({path:&apos;/register&apos;});      },      login:function(){          let me=this;          let params=qs.stringify(this.theform);          this.$axios.post(&apos;login&apos;,params,function(r){            if(!r.islogin){              alert(&quot;邮箱或密码错误&quot;);              me.$router.push({path:&apos;/&apos;});            }else{              me.state.login(r.name,r.manager,r.email);              if(r.manager){                me.$router.push({path:&apos;&apos;});              }else{                me.$router.push({path:&apos;&apos;});              }            }          });      }   }}&lt;/script&gt;&lt;style type=&quot;text/css&quot; src=&quot;@/style/login.css&quot;&gt;&lt;/style&gt;</code></pre><h2 id="axios请求"><a href="#axios请求" class="headerlink" title="axios请求"></a>axios请求</h2><p>在使用axios发送请求时，我使用的在另一篇博客里用到的axios接口函数，在处理字符串时会报错，怎么也无法解决，最终我只能把下面这行注释</p><pre><code>/*      o[key] = o[key].trim()*/</code></pre><p>通过看接口代码，发现我们在后台需要返回数据里有success属性，否则会弹框打印信息。</p><pre><code>package com.me.controller;  import com.me.beans.ReturnMessage;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.web.bind.annotation.RequestParam;  import org.springframework.web.bind.annotation.ResponseBody;  import org.springframework.web.bind.annotation.RestController;  import java.util.HashMap;  @RestController  public class LoginController {      @RequestMapping(&quot;/login&quot;)      @ResponseBody    public HashMap login(@RequestParam(&quot;email&quot;)String email, @RequestParam(&quot;password&quot;)String password){          System.out.println(&quot;I AM COMING!============&quot;);    System.out.println(email);    System.out.println(password);    HashMap&lt;String,Object&gt; hashMap=new HashMap&lt;&gt;();    hashMap.put(&quot;success&quot;,true);    hashMap.put(&quot;islogin&quot;,false);    hashMap.put(&quot;ismanager&quot;,true);    hashMap.put(&quot;email&quot;,&quot;&quot;);    hashMap.put(&quot;name&quot;,&quot;&quot;);   return hashMap;    /*writer.write(&quot;success!!&quot;);*/    }      @RequestMapping(&quot;/sendcode&quot;)      @ResponseBody    public ReturnMessage sendcode(@RequestParam(&quot;email&quot;)String email){          System.out.println(email);   return new ReturnMessage(true);    }  }</code></pre><p>后台需要返回json格式的数据，使用@ResponseBody会帮我们自动把返回的数据转换为json格式。使用时还遇到了这个错误</p><blockquote><p><a href="https://www.cnblogs.com/gyjx2016/p/5896138.html" target="_blank" rel="noopener">https://www.cnblogs.com/gyjx2016/p/5896138.html</a><br>只需要把@Controller改为@RestController注解即可（由于前后端分离，@controller注解并没有什么用）</p></blockquote><p>前台在提取的时候只需要把success函数里的r提出来用r.属性名就可以了</p><p>另外，get请求会把参数放在url后面<br>所以请求时参数应写为{xxx:”xxx”}的格式<br>而post请求类型时，不能直接按上面的格式，或者用JSON.stringify()的格式，实际使用时，需要导入axios里的qs工具</p><pre><code>import qs from &apos;qs&apos;</code></pre><p>然后对参数进行qs.stringify的操作<br>比如上面的表单里的数据，就用了</p><pre><code>qs.stringify(this.theform)</code></pre><hr><p>实际使用时，要注意this的含义，可以在刚开始用一个变量来存储this，防止后面使用的时候丢失。</p><hr><h2 id="获取验证码"><a href="#获取验证码" class="headerlink" title="获取验证码"></a>获取验证码</h2><p>实现验证码60秒内禁止重新发送</p><pre><code>  var num=60;  var me=this;me.$axios.get(&apos;sendcode&apos;,{email:me.rform.email});  this.sflag=true;  var timer=setInterval(function(){      num--;      me.send=num+&apos;秒后刷新&apos;;    if(num == 0){       me.sflag=false;       me.send=&apos;发送验证码&apos;;       clearInterval(timer);       timer=null;    }  },1000);</code></pre><p>控制按钮能否点击上用了属性</p><pre><code>:disabled=&quot;sflag&quot;</code></pre><p>通过变量sflag控制</p><hr><p>大概功能都差不多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在使用vue和springboot前后端分离的方式开发项目&lt;br&gt;遇到了很多问题&lt;/p&gt;
&lt;h2 id=&quot;身份认证&quot;&gt;&lt;a href=&quot;#身份认证&quot; class=&quot;headerlink&quot; title=&quot;身份认证&quot;&gt;&lt;/a&gt;身份认证&lt;/h2&gt;&lt;p&gt;这里本可以用vuex，但
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="springboot" scheme="http://xfff.xyz/tags/springboot/"/>
    
      <category term="axios" scheme="http://xfff.xyz/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>【vue】整合surveyjs工具生成在线问卷或考试</title>
    <link href="http://xfff.xyz/2019/01/31/%E3%80%90vue%E3%80%91%E6%95%B4%E5%90%88surveyjs%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E5%9C%A8%E7%BA%BF%E9%97%AE%E5%8D%B7%E6%88%96%E8%80%83%E8%AF%95/"/>
    <id>http://xfff.xyz/2019/01/31/【vue】整合surveyjs工具生成在线问卷或考试/</id>
    <published>2019-01-31T06:23:29.000Z</published>
    <updated>2019-01-31T09:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本想做个问卷系统，在github上找到一个叫做surveyjs的项目，正好是我需要的东西。</p><hr><p>官网</p><blockquote><p><a href="https://surveyjs.io/" target="_blank" rel="noopener">https://surveyjs.io/</a></p></blockquote><p>vue项目,surveyjseditor例子</p><blockquote><p><a href="https://github.com/surveyjs/surveyjs_vue_quickstart" target="_blank" rel="noopener">surveyjs_vue_quickstart</a></p></blockquote><hr><p>可以只用单个survey页面或者把编辑器导入也行。</p><p>这里我的是问卷生成，所以俩部分都需要使用</p><hr><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>本地找个空文件夹<br>打开gitbash命令行窗口<br>git clone <a href="https://github.com/surveyjs/surveyjs_vue_quickstart.git" target="_blank" rel="noopener">https://github.com/surveyjs/surveyjs_vue_quickstart.git</a><br>项目克隆下来后<br>直接运行肯定不行<br>显然根目录下少了nodejs的node_modules<br>在该目录下打开命令行窗口<br>运行</p><pre><code>npm install</code></pre><p>（可能需要翻墙）</p><p>装好对应的依赖和库<br>就可以</p><pre><code>npm run dev</code></pre><p>运行了</p><hr><p>打开项目目录<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzprfbs08cj309k0f10t3.jpg" alt=""></p><p>直接打开上面的components组件目录，里面SurveyEditor.vue是我们引用需要写的组件代码。</p><pre><code>&lt;template&gt;  &lt;div&gt;&lt;div id=&quot;surveyEditorContainer&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as SurveyEditor from &apos;surveyjs-editor&apos;import &apos;surveyjs-editor/surveyeditor.css&apos;;import * as SurveyKo from &quot;survey-knockout&quot;;import * as widgets from &quot;surveyjs-widgets&quot;;import &quot;inputmask/dist/inputmask/phone-codes/phone.js&quot;;widgets.icheck(SurveyKo);widgets.select2(SurveyKo);widgets.inputmask(SurveyKo);widgets.jquerybarrating(SurveyKo);widgets.jqueryuidatepicker(SurveyKo);widgets.nouislider(SurveyKo);widgets.select2tagbox(SurveyKo);widgets.signaturepad(SurveyKo);widgets.sortablejs(SurveyKo);widgets.ckeditor(SurveyKo);widgets.autocomplete(SurveyKo);widgets.bootstrapslider(SurveyKo);export default {  name: &apos;survey-editor&apos;,  data () {    return {    }  },  mounted () {    let editorOptions = { showEmbededSurveyTab: true };    this.editor = new SurveyEditor.SurveyEditor(&apos;surveyEditorContainer&apos;, editorOptions);    this.editor.saveSurveyFunc = function() {      console.log(JSON.stringify(this.text));    };  }}&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>大部分代码都很容易理解，showEmbededSurveyTab是用来选择是否显示应用在不同项目中需要写的代码的子页面，我改为false</p><hr><p>如何把该组件引入自己的项目中–</p><p>新建项目</p><p>按上次<a href="http://xfff.xyz/2019/01/29/vuejs%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/">vue总体结构学习</a>这节配置好vue项目结构之后。<br>把该加入的SurveyEditor.vue放入component目录</p><p>把该vue里用到的比如surveyjs-editor、survey-konckout、surveyjs-widgets、phone一一用</p><pre><code>npm install xxxx -D</code></pre><p>安装好</p><p>然后在页面里需要使用到该组件时只需要</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzpscuh94ij30hu08yaaj.jpg" alt=""></p><p>如上导入即可</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzpsdp938rj311y0kiq5g.jpg" alt=""></p><hr><p>另外，生成的页面导入，该页面创建完问卷后点击save survey会产生一个关于该问卷的格式信息，在saveSurveyFunc方法里我们可以对该数据进行处理提交给数据库。</p><p>当获取到该数据后要对新的问卷页面进行渲染，则可以这样：</p><p>新建页面</p><pre><code>&lt;template&gt;    &lt;div id=&quot;surveyContainer&quot;&gt;&lt;!-- &lt;link href=&quot;https://surveyjs.azureedge.net/1.0.66/survey.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt; --&gt;        &lt;survey :survey=&quot;survey&quot;&gt;&lt;/survey&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import * as Survey from &apos;survey-vue&apos;import &apos;bootstrap/dist/css/bootstrap.css&apos;;Survey.Survey.cssType = &quot;bootstrap&quot;;var surveyJSON = {&quot;pages&quot;:[{&quot;name&quot;:&quot;page1&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;comment&quot;,&quot;name&quot;:&quot;question1&quot;,&quot;title&quot;:&quot;aaa&quot;},{&quot;type&quot;:&quot;dropdown&quot;,&quot;name&quot;:&quot;question2&quot;,&quot;choices&quot;:[&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;]}]},{&quot;name&quot;:&quot;page2&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;radiogroup&quot;,&quot;name&quot;:&quot;question3&quot;,&quot;choices&quot;:[&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;]}]},{&quot;name&quot;:&quot;page3&quot;,&quot;elements&quot;:[{&quot;type&quot;:&quot;matrix&quot;,&quot;name&quot;:&quot;question4&quot;,&quot;columns&quot;:[&quot;Column 1&quot;,&quot;Column 2&quot;,&quot;Column 3&quot;],&quot;rows&quot;:[&quot;Row 1&quot;,&quot;Row 2&quot;]}]}],&quot;maxTimeToFinishPage&quot;:10,&quot;showTimerPanel&quot;:&quot;top&quot;}var mysurvey = new Survey.Model(surveyJSON);export default{    data(){        return{            survey:mysurvey        }    },    methods:{          sendDataToServer:function(survey){            alert(&quot;The results are:&quot; + JSON.stringify(survey.data));        }    },    created(){        mysurvey.onComplete.add(this.sendDataToServer);    }}&lt;/script&gt;</code></pre><p>（这里要用安装bootstrap和survey-vue）<br>这样就能渲染出对应的问卷或考试页面（考试可以设置提交限定时间），上面的surveyJSON是我现导入的数据，一般使用要从服务器获取。</p><hr><p><strong>关于created和mounted的区别</strong><br>created是在页面创建的时候，mounted是页面渲染结束后，上面的created应做修改<br>参考</p><blockquote><p><a href="https://www.jianshu.com/p/f99d3e3d2256" target="_blank" rel="noopener">https://www.jianshu.com/p/f99d3e3d2256</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本想做个问卷系统，在github上找到一个叫做surveyjs的项目，正好是我需要的东西。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;官网&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://surveyjs.io/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
      <category term="surveyjs" scheme="http://xfff.xyz/tags/surveyjs/"/>
    
  </entry>
  
  <entry>
    <title>vuejs发送异步请求</title>
    <link href="http://xfff.xyz/2019/01/29/vuejs%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"/>
    <id>http://xfff.xyz/2019/01/29/vuejs发送异步请求/</id>
    <published>2019-01-29T08:56:23.000Z</published>
    <updated>2019-01-31T09:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用vue时如何发送请求？</p><hr><p>答：ajax，不过vue不使用jquery，那么需要引入一些HTTP库工具，使用其中封装好的请求方法即可</p><p>superagent或者Axios（主流）<br>使用文档</p><blockquote><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a><br><a href="https://www.jianshu.com/p/1432e0f29abd" target="_blank" rel="noopener">https://www.jianshu.com/p/1432e0f29abd</a></p></blockquote><p>首先要安装相应的工具<br>运行命令</p><pre><code>npm install xxx -D</code></pre><p>xxx替换为对应的组件名</p><p>然后在src下的config目录新建js文件<br>假如现在使用的是superagent<br><strong>api.js</strong></p><pre><code>// 配置API接口地址var root = &apos;https://cnodejs.org/api/v1&apos;;// 引用superagentvar request = require(&apos;superagent&apos;);// 自定义判断元素类型JSfunction toType(obj) {  return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}// 参数过滤函数function filter_null(o) {  for (var key in o) {    if (o[key] == null) {      delete o[key]    }    if (toType(o[key]) == &apos;string&apos;) {      o[key] = o[key].trim()      if (o[key].length == 0) {        delete o[key]      }    }  }  return o}/*  接口处理函数  这个函数每个项目都是不一样的，我现在调整的是适用于  https://cnodejs.org/api/v1 的接口，如果是其他接口  需要根据接口的参数进行调整。参考说明文档地址：  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd*/function _api_base(method, url, params, success, failure) {  var r = request(method, url).type(&apos;text/plain&apos;)  if (params) {    params = filter_null(params);    if (method === &apos;POST&apos; || method === &apos;PUT&apos;) {      if (toType(params) == &apos;object&apos;) {        params = JSON.stringify(params);      }      r = r.send(params)    } else if (method == &apos;GET&apos; || method === &apos;DELETE&apos;) {      r = r.query(params)    }  }  r.end(function(err, res) {    if (err) {      alert(&apos;api error, HTTP CODE: &apos; + res.status);      return;    };    if (res.body.success == true) {      if (success) {        success(res.body);      }    } else {      if (failure) {        failure(res.body);      } else {        alert(&apos;error: &apos; + JSON.stringify(res.body));      }    }  });};// 返回在vue模板中的调用接口export default {  get: function(url, params, success, failure) {    return _api_base(&apos;GET&apos;, root + &apos;/&apos; + url, params, success, failure)  },  post: function(url, params, success, failure) {    return _api_base(&apos;POST&apos;, root + &apos;/&apos; + url, params, success, failure)  },  put: function(url, params, success, failure) {    return _api_base(&apos;PUT&apos;, root + &apos;/&apos; + url, params, success, failure)  },  delete: function(url, params, success, failure) {    return _api_base(&apos;DELETE&apos;, root + &apos;/&apos; + url, params, success, failure)  },}</code></pre><p>这是原博作者封装好的请求方法，开头的api地址是我们项目的基础请求地址头<br>这里填的是cnodejs.org提供的api接口</p><p>使用时只需要</p><p>先在启动入口里全局配置好</p><pre><code>import api from &apos;./config/api&apos;Vue.prototype.$api=api</code></pre><p>这两行的意思大概就是把api.js文件注册到全局，然后可以通过 $api.方法名 调用该文件里的方法。</p><hr><p>如</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    import Header from &apos;../components/header&apos;    import Footer from &apos;../components/footer&apos;    export default{        components:{Header,Footer},        data(){            return{                lists:[]            }        },        created(){            this.get_data()        },        methods:{            get_data:function(params){                var v=this                if(!params) params={}                    v.$api.get(&apos;topics&apos;,params,function(r){                        v.lists=r.data;                    })            },        },    }&lt;/script&gt;</code></pre><p>created是该页面创建时执行的方法，params是传入的参数，’topics’是请求的地址，r是成功执行时返回的数据</p><hr><p>然后该页面的template块为</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;Header&gt;&lt;/Header&gt;    &lt;ul class=&quot;list&quot;&gt;      &lt;li v-for=&quot;item in lists&quot;&gt;          &lt;time v-text=&quot;$fortime.goodTime(item.create_at)&quot;&gt;&lt;/time&gt;          &lt;router-link :to=&quot;&apos;/content/&apos; + item.id&quot;&gt;{{item.title}}&lt;/router-link&gt;      &lt;/li&gt;    &lt;/ul&gt;    &lt;Footer&gt;&lt;/Footer&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>fortime是我注册的工具类，用来格式化时间<br>router-link相当于a标签，请求的地址是/content/加上item的id</p><hr><p>接下来写content里的内容，这次使用axios工具<br>一样，先install，创建一个index.js写入</p><pre><code>// 配置API接口地址var root = &apos;/api/v1&apos;// 引用axiosvar axios = require(&apos;axios&apos;)// 自定义判断元素类型JSfunction toType (obj) {  return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}// 参数过滤函数function filterNull (o) {  for (var key in o) {    if (o[key] === null) {      delete o[key]    }    if (toType(o[key]) === &apos;string&apos;) {      o[key] = o[key].trim()    } else if (toType(o[key]) === &apos;object&apos;) {      o[key] = filterNull(o[key])    } else if (toType(o[key]) === &apos;array&apos;) {      o[key] = filterNull(o[key])    }  }  return o}/*  接口处理函数  这个函数每个项目都是不一样的，我现在调整的是适用于  https://cnodejs.org/api/v1 的接口，如果是其他接口  需要根据接口的参数进行调整。参考说明文档地址：  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd  主要是，不同的接口的成功标识和失败提示是不一致的。  另外，不同的项目的处理方法也是不一致的，这里出错就是简单的alert*/function apiAxios (method, url, params, success, failure) {  if (params) {    params = filterNull(params)  }  axios({    method: method,    url: url,    data: method === &apos;POST&apos; || method === &apos;PUT&apos; ? params : null,    params: method === &apos;GET&apos; || method === &apos;DELETE&apos; ? params : null,    baseURL: root,    withCredentials: false  })  .then(function (res) {    if (res.data.success === true) {      if (success) {        success(res.data)      }    } else {      if (failure) {        failure(res.data)      } else {        window.alert(&apos;error: &apos; + JSON.stringify(res.data))      }    }  })  .catch(function (err) {    let res = err.response    if (err) {      window.alert(&apos;api error, HTTP CODE: &apos; + res.status)    }  })}// 返回在vue模板中的调用接口export default {  get: function (url, params, success, failure) {    return apiAxios(&apos;GET&apos;, url, params, success, failure)  },  post: function (url, params, success, failure) {    return apiAxios(&apos;POST&apos;, url, params, success, failure)  },  put: function (url, params, success, failure) {    return apiAxios(&apos;PUT&apos;, url, params, success, failure)  },  delete: function (url, params, success, failure) {    return apiAxios(&apos;DELETE&apos;, url, params, success, failure)  }}</code></pre><p><strong>！这里</strong>不直接用原api地址是因为cnode.js的接口处理的很好，解决了跨域的问题。实际项目中，很多接口不允许跨域请求。为了解决这个问题，采用webpack的代理的方式<br>在<strong>根目录的config文件夹</strong>下打开index.js，找到proxyTable这一行，里面就是我们要填的代理地址<br>这里我们写的是</p><pre><code>proxyTable: {    &apos;/api/v1/**&apos;:{        target: &apos;https://cnodejs.org&apos;,        secure: false,        changeOrigin: false,    }},</code></pre><p>然后在main.js里注册</p><pre><code>import aapi from &apos;./config/index&apos;Vue.prototype.$axapi=aapi</code></pre><p>然后使用</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;myHeader&gt;&lt;/myHeader&gt;    &lt;h2 v-text=&quot;dat.title&quot;&gt;&lt;/h2&gt;    &lt;p v-if=dat.author&gt;作者：{{dat.author.loginname}}　　发表于：{{$fortime.goodTime(dat.create_at)}}&lt;/p&gt;    &lt;hr&gt;    &lt;article v-html=&quot;dat.content&quot;&gt;&lt;/article&gt;    &lt;h3&gt;网友回复：&lt;/h3&gt;    &lt;ul&gt;      &lt;li v-for=&quot;i in dat.replies&quot;&gt;        &lt;p&gt;评论者：{{i.author.loginname}}　　评论于：{{$fortime.goodTime(i.create_at)}}&lt;/p&gt;        &lt;article v-html=&quot;i.content&quot;&gt;&lt;/article&gt;      &lt;/li&gt;    &lt;/ul&gt;    &lt;myFooter&gt;&lt;/myFooter&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import myHeader from &apos;../components/header.vue&apos;import myFooter from &apos;../components/footer.vue&apos;export default {  components: { myHeader, myFooter },  data () {    return {      id: this.$route.params.id,      dat: {}    }  },  created () {    this.getData()  },  methods: {    getData () {      this.$axapi.get(&apos;topic/&apos; + this.id, null, r =&gt; {        this.dat = r.data      })    }  }}&lt;/script&gt;</code></pre><p>这里出过一个错就是，老提示loginname not defined，后来发现是author还没加载就加载了loginname，在p标签里加上v-if后解决问题</p><hr><p>运行结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznl8issgwj30y30g0771.jpg" alt=""></p><hr><p>说明请求成功，具体项目代码在</p><blockquote><p><a href="https://github.com/HolyDogs/VueStructDemo" target="_blank" rel="noopener">https://github.com/HolyDogs/VueStructDemo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;使用vue时如何发送请求？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;答：ajax，不过vue不使用jquery，那么需要引入一些HTTP库工具，使用其中封装
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>vuejs总体结构学习</title>
    <link href="http://xfff.xyz/2019/01/29/vuejs%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xfff.xyz/2019/01/29/vuejs总体结构学习/</id>
    <published>2019-01-29T07:50:24.000Z</published>
    <updated>2019-01-31T09:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然翻到一篇讲解一个vue项目的搭建的博客。全部撸完后觉得写的很好，决定在这里总结一下，原博地址</p><blockquote><p><a href="https://blog.csdn.net/fungleo/article/details/77606321" target="_blank" rel="noopener">https://blog.csdn.net/fungleo/article/details/77606321</a></p></blockquote><hr><p>首先，看一下大体的项目结构</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzniy1h619j30fo0ix42b.jpg" alt=""></p><p>贴代码<br>main.js</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznj3i8xvgj30o70eu0uh.jpg" alt=""></p><p>红框框起来的是必要代码，引入Vue和App模版、vue路由。然后引入全局的路由配置文件routes.js<br>使用路由需要Vue.use(VueRouter)</p><hr><p>看一下App.vue<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznj87c7lmj30hq08a0t3.jpg" alt=""><br>很简单，在模版里加入了路由的标签router-view</p><hr><p>接下来是路由配置文件routes.js<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznj9o2ircj30gw0fet9w.jpg" alt=""></p><p>也就是把要配置的路径对应的vue文件导入，一一配置。<br>path为’/‘时为默认路径，即当页面路径/后有问题的时候默认也导入到该页面</p><p>配置第二个content路径的时候，<strong>：id</strong>表示动态映射路径，当/content匹配成功的时候就会进入content.vue文件对应的页面，该页面中可以通过<span>this.$routes.params.id</span>获取该id值</p><p>第三个是将/user/xxx匹配成功时将子页面渲染到Frame里的router-view标签里<br>subroute的代码为<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznjqeoykyj30ei04bmx6.jpg" alt=""><br>比如这个时候我请求/user/love时就会映射到userLove对应的页面上，如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznjs4mre3j30q706f0t4.jpg" alt=""></p><hr><p>组件定义<br>当一个页面的某部分在页面变化保持不变的时候，我们就可以把该部分写在component文件夹下，定义组件，并在其他页面使用</p><p>比如，我们定义一个页面的头部和尾部<br>header.vue<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznjx4yo7kj30f704gjrm.jpg" alt=""></p><p>尾部<br>footer.vue<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznjy0p9u1j30dg03lgll.jpg" alt=""></p><p>然后在使用时导入</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fznjzqucmgj30ql0cjmz1.jpg" alt=""></p><p>这样就可以把组件渲染到页面上</p><hr><p>引用静态文件时,src定义为static/xxx即可</p><hr><p>具体项目代码我传到了github上，地址</p><blockquote><p><a href="https://github.com/HolyDogs/VueStructDemo" target="_blank" rel="noopener">https://github.com/HolyDogs/VueStructDemo</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;偶然翻到一篇讲解一个vue项目的搭建的博客。全部撸完后觉得写的很好，决定在这里总结一下，原博地址&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fungleo/article/details/77606321&quot; tar
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
      <category term="js" scheme="http://xfff.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>【redis】jedis使用</title>
    <link href="http://xfff.xyz/2019/01/25/%E3%80%90redis%E3%80%91jedis%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/25/【redis】jedis使用/</id>
    <published>2019-01-25T07:57:30.000Z</published>
    <updated>2019-01-31T09:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用jedis访问redis数据库"><a href="#使用jedis访问redis数据库" class="headerlink" title="使用jedis访问redis数据库"></a>使用jedis访问redis数据库</h2><p>创建个maven项目JedisDemo</p><p>引入依赖</p><pre><code>&lt;dependencies&gt;       &lt;dependency&gt;         &lt;groupId&gt;redis.clients&lt;/groupId&gt;           &lt;artifactId&gt;jedis&lt;/artifactId&gt;           &lt;version&gt;2.9.0&lt;/version&gt;       &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>创建个类连接</p><pre><code>import redis.clients.jedis.Jedis;  import java.util.HashMap;  import java.util.List;  import java.util.Set;  public class DemoTest {      public static void main(String[] args) {          String host=&quot;127.0.0.1&quot;;       int port=6379;    Jedis jedis=new Jedis(host,port);    //jedis.auth(&quot;password&quot;);   //字符串类型  System.out.println(&quot;字符串&quot;);    System.out.println(jedis.get(&quot;haha&quot;));    //hash类型    System.out.println(&quot;hashmap&quot;);    HashMap&lt;String,String&gt; map= (HashMap&lt;String, String&gt;) jedis.hgetAll(&quot;mymap&quot;);    System.out.println(map.get(&quot;name&quot;)+&quot; &quot;+map.get(&quot;age&quot;));    //list类型    System.out.println(&quot;List类型&quot;);    List alist=jedis.lrange(&quot;mylist&quot;,0,-1);    alist.stream().forEach(System.out::println);    //set类型    System.out.println(&quot;set类型&quot;);    Set myset=jedis.smembers(&quot;myset&quot;);    myset.stream().forEach(System.out::println);    //zset类型    System.out.println(&quot;zset类型&quot;);    Set myzset=jedis.zrangeByScore(&quot;myzset&quot;,&quot;30&quot;,&quot;50&quot;);    myzset.stream().forEach(System.out::println);    }  }</code></pre><p>输出</p><pre><code>字符串llxizayyyyhashmaplili 5List类型aakjihgfzzzedcbaset类型jlgnadhzset类型tomxiaominghuhu</code></pre><p>访问redis成功，可以看到方法名和我们在redis控制台使用的命令一致。</p><hr><hr><h2 id="使用RedisPool"><a href="#使用RedisPool" class="headerlink" title="使用RedisPool"></a>使用RedisPool</h2><pre><code>import redis.clients.jedis.JedisPool;  import redis.clients.jedis.JedisPoolConfig;  public class JedisUtils {      private static JedisPool jedisPool;   public static JedisPool open(String ip,int port){          JedisPoolConfig config=new JedisPoolConfig();    //设置最大线程数    config.setMaxTotal(20);    //设置最大空闲数    config.setMaxIdle(2);    //设置检查项为true    config.setTestOnBorrow(true);    //    jedisPool=new JedisPool(config,ip,port,5000,&quot;password&quot;);   return jedisPool;    }      public static void close(){          if(jedisPool!=null){              jedisPool.close();    }      }  }</code></pre><p>使用</p><pre><code>JedisPool pool = null;  Jedis myjedis=null;  try{      pool=JedisUtils.open(host,port);    myjedis=pool.getResource();    //使用jedis操作  }finally {      if(jedis!=null){          jedis.close();    }  }</code></pre><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>只需要声明一个<br>Transaction类<br>Transaction trans=jedis.multi();<br>xxxx<br>xxx<br>xx<br>xxxx<br>xx<br>然后trans.exec()返回一个list集合，里面是事务语句的结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用jedis访问redis数据库&quot;&gt;&lt;a href=&quot;#使用jedis访问redis数据库&quot; class=&quot;headerlink&quot; title=&quot;使用jedis访问redis数据库&quot;&gt;&lt;/a&gt;使用jedis访问redis数据库&lt;/h2&gt;&lt;p&gt;创建个maven项目
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="jedis" scheme="http://xfff.xyz/tags/jedis/"/>
    
      <category term="java" scheme="http://xfff.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【redis】高级话题</title>
    <link href="http://xfff.xyz/2019/01/25/%E3%80%90redis%E3%80%91%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <id>http://xfff.xyz/2019/01/25/【redis】高级话题/</id>
    <published>2019-01-25T06:52:28.000Z</published>
    <updated>2019-01-31T09:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>multi<br>标记一个事务的开始，多条命令会按照先后顺序放进一个队列中，总返回OK</p><p>exec<br>执行所有事务块的命令<br>事务内的所有执行语句内容，事务被打断返回nil</p><p>discard<br>（当事务队列内的语句写到一半不想写了）取消事务，放弃事务内的所有命令，总返回OK</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzimisoa19j309b09t74c.jpg" alt=""></p><p>当遇到语法错误时，事务就会被放弃</p><p>当语法没错，但执行会出错时，redis不会回滚，前面正确的命令会正常执行</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzimsqu0h8j30fi094t8v.jpg" alt=""></h2><p>watch key…<br>监视一个或多个key，如果在事务执行前这些key被其他命令所改动，那么事务将会被打断。总是返回OK</p><p>unwatch<br>取消watch命令对所有key的监视</p><p>比如这里我对k5这个key添加监视，然后在可视化工具里修改k5的值<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzin0nu83hj30es043jr8.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzimzllvzxj309305mjra.jpg" alt=""></p><p>可以看到事务执行失败。</p><hr><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>单保存在内存中，若突然系统问题出现关机，会导致数据丢失，所以保存在硬盘中能保证数据安全。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>Redis Database（RDB），数据快照写入磁盘。<br>保存数据是在单独的进程中写文件，不会影响Redis的正常使用。RDB恢复数据比其他AOF（将命令写入日志）速度快</p><p>在配置文件redis.conf中搜索SNAPSHOTTING可以看到关于RDB的配置说明。配置Redis生成快照文件的时间策略，格式如下</p><pre><code>save &lt;seconds&gt; &lt;changes&gt;</code></pre><p>表示在seconds秒内至少发生了changes个key的改动这一条件被满足时，就会启动生成保存</p><p>在配置文件中有如下三列默认配置</p><pre><code>save 900 1save 300 10save 60 10000</code></pre><p>另外，<br>dbfilename属性对应RDB的文件名，默认为dump.rdb<br>dir指定RDB文件的存储位置，默认为./，当前目录<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzinigak8wj30f609pwfi.jpg" alt=""></p><p>缺点：会丢失未满足条件而发生保存的数据。<br>优点：性能高。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>如果不想有丢失数据的风险，采用AOF方式<br>每次接收到一条改变数据的命令时，就会把该命令写到一个AOF文件中，当redis重启时，可以通过执行AOF中的所有命令恢复数据</p><p>AOF功能默认为关闭状态，需要在redis.conf文件中配置</p><ul><li>appendonly：默认是no，改成yes即为开启</li><li>appendfilename：指定AOF文件名，默认为appendonly.aof</li><li>dir：指定RDB和AOF文件存放的目录</li><li>appendfsync：配置向aof文件写命令数据的策略<ul><li>no：不主动进行同步，而是完全交由操作系统来做（30秒一次），比较快但是不安全</li><li>always：每次执行写入都会执行同步，慢一点，安全</li><li>everysec：每秒执行一次，比较平衡，默认为这个</li></ul></li><li>auto-aof-rewrite-min-size：允许重写的最小AOF文件大小，默认为64M，当超过此大小时整理aof文件，去掉无用的命令（比如说重复赋值）</li><li></li></ul><p>若因某条命令让redis关闭，重启前可以对aof文件修改，删除这条命令，重启redis会自动执行该文件中的命令恢复数据</p><hr><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>为了避免单点故障，需要将数据复制多份到多台不同的服务器上，当有一台服务器上的数据更新后，自动将更新的数据同步到其他的服务器上。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>将redis服务器集群分为一个主服务器和一些从服务器，主服务器复制进行写操作并把写入的数据实时同步到从服务器，从服务器负责用于读操作。</p><p>实现</p><p>复制三份配置文件，修改不同的端口号，运行redis-server时带上配置文件的参数，即可模拟多台redis服务器的环境。</p><p>配置主redis服务器（Master）<br>在空文件中加入下面内容</p><ul><li>include 原来的配置文件路径   //表示引入之前的配置</li><li>daemonize yes //让redis后台启动</li><li>port XXXx //指定端口号</li><li>pidfile /var/run/redis_xxxx.pid //linux下给进程分配id</li><li>logfile xxxx.log //日志文件</li><li>dbfilename xxxxxx.rdb //rdb文件</li></ul><p>配置从redis服务器（Slave）<br>加入如下内容</p><ul><li>include 原来的配置文件路径 //表示引入之前的配置</li><li>daemonize yes //让redis后台启动</li><li>port XXXx //指定端口号</li><li>pidfile /var/run/redis_xxxx.pid //linux下给进程分配id</li><li>logfile xxxx.log //日志文件</li><li>dbfilename xxxxxx.rdb //rdb文件</li><li><strong>slaveof ipaddress port  //ipaddress指向主服务器的IP地址，port指定端口号</strong></li></ul><p><strong>info replication命令可以查看当前的服务器的状态信息</strong></p><p>不能在从服务器Slave上进行写操作，会提示操作失败。</p><h2 id="容灾处理"><a href="#容灾处理" class="headerlink" title="容灾处理"></a>容灾处理</h2><p>当Master服务出现故障，需手动将slave中的一个提升为master，剩下的slave挂至新的master上</p><p>步骤</p><ol><li>停掉故障的master服务</li><li>选一台slave升级到master，运行命令    </li></ol><pre><code>slaveof no one</code></pre><ol start="3"><li>切换到其他slave服务器的客户端，运行命令</li></ol><pre><code>    slaveof ipaddress port指定新的master服务地址</code></pre><hr><p>redis官方提供了解决问题的高可用方案</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a><strong>Sentinel</strong></h2><p>哨兵（多个单独运行）<br>它有三个主要任务</p><ul><li>监控：心跳检测主服务器是否正常工作</li><li>提醒：提醒管理员</li><li>自动故障转移 ：转换master</li><li>当检测到主redis服务器master出现故障，会在哨兵中（总共奇数个）产生一次投票，半数以上检测到故障时就会运行后面两个任务。</li></ul><p>配置：<br>同样是改配置文件，ip地址什么的，大同小异</p><hr><h1 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h1><p><strong>访问Redis默认没有密码，这样不安全，可以通过修改redis.conf配置文件设置密码</strong><br><strong>requirepass</strong>对应的就是密码<br>设置密码后用客户端工具cli登陆</p><p>需要在后面添加<br>-a password<br>参数登陆<br>或者使用auth password</p><p><strong>绑定ip</strong><br>同样是配置文件<br>bind这项对应的就是允许访问你redis的ip地址，默认bind 127.0.0.1，只允许本机访问。若想允许多个ip地址可以用空格分隔。</p><p><strong>修改端口</strong><br>使用默认的端口比较危险，在配置文件中把<br>port xxxx<br>这行端口修改为自己可以指定的端口，范围是1024-65535</p><p>使用<br>./redis-cli -p xxxx<br>指定端口号启动</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;multi&lt;br&gt;标记一个事务的开始，多条命令会按照先后顺序放进一个队列中，总返回OK&lt;/p&gt;
&lt;p&gt;exec&lt;br&gt;执行所有事务块的命令&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://xfff.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【redis】可视化工具以及一些基本命令对5种类型操作</title>
    <link href="http://xfff.xyz/2019/01/25/%E3%80%90redis%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%AF%B95%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C/"/>
    <id>http://xfff.xyz/2019/01/25/【redis】可视化工具以及一些基本命令对5种类型操作/</id>
    <published>2019-01-25T02:11:20.000Z</published>
    <updated>2019-01-31T09:22:22.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="#id1">redis可视化工具安装</a></li><li><a href="#id2">redis-cli命令</a></li><li><a href="#id3">Key的五种数据类型</a></li><li><p>基本命令</p><ul><li><p><a href="#id4">字符串类型</a></p></li><li><p><a href="#id5">哈希类型hash</a></p></li><li><p><a href="#id6">列表list</a></p></li><li><p><a href="#id7">集合类型set</a></p></li><li><p><a href="#id8">有序集合zset</a></p></li></ul></li></ol><hr><p>redis关闭<br>./redis-cli shutdown<br>kill 进程</p><p>连接指定地址的redis<br>./redis-cli -h 127.0.0.1 -p 6379</p><p><span id="id1"></span></p><h2 id="redis-desktop-manager"><a href="#redis-desktop-manager" class="headerlink" title="redis desktop manager"></a>redis desktop manager</h2><p>redis的可视化管理工具<br>download</p><blockquote><p><a href="https://pan.baidu.com/s/1kU8sY3P" target="_blank" rel="noopener">https://pan.baidu.com/s/1kU8sY3P</a><br>官网<br><a href="https://redisdesktop.com/download" target="_blank" rel="noopener">https://redisdesktop.com/download</a><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhprjmfjgj30ue0hyjsn.jpg" alt=""></p></blockquote><hr><p>需要连接网络上的redis时，需要修改服务器上的redis.conf配置文件，首先注释<br>bind 127.0.0.1<br>这行<br>然后将下面的protocol保护yes改为no<br>启动时命令后面加上conf属性作为参数</p><hr><hr><p><span id="id2"></span></p><h2 id="redis-cli命令"><a href="#redis-cli命令" class="headerlink" title="redis-cli命令"></a>redis-cli命令</h2><p><strong>ping</strong>查看redis服务是否正常运行，返回PONG代表正常</p><p><strong>DBSIZE</strong>查看当前数据库的key数量</p><p>redis默认使用16个库，可以通过修改配置文件修改数量</p><p>通过<strong>select</strong> db切换库</p><p><strong>flushdb</strong>清空库里的内容</p><p>退出client工具：<strong>exit</strong></p><p><strong>keys</strong> pattern查找符合pattern匹配的key（尽量不使用key *，redis单线程接收请求，若key过多，会给redis造成很大压力）</p><p>exists key [keys…]<br>判断该key是否存在</p><p>expire key seconds<br>设置key的存活时间，超过时间就删除<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhr6o7r3hj30bg048t8l.jpg" alt=""></p><p>ttl key<br>查看该key存活剩余时间（”验证码超时作废”）</p><p>type key<br>返回key类型</p><p>del key [keys]<br>删除对应的key，并返回删除成功的个数</p><hr><p><span id="id3"></span></p><h2 id="Key的五种数据类型"><a href="#Key的五种数据类型" class="headerlink" title="Key的五种数据类型"></a>Key的五种数据类型</h2><ol><li><p>字符串类型<br>k1 value</p></li><li><p>hash类型map<br> HashMap&lt;String,String&gt; data=new HashMap&lt;&gt;();<br> k1 data</p><p> 其中k1称为key，data里的key称为field</p></li></ol><ol start="3"><li>列表类型list<br> k1 [value1，value2，value3]<br> 下标012     </li></ol><ol start="4"><li><p>集合类型set<br> 无序，元素不重复</p></li><li><p>有序集合类型zset<br> 有序set集合</p></li></ol><hr><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><span id="id4"></span></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>set key value<br>相当于sql里的saveorupdate</p><p>get key<br>获取key对应的value</p><p>incr key<br>对key的value值加1，只能对数字类型，如果key不存在，则创建该key初始化key值为0再加1</p><p>decr key<br>减一，其他同上</p><p>append key value<br>如果key存在，则将value追加到原值末尾<br>否则新建该key</p><p>strlen key<br>求key对应的字符串长度</p><p>getrange key start end<br>取字符串子串，下标从0开始，从右往左的话最右边是-1<br>取的时候小的下标在左</p><p>setrange key start value<br>从start开始用value去替换key的value值，替换长度为value 的长度</p><p>mset k1 v1 k2 v2 k3 v3…<br>复数个keyvalue的定义</p><p>mget k1 k2 k3…<br>复数个key 的获取</p><hr><hr><p><span id="id5"></span></p><h2 id="哈希类型hash"><a href="#哈希类型hash" class="headerlink" title="哈希类型hash"></a>哈希类型hash</h2><p>hset key field value<br>存入值<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzht5aei1kj30ak02xt8k.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzht5t6jr9j30dg02pwea.jpg" alt=""></p><p>hget key field<br>获取该key下的field对应的值</p><p>hmset<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzht77o10aj30dc00qwe9.jpg" alt=""></p><p>hmget key field1 field2….<br>获取多个field值</p><p>hgetall<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzht8tmz26j307c02fa9u.jpg" alt=""></p><p>hkeys key<br>获取该key下的所有field</p><p>hvals key<br>获取该key下的所有value</p><p>hexists key field<br>查询key下是否存在该field</p><hr><p><span id="id6"></span></p><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>lpush key value1 value2 …<br>将value一个一个插入到key表头的头部</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhtcfpyvcj309v0180si.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhtcwb9okj30bu03pt8i.jpg" alt=""></p><p>rpush key value…<br>从尾部插入</p><p>lrange key start end<br>查询下标从start到end结束的元素</p><p>lindex key index<br>查询下标为index 的元素</p><p>llen key<br>查询key对应的list 的长度</p><p>lrem key count value<br>若count&gt;0则从表左到右进行删除，删除count个与value相同的值。count若为负则相反。count=0则删除全部value值。</p><p>lset key index value<br>将index下标的值替换为value，下标超出范围就报错</p><p>linsert key BEFORE|AFTER pivot value<br>在pivot参考值前或者后面插入value值</p><hr><p><span id="id7"></span></p><h2 id="集合类型set"><a href="#集合类型set" class="headerlink" title="集合类型set"></a>集合类型set</h2><p>sadd key member…<br>将一个或多个元素添加到set集合中</p><p>smembers key<br>获取key里的所有成员元素</p><p>sismember key member<br>检查key对应集合里有无member元素</p><p>scard key<br>查询该set集合里有多少元素</p><p>srem key members…<br>删除该set集合里的member</p><p>srandmember key count<br>随机显示count个元素，不指定count默认1</p><p>spop key count<br>随机删除count个元素，不指定默认1</p><hr><p><span id="id8"></span></p><h2 id="有序集合zset"><a href="#有序集合zset" class="headerlink" title="有序集合zset"></a>有序集合zset</h2><p>zadd key score member…<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhu85lwg5j30i500l3ya.jpg" alt=""><br>score表示分数，member表示value，分数是用来排序的<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzikrg9cnkj30gs06faa3.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzikrwmxu4j30dt04rt8k.jpg" alt=""></p><p>zrange key start end [withscores]<br>显示下标从start到end的值，从小到大显示，若加上withscores会连分数一起显示<br>（同样可以从后往前用负值查询）</p><p>zrevrange key start end [withscores]<br>同上，但是是按分数从大到小显示<br>0下标对应最大的分数</p><p>zrem key member …<br>删除key里对应的member</p><p>zcard key<br>获取key元素个数</p><p>zrangebyscore key min max [withscores] [LIMIT offset count]<br>通过分数范围获取key里的值，offset表示从第几个结果开始，count表示输出几项数据</p><p>zrevrangebyscore<br>和上面相反顺序</p><p>zcount key min max<br>返回分数在min和max之间的结果有几个</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#id1&quot;&gt;redis可视化工具安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id2&quot;&gt;redis-cli命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#id3&quot;&gt;Key的五种数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基本命令&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://xfff.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【redis】windows环境和linux环境下的安装使用</title>
    <link href="http://xfff.xyz/2019/01/24/%E3%80%90redis%E3%80%91windows%E7%8E%AF%E5%A2%83%E5%92%8Clinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/24/【redis】windows环境和linux环境下的安装使用/</id>
    <published>2019-01-24T02:46:37.000Z</published>
    <updated>2019-01-31T09:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>首先，贴上官方网站地址，可以在这查询官方文档、命令等等。</p><blockquote><p><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a><br>中文版<br><a href="http://redis.cn/" target="_blank" rel="noopener">http://redis.cn/</a></p></blockquote><p>redis是非关系型数据库，运行于内存中，当项目需要请求数据库时会先查询redis数据库，以减轻主库的访问压力。</p><p>属于非关系型数据库NOSQL的redis没有固定的列与值的表形式。<br>NOSQL=NOT ONLY SQL</p><hr><h2 id="windows下安装redis"><a href="#windows下安装redis" class="headerlink" title="windows下安装redis"></a>windows下安装redis</h2><p>redis的作者并没有写适合在windows下运行的redis数据库，微软为了让更多的用户使用windows系统，自己对redis进行了修改，建造了适合在windows下运行的redis。而平时使用在服务器端的都是在linux下运行的redis，所以windows下的redis仅适合用来开发学习。</p><p>下载网站：</p><blockquote><p><a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p></blockquote><p>下载后解压到自选目录，运行<br>redis-server.exe文件见下图即表示运行成功<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhhrts2c9j30qu0b90t2.jpg" alt=""></p><hr><p>双击redis-cli.exe运行客户端工具</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhhtpdn8uj30hr0670ss.jpg" alt=""></p><hr><h2 id="Linux下安装redis"><a href="#Linux下安装redis" class="headerlink" title="Linux下安装redis"></a>Linux下安装redis</h2><p>打开官网下载压缩包</p><p>安装gcc编译器，可以用来编译运行c语言文件</p><pre><code>yum -y install gcc</code></pre><p>？好像不是这样装的，我以前装过所以不用再装</p><p>把下好的压缩包解压</p><pre><code>tar -zxvf 压缩包</code></pre><p>进入解压后的目录<br>运行make命令<br>这个时候会把目录下的C程序全部编译运行，等待运行结束出现下图<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzhoh6e39xj31ue0lc1kx.jpg" alt=""></p><p>这个时候就能进入src目录，里面有和上面windows名字差不多的可执行命令文件</p><p>如redis-server和redis-cli等</p><hr><p>若想在任意目录运行这些命令<br>要么运行时前面加上路径<br>要么<br>进入src目录<br>运行</p><pre><code>sudo make install</code></pre><p>命令</p><p>相当于把redis的命令配置在环境变量中，在任何目录都可使用</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;首先，贴上官方网站地址，可以在这查询官方文档、命令等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://xfff.xyz/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>dubboDemo搭建例子</title>
    <link href="http://xfff.xyz/2019/01/21/dubboDemo%E6%90%AD%E5%BB%BA%E4%BE%8B%E5%AD%90/"/>
    <id>http://xfff.xyz/2019/01/21/dubboDemo搭建例子/</id>
    <published>2019-01-21T01:08:11.000Z</published>
    <updated>2019-01-21T01:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个工作空间DubboDemo<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdxu1zgm4j309b05qjre.jpg" alt=""></p><p>在项目下新建module</p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p>新建service接口并编写实现类<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdxw3w8j3j30j7078wes.jpg" alt=""></p><p>将service提取到另一module中</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdxxcld7jj30bi09bmxg.jpg" alt=""></p><p>新建服务消费者module</p><p>和提供者类似将service接口提取到主module中</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdxzsttuaj30v80by405.jpg" alt=""></p><hr><p>可以看到消费者里需要用到提供者的Service</p><p>其他的domain和service需要引入主module 的依赖</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;xff&lt;/groupId&gt;   &lt;artifactId&gt;themainservice&lt;/artifactId&gt;   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;/dependency&gt;</code></pre><p>这个时候在服务提供者里添加依赖和配置文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;   &lt;groupId&gt;xff&lt;/groupId&gt;   &lt;artifactId&gt;user-service-provider&lt;/artifactId&gt;   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;   &lt;artifactId&gt;lombok&lt;/artifactId&gt;   &lt;version&gt;1.16.18&lt;/version&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xff&lt;/groupId&gt;   &lt;artifactId&gt;themainservice&lt;/artifactId&gt;   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;dubbo&lt;/artifactId&gt;   &lt;version&gt;2.6.5&lt;/version&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;   &lt;/dependency&gt; &lt;/dependencies&gt;  &lt;/project&gt;</code></pre><p>provider.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;   &lt;dubbo:application name=&quot;userserviceprovider&quot;&gt;&lt;/dubbo:application&gt;   &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;   &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;&gt;&lt;/dubbo:protocol&gt;   &lt;dubbo:service interface=&quot;service.UserService&quot; ref=&quot;userServiceImpl&quot;&gt;&lt;/dubbo:service&gt;   &lt;bean id=&quot;userServiceImpl&quot; class=&quot;service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;  &lt;/beans&gt;</code></pre><p>这样就能将服务暴露给其他服务使用</p><p>再写一个类运行</p><pre><code>public static void main(String[] args) throws IOException {      ClassPathXmlApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);    ioc.start();    System.in.read();  }</code></pre><hr><p>类似的，在服务消费者里</p><p>依赖一样</p><p>consumer.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;   &lt;context:component-scan base-package=&quot;service.impl&quot;&gt;&lt;/context:component-scan&gt;   &lt;dubbo:application name=&quot;orderserviceconsumer&quot;&gt;&lt;/dubbo:application&gt;   &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;127.0.0.1:2181&quot;&gt;&lt;/dubbo:registry&gt;   &lt;dubbo:reference interface=&quot;service.UserService&quot; id=&quot;userService&quot;&gt;&lt;/dubbo:reference&gt;  &lt;/beans&gt;</code></pre><p>写一个类测试</p><pre><code>public static void main(String[] args) throws IOException {      ApplicationContext ioc= new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);    OrderService one= ioc.getBean(OrderService.class);    Order order=new Order();    order.setPrice(123);    System.out.println(one.findPrice(order));    System.in.read();  }</code></pre><hr><p>运行</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdyp5y2xzj30i505bmxq.jpg" alt=""></p><p>这个时候打开上篇的OPS控制台可以看到服务提供者，打开在下面可以看到服务消费者正在使用</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzdyq0wp4zj30t50czdg9.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建一个工作空间DubboDemo&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sly1fzdxu1zgm4j309b05qjre.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在项目下新建module&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="分布式" scheme="http://xfff.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="dubbo" scheme="http://xfff.xyz/tags/dubbo/"/>
    
      <category term="demo" scheme="http://xfff.xyz/tags/demo/"/>
    
  </entry>
  
  <entry>
    <title>dubboOPS控制台安装使用</title>
    <link href="http://xfff.xyz/2019/01/18/dubboOPS%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/18/dubboOPS控制台安装使用/</id>
    <published>2019-01-18T02:16:50.000Z</published>
    <updated>2019-01-18T02:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zooKeeper注册中心"><a href="#zooKeeper注册中心" class="headerlink" title="zooKeeper注册中心"></a>zooKeeper注册中心</h2><p>先从该网站下载</p><blockquote><p><a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi/zookeeper/</a><br>（这里我下的3.4.12稳定版本）</p></blockquote><p>解压到自选目录下</p><p>打开bin目录</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzaj2epa5dj30gy05s74u.jpg" alt=""></p><p>zkServer是我们要运行的zookeeper服务，在地址栏输入cmd可以快速进入当前目录的命令行，但是这个时候运行会报错，我们需要改一下配置文件</p><p>打开conf目录</p><p>将zoo_sample.cfg复制粘贴一份重命名为zoo.cfg</p><p>用文本编辑器打开zoo.cfg文件</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzaj70159jj308v055wen.jpg" alt=""></p><p>上面标记的那列是产生的数据存放位置，原目录结构为linux文件结构，这里我在windows上使用，于是在上一级目录新建了一个data文件夹，并修改目录</p><p>下面的是端口号，无特殊要求使用默认的2181</p><hr><p>这个时候去运行zkServer，可以看到成功运行<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzajahm3xpj30o406twf0.jpg" alt=""></p><p>先放在后台</p><hr><p>然后可以去运行zkCli客户端，可以查看zookeeper相关的状态，get / 查看根结点下有什么值<br>使用ls /查看根结点下有什么结点<br>这个时候一般会有个zooKeeper结点<br>我们可以通过create -e /你的结点名 结点值<br>创建新结点<br>（关于zooKeeper我不太熟）</p><hr><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>接下来我们进入Dubbo官网</p><blockquote><p><a href="http://dubbo.apache.org/en-us/" target="_blank" rel="noopener">http://dubbo.apache.org/en-us/</a><br>在这能找到很多介绍指南</p></blockquote><p>进入github库，往下在README里</p><p>Dubbo eco system<br>下面最后一项</p><ul><li><a href="https://github.com/apache/incubator-dubbo-ops" target="_blank" rel="noopener">Dubbo OPS</a>  - The reference implementation for Dubbo admin<br>就是我们要找的了。<br>打开是另一个代码库，下载到本地</li></ul><p>下面可以选择中文的README，可以根据这里的介绍一步一步安装运行。</p><hr><p>我们把下载下来的压缩包解压<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzajmdtoelj30fv07ojrz.jpg" alt=""></p><p>如图，backend是springBoot项目，frontend是vue.js项目，整体采用了前后端分离的方式。</p><p>前端页面8081<br>后端端口是8080<br>我们先运行后端项目，用IDEA打开backend项目，等待依赖导入下载完成，可以直接运行，也可以将项目用maven打包</p><p>然后在项目目录的target下面可以看到一个jar文件</p><p>可以直接在该目录下的命令行运行</p><pre><code>java -jar 加上jar包名</code></pre><p>可以看到项目成功运行在8080端口，我们可以访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api</p><p>后端项目运行完成，现在去运行前端</p><p>打开frontend目录，运行</p><pre><code>npm run dev</code></pre><p>报错了，经过搜索，按下面博客的解决方式</p><blockquote><p><a href="https://www.cnblogs.com/laraLee/p/9174383.html" target="_blank" rel="noopener">https://www.cnblogs.com/laraLee/p/9174383.html</a></p></blockquote><p>运行一下npm install再npm run dev成功</p><p>打开localhost:8081，就可以看到我们需要的OPS页面了<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzajwwuqqej311y0hojsn.jpg" alt=""></p><p>记住需要zookeeper和后端项目在后台运行，否则前端只是个界面，没有实际效果…</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fzajyax34sj30hf09g0td.jpg" alt=""><br>如上是后端没有在运行时无法从8080端口获取数据的报错。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zooKeeper注册中心&quot;&gt;&lt;a href=&quot;#zooKeeper注册中心&quot; class=&quot;headerlink&quot; title=&quot;zooKeeper注册中心&quot;&gt;&lt;/a&gt;zooKeeper注册中心&lt;/h2&gt;&lt;p&gt;先从该网站下载&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="分布式" scheme="http://xfff.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="dubbo" scheme="http://xfff.xyz/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>vue从入门到放弃</title>
    <link href="http://xfff.xyz/2019/01/17/vue%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://xfff.xyz/2019/01/17/vue从入门到放弃/</id>
    <published>2019-01-17T03:26:06.000Z</published>
    <updated>2019-01-31T09:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>将对应的html标签转为html页面形式而不是字符串</p><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>加载完script里的脚本才会加载被该属性标记的元素</p><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>等同于</p><pre><code>{{}}</code></pre><p>卧槽，这里生成的时候一直报错，原来不能直接用两个花括号写在博客里，害我找了好久的错误    </p><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>告诉属性名指定的是一个变量   v-bind:text=”变量名”，可以简写为：，里面可以写表达式</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>事件绑定  v-on：事件名，简写为@</p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>数据的双向绑定，v-bind是单向绑定。</p><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>循环</p><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>通过一个flag变量控制是否移除创建元素，切换消耗较高</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>和v-if类似，但是v-show只是设置对应控件不可见，较高的初始渲染消耗</p><hr><h2 id="绑定class样式设置"><a href="#绑定class样式设置" class="headerlink" title="绑定class样式设置"></a>绑定class样式设置</h2><p>如下<br>使用：class=”[flag?’onestyle’:’’]”或者{‘onstyle’:flag}<br>可以定义一个flag标志，当为true时为标签添加class为onestyle的class属性。</p><p>也可以在对象上添加：style=’{color：’red’ , …}’或者写入data，引用变量</p><h2 id="setInterval（）"><a href="#setInterval（）" class="headerlink" title="setInterval（）"></a>setInterval（）</h2><p>定时器</p><hr><p>使用</p><p>Vue.directive()</p><p>自定义指令</p><p>配合钩子函数使用</p><hr><p>好好看了下官方文档，写的很详细，但是点实在太多了，我肯定记不住，只能使用时再查了。。。</p><p>官网</p><blockquote><p><a href="https://cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/index.html</a></p></blockquote><p>顺便贴个js学习文档</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501245426ad4b91f2b880464ba876a8e3043fc8ef000</a></p></blockquote><p>最后贴个路由使用学习</p><blockquote><p><a href="https://www.cnblogs.com/SamWeb/p/6610733.html" target="_blank" rel="noopener">https://www.cnblogs.com/SamWeb/p/6610733.html</a></p></blockquote><hr><p>枯了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;v-html&quot;&gt;&lt;a href=&quot;#v-html&quot; class=&quot;headerlink&quot; title=&quot;v-html&quot;&gt;&lt;/a&gt;v-html&lt;/h2&gt;&lt;p&gt;将对应的html标签转为html页面形式而不是字符串&lt;/p&gt;
&lt;h2 id=&quot;v-cloak&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue学习01</title>
    <link href="http://xfff.xyz/2019/01/17/vue%E5%AD%A6%E4%B9%A001/"/>
    <id>http://xfff.xyz/2019/01/17/vue学习01/</id>
    <published>2019-01-17T01:40:33.000Z</published>
    <updated>2019-01-31T09:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p><del>这个时候我还没学路由…</del></p><p>直接上使用的代码部分</p><p>main.js</p><pre><code>// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;/*import router from &apos;./router&apos;*/Vue.config.productionTip = falseVue.filter(&apos;myreverse&apos;,function(value){    return value.split(&apos;&apos;).reverse().join(&apos;&apos;);})/* eslint-disable no-new */new Vue({  el: &apos;#app&apos;,/*  router,*/  components: { App },  template: &apos;&lt;App/&gt;&apos;})</code></pre><p>由于没使用router被我注释了，<br>filter是过滤器，这里是全局定义方法，后面会介绍，其他都是模版的代码。</p><hr><p>App.vue</p><pre><code>&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;img src=&quot;./assets/logo.png&quot;&gt;    &lt;br/&gt;    &lt;hi&gt;&lt;/hi&gt;    &lt;mytest&gt;&lt;/mytest&gt;    &lt;pop&gt;&lt;/pop&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import hi from &apos;./components/hi&apos;import mytest from &apos;./components/mytest&apos;import pop from &apos;./components/pop&apos;export default {  name: &apos;App&apos;,  components:{hi,mytest,pop}}&lt;/script&gt;&lt;style&gt;#app {  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;}&lt;/style&gt;</code></pre><p>在template模版里根节点只运行存在一个div，那三个奇怪名字的是我自定义的三个页面（块）</p><hr><h2 id="hi-vue"><a href="#hi-vue" class="headerlink" title="hi.vue"></a>hi.vue</h2><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;input v-model=&quot;message&quot; placeholder=&quot;input message&quot; /&gt;    &lt;input v-model=&quot;checked&quot; type=&quot;checkbox&quot; id=&quot;checkbox1&quot; value=&quot;checkbox11&quot;&gt;11&lt;/input&gt;    &lt;input v-model=&quot;checked&quot; type=&quot;checkbox&quot; id=&quot;checkbox2&quot; value=&quot;checkbox22&quot;&gt;22&lt;/input&gt;    &lt;br/&gt;    &lt;select v-model=&quot;selected&quot;&gt;      &lt;option disable value=&quot;&quot;&gt;请选择&lt;/option&gt;      &lt;option&gt;AA&lt;/option&gt;      &lt;option&gt;BB&lt;/option&gt;      &lt;option&gt;CC&lt;/option&gt;    &lt;/select&gt;    &lt;br/&gt;    &lt;select v-model=&quot;selected1&quot; style=&quot;width: 50px;&quot;&gt;      &lt;option v-for=&quot;option in options&quot; :value=&quot;option.value&quot;&gt;      {{option.text}}      &lt;/option&gt;    &lt;/select&gt;    &lt;br/&gt;    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;a&quot; /&gt;&lt;label&gt;a&lt;/label&gt;    &lt;br/&gt;    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;b&quot; /&gt;&lt;label&gt;b&lt;/label&gt;    &lt;br/&gt;    &lt;input type=&quot;radio&quot; name=&quot;name&quot; v-model=&quot;pick&quot; value=&quot;c&quot; /&gt;&lt;label&gt;c&lt;/label&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;Message is:{{message}}&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;Message is:{{checked}}&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;select is : {{selected}}&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;select is : {{selected1}}&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;radio is : {{pick}}&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;reverse is :{{message|myreverse}}&lt;/span&gt;        &lt;br/&gt;    &lt;span&gt;up is :{{message|capitalize}}&lt;/span&gt;        &lt;br/&gt;    &lt;span&gt;myfilter3 is :{{message|myfilter('haha')}}&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &apos;hi&apos;,  data () {    return {      message: &apos;&apos;,      checked: [],      selected:&apos;&apos;,      options:[      {text:&quot;AA&quot;,value:&apos;A&apos;},      {text:&quot;BB&quot;,value:&apos;B&apos;},      {text:&quot;CC&quot;,value:&apos;C&apos;}      ],      selected1:&apos;&apos;,      pick:&apos;&apos;    }  },  filters:{  myfilter:function(value,value1){    return value.charAt(0).toLocaleUpperCase()+value.slice(1)+value1;  }  }}&lt;/script&gt;</code></pre><p>实际效果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz9bzb5mq9j30iu09zt8n.jpg" alt=""><br>这里注意在使用键值对时，value值才是选中的值，text值是选择框里的值。v-for可以对这种数组进行遍历…还有一些对字符串操作的方法等等…</p><hr><h2 id="mytest-vue"><a href="#mytest-vue" class="headerlink" title="mytest.vue"></a>mytest.vue</h2><pre><code>&lt;template&gt;&lt;div&gt;  &lt;div&gt;    &lt;h1&gt;There is mytest part----&lt;/h1&gt;    &lt;button v-on:click=&quot;count=count+1&quot;&gt;addit&lt;/button&gt;    &lt;span&gt;{{count}}&lt;/span&gt;    &lt;button v-on:click=&quot;sayhaha&quot;&gt;SAYhaha&lt;/button&gt;    &lt;button v-on:click=&quot;sayxixi&quot;&gt;SAYxixi&lt;/button&gt;  &lt;/div&gt;  &lt;br/&gt;    &lt;div id=&quot;demo&quot; @click=&quot;commonAlert&quot;&gt;        &lt;button @click.stop=&quot;alertA&quot;&gt;内部标签&lt;/button&gt;    &lt;br&gt;    &lt;span&gt;哈哈哈&lt;/span&gt;    &lt;/div&gt;    &lt;br/&gt;    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;preventWebJump&quot;&gt;百度一下&lt;/a&gt;    &lt;br/&gt;    &lt;div @click.capture=&quot;aa&quot;&gt;      &lt;div @click.capture=&quot;bb&quot;&gt;        &lt;Button @click.capture=&quot;cc&quot;&gt;冒泡&lt;/Button&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &apos;mytest&apos;,  data () {    return {      count:1    }  },  methods:{    sayhaha:function(){      alert(&quot;hahaha&quot;)    },    sayxixi:function(){      alert(&quot;xixixi&quot;)    },    commonAlert:function(){      alert(&quot;outclick!&quot;)    },    alertA:function(){      alert(&quot;innerClick!&quot;)    },    preventWebJump:function(){      alert(&quot;禁止跳转&quot;)    },    cc:function(){      alert(&quot;cc&quot;)    },    bb:function(){      alert(&quot;bb&quot;)    },    aa:function(){      alert(&quot;aa&quot;)    }  }}&lt;/script&gt;&lt;!--.once.passive.self--&gt;</code></pre><p>实际效果</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz9c09m6gej30gy06ajrb.jpg" alt=""><br>这里主要对事件处理方法进行了一些测试，还包括一些事件修饰符，实际效果用图片表现不出事件特性。<br>这里还有.once（指定事件只触发一次）.passive（和prevent相反，允许标签自带的事件）.self（冒泡事件时，不直接与该控件交互的事件会被跳过，不同于.stop是冒泡到该事件时停止）</p><hr><h2 id="pop-vue"><a href="#pop-vue" class="headerlink" title="pop.vue"></a>pop.vue</h2><pre><code>&lt;template&gt;  &lt;div id=&quot;demo&quot;&gt;  &lt;button v-on:click=&quot;greet =!greet&quot;&gt;点击&lt;/button&gt;  &lt;transition name=&quot;fade&quot;&gt;    &lt;p v-show=&quot;greet&quot;&gt;hello world jack!&lt;/p&gt;  &lt;/transition&gt;  &lt;/div&gt;  &lt;/template&gt;&lt;script&gt;  export default{    name:&apos;pop&apos;,    data(){      return{        greet:true      }    }  }&lt;/script&gt;&lt;style&gt;.fade-enter-active, .fade-leave-active {  transition: opacity 0.5s;}.fade-enter, .fade-leave-to {  opacity: 0;}&lt;/style&gt;</code></pre><p>vue定义过渡，transition标签（name=fade）内的控件在消隐时可以通过css定义过渡动画，配合三方css文件，可以达到很有意思的效果。<br>参考</p><blockquote><p><a href="https://blog.csdn.net/hanhailong18/article/details/82222316" target="_blank" rel="noopener">https://blog.csdn.net/hanhailong18/article/details/82222316</a></p></blockquote><hr><p>还有键盘输入事件绑定…<br>参考</p><blockquote><p><a href="https://blog.csdn.net/hanhailong18/article/details/82584647" target="_blank" rel="noopener">https://blog.csdn.net/hanhailong18/article/details/82584647</a></p></blockquote><p>很多点没提到，在之后的学习中再补上吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;del&gt;这个时候我还没学路由…&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;直接上使用的代码部分&lt;/p&gt;
&lt;p&gt;main.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// The Vue build version to load with the `import` command
//
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue入门安装</title>
    <link href="http://xfff.xyz/2019/01/15/vue%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85/"/>
    <id>http://xfff.xyz/2019/01/15/vue入门安装/</id>
    <published>2019-01-15T07:02:32.000Z</published>
    <updated>2019-01-31T09:26:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>入职前以为，我们写后端的，也许整天面对的就是后台的service、controller等层去开发，入职后上级和我们说后台大部分代码都可以自动生成，前端的js需要好好学习一下…</em>  </p><p><em>我晕了，前端根本没怎么重视，JavaScript也没有系统地学习，现在想了想，要不好好学一个前端的框架吧。从各个网站上了解到一些信息和趋势，决定学习时下比较热门的前端框架vue.js</em>  </p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>安装…<br>先安装个nodejs，官网下载即可（因为之前用hexo搭建博客的时候安装过了，这里就不写步骤了）  </p><p>为了减少对C盘的使用，把nodejs安装在其他盘之后，还需要更改设置，不然还是会把一些文件和缓存放在C盘<br> npm config set prefix “xxx”<br>    npm config set cache “xxx”  </p><p>新建两个文件夹,路径填入xxx即可  </p><p>安装vue-cli<br> npm install -g vue-cli</p><p>如果无法识别vue，可能是npm版本太低，运行<br> npm install -g npm </p><p>完事运行<br> vue -V   </p><p>出现版本号表示成功。  </p><hr><h2 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h2><p>命令行找个目录运行<br> vue init webpack yourproject</p><p>yourproject是项目名，webpack是vue模版，除了webpack还有其他几个模版  </p><p>这个时候会从github上下载对应的模版文件（这里也可以输入自己的自定义模版导入），途中会有很多选项，网上都建议有个ESLint选no，因为不会用…<br>其他一路回车和输入Y，最后结束命令行会显示如何开始自己的项目，以前的版本还需要install一下依赖，现在好像不需要  </p><p>反正新版本只需要cd 进入项目目录，然后<br> npm run dev </p><p>即可，在对应的页面能看到项目初始默认的页面。端口号打包目录什么的可以在config目录里修改。  </p><p>打包命令<br> npm run build </p><p>运行会生成一个dist文件夹，实际使用时只需要把该文件夹放到服务器即可。  </p><hr><p>目录结构大概是这样<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz9byntaasj304e0cnt8l.jpg" alt=""><br>开发目录为src<br>assets放静态文件<br>components放模版<br>router是vue路由<br>main.js是程序入口<br>….  </p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;入职前以为，我们写后端的，也许整天面对的就是后台的service、controller等层去开发，入职后上级和我们说后台大部分代码都可以自动生成，前端的js需要好好学习一下…&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;我晕了，前端根本没怎么重视，JavaScript也没有
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://xfff.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习使用(与mybatis plus整合)</title>
    <link href="http://xfff.xyz/2019/01/14/SpringBoot%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/14/SpringBoot学习使用/</id>
    <published>2019-01-14T02:28:28.000Z</published>
    <updated>2019-01-14T08:24:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>以一个简单的Demo为例搭建一个简单的SpringBoot项目</p><p>File–&gt;new–&gt;project</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz65o6go7mj30j10gfq3n.jpg" alt=""></p><p>如上选择<br>若没有Spring Assistant选项要在plugins里安装该插件</p><hr><p>选择各种需要的选项后，next，选web项目，取名等等这里就不写了。。。</p><p>项目建好了结构大概是这样的。（<del>这里我懒得创新的了，还有自己写的一些文件就忽略吧</del>）反正没有example里的那4个文件夹，还有resources里的mapper和static和templates。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fz65uhufyfj30a10eh0t7.jpg" alt=""></p><p>然后，打开pom文件加依赖–</p><p>这个看起来很乱，不知道为什么粘贴过来就不排版了。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;   &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;   &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;   &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;   &lt;groupId&gt;com.example&lt;/groupId&gt;   &lt;artifactId&gt;springbootdemo&lt;/artifactId&gt;   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;   &lt;name&gt;SpringBootDemo&lt;/name&gt;   &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;   &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;   &lt;/properties&gt;   &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;   &lt;/dependency&gt;   &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;scope&gt;runtime&lt;/scope&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;   &lt;scope&gt;test&lt;/scope&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.3&lt;/version&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;   &lt;artifactId&gt;velocity&lt;/artifactId&gt;   &lt;version&gt;1.7&lt;/version&gt;   &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;   &lt;version&gt;2.3&lt;/version&gt;   &lt;/dependency&gt; &lt;/dependencies&gt;   &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;   &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt;   &lt;filtering&gt;true&lt;/filtering&gt;   &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;  &lt;/project&gt;</code></pre><p>**这里有些包不配置的话后面会出错，像我就在mybatis—plus包上折腾了很久，网上很多人都说只引入mybatis-plus-boot-starter包就行，其实不对，一定要引入mybatis-plus的包。虽然你只使用mybatis-plus-boot-starter正常使用mybatis-plus封装好的mapper方法不会报错，但是当你想自定义xml文件，写语句时，使用时就会一直报如下错误</p><p>#org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)<br>这个错误网上的解释大多都是xml文件名字或者namespace不匹配，但是这样是解决不了这个问题的。只有把mybatis plus包引入后，在springboot的application.properties里加入**</p><pre><code>mybatis-plus.mapper-locations=classpath*:/mapper/*.xml</code></pre><p><strong>完美解决。</strong></p><p>另外，对于mybatis plus的版本，也有很多问题，当我使用3.0以上版本的时候，很多类会找不到，比如自动生成器的AutoGenerator。这里我懒得去找新版本该怎么使用，下次再找吧。</p><p>还有那个velocity的依赖是模版引擎的依赖，不添加后来运行也会报错</p><blockquote><p><a href="https://blog.csdn.net/qq_39609151/article/details/82855305" target="_blank" rel="noopener">https://blog.csdn.net/qq_39609151/article/details/82855305</a></p></blockquote><hr><p>利用mybatis plus的生成器生成（地址<a href="http://xfff.xyz/2019/01/10/mybatis-plus%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/">CLICK</a>）各层代码后，我们把mapper的xml文件放入resource目录下（新建mapper目录放入）。</p><p>在mapper接口类上加上注解@Mapper<br>或者在springBoot启动类上加上注解扫描mapper，如下</p><pre><code>/*@ComponentScan  @EnableAutoConfiguration*/  @SpringBootApplication  @MapperScan(&quot;com.example.mapper&quot;)  public class SpringBootDemoApplication {     public static void main(String[] args) {        SpringApplication.run(SpringBootDemoApplication.class, args);    }  }</code></pre><p>在application.properties里配置数据库和其他的属性</p><p>如下</p><pre><code>server.port=8080  spring.datasource.url=jdbc:mysql://localhost:3306/mpdemo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;&amp;serverTimezone=GMT  spring.datasource.username=root  spring.datasource.password=olonn  spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver  mybatis-plus.mapper-locations=classpath*:/mapper/*.xml  #mybatis-plus.type-aliases-package=com....</code></pre><p>这里我们用的mybatis plus就不需要别名了，另外前面引入了mybatis plus 的依赖，才能写成mybatis-plus…的形式，不然就用mybatis…（这样不能自定义xml内容）</p><hr><p>我们在xml里新写几条自定义方法语句</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;  &lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;    &lt;!-- 开启二级缓存 --&gt;  &lt;!--    &lt;cache type=&quot;org.mybatis.caches.ehcache.LoggingEhcache&quot;/&gt;--&gt;   &lt;!-- 通用查询映射结果 --&gt;  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.beans.User&quot;&gt;   &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;   &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;   &lt;result column=&quot;birth&quot; property=&quot;birth&quot; /&gt;   &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;   &lt;result column=&quot;dog&quot; property=&quot;dog&quot; /&gt;   &lt;/resultMap&gt;    &lt;!-- 通用查询结果列 --&gt;    &lt;sql id=&quot;Base_Column_List&quot;&gt;    id, name, birth, age, dog      &lt;/sql&gt;   &lt;sql id=&quot;My_Column_List&quot;&gt;    name, birth, age, dog      &lt;/sql&gt;   &lt;select id=&quot;selectFour&quot; resultType=&quot;com.example.beans.User&quot;&gt;    SELECT * from USER where id=4      &lt;/select&gt;   &lt;insert id=&quot;insertOneCo&quot;&gt;    insert into USER(&lt;include refid=&quot;My_Column_List&quot;/&gt;)            value(#{name},#{birth},#{age},#{dog})      &lt;/insert&gt;  &lt;/mapper&gt;</code></pre><p>Mapper层</p><pre><code>package com.example.mapper;  import com.example.beans.User;  import com.baomidou.mybatisplus.mapper.BaseMapper;  import org.apache.ibatis.annotations.Mapper;  /**   * &lt;p&gt;    *  Mapper 接口   * &lt;/p&gt;    *   * @author xfff   * @since 2019-01-14   */  @Mapper  public interface UserMapper extends BaseMapper&lt;User&gt; {      User selectFour();   void insertOneCo(User user);  }</code></pre><p>Service层：</p><pre><code>package com.example.service;  import com.example.beans.User;  import com.baomidou.mybatisplus.service.IService;  /**   * &lt;p&gt;    *  服务类   * &lt;/p&gt;    *   * @author xfff   * @since 2019-01-14   */public interface UserService extends IService&lt;User&gt; {      User selectFour();  }</code></pre><p>实现类：</p><pre><code>package com.example.service.impl;  import com.example.beans.User;  import com.example.mapper.UserMapper;  import com.example.service.UserService;  import com.baomidou.mybatisplus.service.impl.ServiceImpl;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  /**   * &lt;p&gt;    *  服务实现类   * &lt;/p&gt;    *   * @author xfff   * @since 2019-01-14   */@Service  public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService {      @Autowired    private UserMapper userMapper;    @Override    public User selectFour() {          User user=userMapper.selectFour();   return user;    }  }</code></pre><p>Controller：</p><pre><code>package com.example.controller;  import com.example.beans.User;  import com.example.mapper.UserMapper;  import com.example.service.UserService;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.web.bind.annotation.RequestMapping;  import org.springframework.stereotype.Controller;  import org.springframework.web.bind.annotation.ResponseBody;  import org.springframework.web.bind.annotation.RestController;  import java.util.Date;  /**   * &lt;p&gt;    *  前端控制器   * &lt;/p&gt;    *   * @author xfff   * @since 2019-01-14   */@RestController  @RequestMapping(&quot;/user&quot;)  public class UserController {      @Autowired    private UserService userService;    @Autowired    private UserMapper userMapper;    @RequestMapping(&quot;/getU&quot;)      @ResponseBody    public User user(){          return userService.selectById(4);    }      @RequestMapping(&quot;/sf&quot;)      @ResponseBody    public User selectFour(){          return userService.selectFour();    }      @RequestMapping(&quot;/haha&quot;)      @ResponseBody    public String haha(){          User auser=new User();    auser.setAge(14);    auser.setBirth(new Date());    auser.setName(&quot;HHAHAHA&quot;);    auser.setDog(&quot;OTOT&quot;);    userMapper.insertOneCo(auser);   return &quot;OKOK&quot;;    }  }</code></pre><p>运行SpringBoot启动类，该类要放在和其他包同级或上级下。</p><p>相比于SSM框架，搭建一个项目springboot快很多<br><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fz66r08nilj30p4047t8x.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fz66qhds83j30or04faaa.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fz66rkxsq0j30i106mdg7.jpg" alt=""></p><hr><p>另外，Controller上的注解若为RestController的话，返回的就是像json和普通类型数据，Controller可以返回页面。<br>具体参考</p><blockquote><p><a href="https://blog.csdn.net/wuzengwen18914044177/article/details/78342517" target="_blank" rel="noopener">https://blog.csdn.net/wuzengwen18914044177/article/details/78342517</a></p></blockquote><p>另外在springboot项目中，resource下的static目录为静态目录，可以直接在地址栏输入对应的地址访问。</p><hr><p>继续学习深入吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以一个简单的Demo为例搭建一个简单的SpringBoot项目&lt;/p&gt;
&lt;p&gt;File–&amp;gt;new–&amp;gt;project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sly1fz65o6go7mj30j10g
      
    
    </summary>
    
      <category term="SpringBoot" scheme="http://xfff.xyz/categories/SpringBoot/"/>
    
    
      <category term="mybatis_plus" scheme="http://xfff.xyz/tags/mybatis-plus/"/>
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="springboot" scheme="http://xfff.xyz/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>mybatis plus插件使用</title>
    <link href="http://xfff.xyz/2019/01/11/mybatis-plus%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/11/mybatis-plus插件使用/</id>
    <published>2019-01-11T06:16:16.000Z</published>
    <updated>2019-01-11T07:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><p>使用mybatis plus时分页</p><p>可以直接使用生成的mapper或者service封装好的分页方法</p><pre><code>userService.selectPage(new Page&lt;&gt;(6,5),null).getRecords().stream().forEach(System.out::println);</code></pre><p>但是这种方法只是物理上的分页，实际查询时会把所有记录全部查询出来，然后在内存中分页，效率不高。</p><p>一般我们使用mybatis plus 自带的分页插件实现分页功能。</p><p>首先，在spring配置文件中配置分页插件。</p><p>配置在sqlSessionFactory的bean标签下</p><pre><code>&lt;!-- 插件注册 --&gt;  &lt;property name=&quot;plugins&quot;&gt;   &lt;list&gt;  &lt;!-- 注册分页插件 --&gt;    &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.PaginationInterceptor&quot;&gt;&lt;/bean&gt;    &lt;!-- 注册执行分析插件 --&gt;    &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.SqlExplainInterceptor&quot;&gt;   &lt;property name=&quot;stopProceed&quot; value=&quot;true&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;    &lt;!-- 注册性能分析插件 --&gt;    &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.PerformanceInterceptor&quot;&gt;   &lt;property name=&quot;format&quot; value=&quot;true&quot;&gt;&lt;/property&gt;    &lt;!-- &lt;property name=&quot;maxTime&quot; value=&quot;5&quot;&gt;&lt;/property&gt; --&gt;    &lt;/bean&gt;    &lt;!-- 注册乐观锁插件 --&gt;    &lt;bean class=&quot;com.baomidou.mybatisplus.plugins.OptimisticLockerInterceptor&quot;&gt;   &lt;/bean&gt;   &lt;/list&gt;  &lt;/property&gt;</code></pre><p>在plugins属性设置里，查看源码可以看到是使用数组设值。</p><pre><code>public void setPlugins(org.apache.ibatis.plugin.Interceptor[] plugins) { /* compiled code */ }</code></pre><p>因此我们用list标签配置各种插件。</p><p>配置完成后，我们这样就能实现分页：</p><pre><code>UserService userService=ioc.getBean(UserService.class);  Page&lt;User&gt; page = new Page&lt;&gt;(3,5);  Page&lt;User&gt; emps =          userService.selectPage(page, null);  System.out.println(emps);  System.out.println(&quot;===============获取分页相关的一些信息======================&quot;);  System.out.println(&quot;总条数:&quot; +page.getTotal());  System.out.println(page.getRecords());  System.out.println(&quot;当前页码: &quot;+  page.getCurrent());  System.out.println(&quot;总页码:&quot; + page.getPages());  System.out.println(&quot;每页显示的条数:&quot; + page.getSize());  System.out.println(&quot;是否有上一页: &quot; + page.hasPrevious());  System.out.println(&quot;是否有下一页: &quot; + page.hasNext());  //将查询的结果封装到page对象中  page.setRecords(emps.getRecords());</code></pre><p>我们可以通过page对象获得我们需要的各种值。</p><hr><h1 id="分析插件"><a href="#分析插件" class="headerlink" title="分析插件"></a>分析插件</h1><h2 id="执行分析插件"><a href="#执行分析插件" class="headerlink" title="执行分析插件"></a>执行分析插件</h2><p>主要用来对数据库操作进行分析，若是全表删除或者更新操作，会导致操作失败。</p><p>和sql语句中的Explain关键字有关。</p><h2 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h2><p>可以对数据库操作进行分析，例如指定限制时间，若是对数据库的操作超时等，返回操作失败的结果。</p><hr><hr><h2 id="乐观锁插件"><a href="#乐观锁插件" class="headerlink" title="乐观锁插件"></a>乐观锁插件</h2><p>上面有配置，在表对应的javabean类里，新添字段，然后在字段上加上@Version注解。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz2myyutlqj307i01sdfn.jpg" alt=""></p><p>表中也新增该字段，然后在每次对数据库进行操作的时候，会判断你操作中的version值是否和数据库中的一致，如果此时有其他人对表中你将操作的字段进行了更改，version会自增，你的version值和表中不一致会导致操作失败。</p><hr><pre><code>&lt;!-- 定义MybatisPlus的全局策略配置--&gt;  &lt;bean id =&quot;globalConfiguration&quot; class=&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;    &lt;!-- 在2.3版本以后，dbColumnUnderline 默认值就是true --&gt;    &lt;property name=&quot;dbColumnUnderline&quot; value=&quot;true&quot;&gt;&lt;/property&gt;    &lt;!-- Mysql 全局的主键策略 --&gt;   &lt;!-- &lt;property name=&quot;idType&quot; value=&quot;0&quot;&gt;&lt;/property&gt; --&gt;    &lt;!-- Oracle全局主键策略 --&gt;    &lt;property name=&quot;idType&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;!-- 全局的表前缀策略配置 --&gt;    &lt;property name=&quot;tablePrefix&quot; value=&quot;tbl_&quot;&gt;&lt;/property&gt;    &lt;!--注入自定义全局操作      &lt;property name=&quot;sqlInjector&quot; ref=&quot;mySqlInjector&quot;&gt;&lt;/property&gt;   --&gt; &lt;!-- 注入逻辑删除 --&gt;  &lt;property name=&quot;sqlInjector&quot; ref=&quot;logicSqlInjector&quot;&gt;&lt;/property&gt;    &lt;!-- 注入逻辑删除全局值 --&gt;    &lt;property name=&quot;logicDeleteValue&quot; value = &quot;-1&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;logicNotDeleteValue&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;!-- 注入公共字段填充处理器 --&gt;    &lt;property name=&quot;metaObjectHandler&quot; ref=&quot;myMetaObjectHandler&quot;&gt;&lt;/property&gt;    &lt;!-- 注入Oracle主键Sequence --&gt;    &lt;property name=&quot;keyGenerator&quot; ref=&quot;oracleKeyGenerator&quot;&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;!-- 定义自定义注入器 --&gt;  &lt;bean id=&quot;mySqlInjector&quot; class=&quot;com.atguigu.mp.injector.MySqlInjector&quot;&gt;&lt;/bean&gt;  &lt;!-- 逻辑删除 --&gt;  &lt;bean id=&quot;logicSqlInjector&quot; class=&quot;com.baomidou.mybatisplus.mapper.LogicSqlInjector&quot;&gt;&lt;/bean&gt;  &lt;!-- 公共字段填充 处理器 --&gt;  &lt;bean id=&quot;myMetaObjectHandler&quot; class=&quot;com.atguigu.mp.metaObjectHandler.MyMetaObjectHandler&quot;&gt; &lt;/bean&gt;  &lt;!-- 配置Oracle主键Sequence --&gt;  &lt;bean id=&quot;oracleKeyGenerator&quot; class=&quot;com.baomidou.mybatisplus.incrementer.OracleKeyGenerator&quot;&gt;&lt;/bean&gt;</code></pre><hr><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>同样，配置完后，给表和对应的javabean新增一个字段，然后用上注解</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz2n8b2ocmj309i01jjr8.jpg" alt=""></p><p>这样表中每个数据被删除时并不会真正从表中移除，而是将该数据的logicFlag字段更改为-1，然后其他操作不能对该行数据进行影响。</p><hr><h2 id="自定义全局操作"><a href="#自定义全局操作" class="headerlink" title="自定义全局操作"></a>自定义全局操作</h2><p>当想自定义一个新方法的时候又不想写对应的xml文件，可以通过该方法，配置完后，在Mapper内新建一个方法</p><pre><code>public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; {     int deleteAll();  }</code></pre><p>然后新建类MySqlInjector</p><pre><code>/**   * 自定义全局操作 */public class MySqlInjector  extends AutoSqlInjector{     /**   * 扩展inject 方法，完成自定义全局操作 */  @Override    public void inject(Configuration configuration, MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass,    Class&lt;?&gt; modelClass, TableInfo table) {        //将EmployeeMapper中定义的deleteAll， 处理成对应的MappedStatement对象，加入到configuration对象中。         //注入的SQL语句    String sql = &quot;delete from &quot; +table.getTableName();    //注入的方法名   一定要与EmployeeMapper接口中的方法名一致    String method = &quot;deleteAll&quot; ;    //构造SqlSource对象    SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);    //构造一个删除的MappedStatement    this.addDeleteMappedStatement(mapperClass, method, sqlSource);    }  }</code></pre><hr><h2 id="公共字段填充器"><a href="#公共字段填充器" class="headerlink" title="公共字段填充器"></a>公共字段填充器</h2><p>如上配置之后</p><p>在需要自动填充的字段上添加注解</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz2ng4teduj3087026jr9.jpg" alt=""></p><p>这样当插入和更新操作时，会进入已注册的填充类中的方法检查</p><p><strong>MyMetaObjectHandler</strong>：</p><pre><code>/**   * 自定义公共字段填充处理器 */public class MyMetaObjectHandler extends MetaObjectHandler {     /**   * 插入操作 自动填充 */  @Override    public void insertFill(MetaObject metaObject) {        //获取到需要被填充的字段的值    Object fieldValue = getFieldValByName(&quot;name&quot;, metaObject);   if(fieldValue == null) {           System.out.println(&quot;*******插入操作 满足填充条件*********&quot;);    setFieldValByName(&quot;name&quot;, &quot;weiyunhui&quot;, metaObject);    }     }     /**   * 修改操作 自动填充 */  @Override    public void updateFill(MetaObject metaObject) {        Object fieldValue = getFieldValByName(&quot;name&quot;, metaObject);   if(fieldValue == null) {           System.out.println(&quot;*******修改操作 满足填充条件*********&quot;);    setFieldValByName(&quot;name&quot;, &quot;weiyh&quot;, metaObject);    }     }  }</code></pre><p>当满足<strong>if</strong>语句中的条件的时候，会自动为下面设置的字段填充上设置的值。</p><hr><h2 id="Oracle实现自增操作"><a href="#Oracle实现自增操作" class="headerlink" title="Oracle实现自增操作"></a>Oracle实现自增操作</h2><p>学习oracle后明白，oracle里没有mysql一样的Auto_increment字段。</p><p>一般我们使用序列Sequence来实现同样的功能</p><p>如上配置后（记得设置主键策略为IdType.INPUT）</p><p>在oracle里新建序列，然后在需要使用的javabean类上注解</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz2nntp04yj30ak02rdfu.jpg" alt=""></p><p>value值为你的序列名。</p><p>另外，我们还可以使用多个类继承一个父类，然后在父类上添加该注解，实现多个类共用一个序列。</p><hr><hr><p>另外，mybatis plus还有很多功能，如AR（Active Record），让javabean类继承Model类，然后自身可以调用对应的数据库操作方法</p><p>如<br>User user=new User()；<br>user.setId(1);<br>user.setName(“哈哈”);<br>user.updateById();</p><hr><p>还有什么动态切换数据源之类的功能…<br>具体上官网</p><blockquote><p><a href="https://mp.baomidou.com/guide/tenant.html" target="_blank" rel="noopener">https://mp.baomidou.com/guide/tenant.html</a></p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz2nroh8pyj30mx0fadr2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分页插件&quot;&gt;&lt;a href=&quot;#分页插件&quot; class=&quot;headerlink&quot; title=&quot;分页插件&quot;&gt;&lt;/a&gt;分页插件&lt;/h1&gt;&lt;p&gt;使用mybatis plus时分页&lt;/p&gt;
&lt;p&gt;可以直接使用生成的mapper或者service封装好的分页方法&lt;/p&gt;

      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis_plus" scheme="http://xfff.xyz/tags/mybatis-plus/"/>
    
  </entry>
  
  <entry>
    <title>mybatis plus自动生成代码</title>
    <link href="http://xfff.xyz/2019/01/10/mybatis-plus%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://xfff.xyz/2019/01/10/mybatis-plus自动生成代码/</id>
    <published>2019-01-10T08:16:13.000Z</published>
    <updated>2019-01-11T02:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis plus的核心功能之一就是能自动生成代码。</p><p>类似mybatis的逆向工程，但是mybatis plus能生成mapper、service、controller、serviceImpl等，而且封装好了基本的CRUD功能，在xml中找不到对应的sql语句。</p><hr><p>创建一个test类<br>如下</p><pre><code>package com.atguigu.mp.test;  import javax.swing.text.DefaultStyledDocument.AttributeUndoableEdit;  import org.junit.Test;  import org.springframework.context.ApplicationContext;  import org.springframework.context.support.ClassPathXmlApplicationContext;  import com.baomidou.mybatisplus.enums.IdType;  import com.baomidou.mybatisplus.generator.AutoGenerator;  import com.baomidou.mybatisplus.generator.config.DataSourceConfig;  import com.baomidou.mybatisplus.generator.config.GlobalConfig;  import com.baomidou.mybatisplus.generator.config.PackageConfig;  import com.baomidou.mybatisplus.generator.config.StrategyConfig;  import com.baomidou.mybatisplus.generator.config.rules.DbType;  import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;  public class TestMP {     /**   * 代码生成    示例代码 */  @Test    public void testGenerator() {        //1. 全局配置    GlobalConfig config = new GlobalConfig();    config.setActiveRecord(true) // 是否支持AR模式    .setAuthor(&quot;weiyunhui&quot;) // 作者  /*         .setOutputDir(&quot;D:\\workspace_mp\\mp03\\src\\main\\java&quot;) // 生成路径*/    .setOutputDir(&quot;E:\\study\\代码\\jjjj\\代码\\mp03\\src\\main\\java&quot;)             .setFileOverride(true)  // 文件覆盖    .setIdType(IdType.AUTO) // 主键策略    .setServiceName(&quot;%sService&quot;)  // 设置生成的service接口的名字的首字母是否为I   // IEmployeeService  .setBaseResultMap(true)             .setBaseColumnList(true);    //2. 数据源配置    DataSourceConfig  dsConfig  = new DataSourceConfig();    dsConfig.setDbType(DbType.MYSQL)  // 设置数据库类型    .setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;)              .setUrl(&quot;jdbc:mysql://localhost:3306/mpdemo?useSSL=false&amp;&amp;serverTimezone=GMT&quot;)              .setUsername(&quot;root&quot;)              .setPassword(&quot;olonn&quot;);    //3. 策略配置    StrategyConfig stConfig = new StrategyConfig();    stConfig.setCapitalMode(true) //全局大写命名    .setDbColumnUnderline(true)  // 指定表名 字段名是否使用下划线    .setNaming(NamingStrategy.underline_to_camel) // 数据库表映射到实体的命名策略    .setInclude(&quot;user&quot;)       ;    /*.setTablePrefix(&quot;tbl_&quot;)   .setInclude(&quot;tbl_employee&quot;);  // 生成的表*/       //4. 包名策略配置    PackageConfig pkConfig = new PackageConfig();    pkConfig.setParent(&quot;com.atguigu.mp&quot;)              .setMapper(&quot;mapper&quot;)              .setService(&quot;service&quot;)              .setController(&quot;controller&quot;)              .setEntity(&quot;beans&quot;)              .setXml(&quot;mapper&quot;);    //5. 整合配置    AutoGenerator  ag = new AutoGenerator();    ag.setGlobalConfig(config)          .setDataSource(dsConfig)          .setStrategy(stConfig)          .setPackageInfo(pkConfig);    //6. 执行    ag.execute();    }  }</code></pre><p>添加相关的依赖</p><p>这里我的数据库使用的mysql8.0，用的mysql-connector-java5.1.37报错，我改成了mysql-connector-java8.0.11，结果还是出错，提示SSL什么的，于是在url后加上了useSSL=false，然后又提示时区的错误，又在后面加上了serverTimezone=GMT，终于能运行成功了。</p><p>解决方法参考:</p><blockquote><p><a href="https://blog.csdn.net/qq_37630354/article/details/82814330" target="_blank" rel="noopener">https://blog.csdn.net/qq_37630354/article/details/82814330</a><br><a href="https://blog.csdn.net/u010429286/article/details/7775017" target="_blank" rel="noopener">https://blog.csdn.net/u010429286/article/details/7775017</a></p></blockquote><p>后记，我又遇到了新的连接问题，本来好好的，结果这次登陆又不能连接数据库了，网上查了一遍，在url后面加上了allowPublicKeyRetrieval=true得到解决<br>参考:</p><blockquote><p><a href="https://blog.csdn.net/Yuriey/article/details/80423504" target="_blank" rel="noopener">https://blog.csdn.net/Yuriey/article/details/80423504</a></p></blockquote><hr><p>运行成功会将对应库里的表生成各类文件，对应结构是这样的</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fz1l344lyfj30920dmaab.jpg" alt=""></p><hr><p>生成的mapper和service都包含基本的CRUD功能，另外，生成的service接口使用时，由于在impl实现类上使用了注解，所以实际@Autowired注解的service是一个实现类。</p><hr><p>大部分细节都写在代码里的注释中——</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mybatis plus的核心功能之一就是能自动生成代码。&lt;/p&gt;
&lt;p&gt;类似mybatis的逆向工程，但是mybatis plus能生成mapper、service、controller、serviceImpl等，而且封装好了基本的CRUD功能，在xml中找不到对应的sq
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis_plus" scheme="http://xfff.xyz/tags/mybatis-plus/"/>
    
  </entry>
  
  <entry>
    <title>mybatis plus简单使用</title>
    <link href="http://xfff.xyz/2019/01/09/mybatis-plus%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2019/01/09/mybatis-plus简单使用/</id>
    <published>2019-01-09T07:44:16.000Z</published>
    <updated>2019-01-10T03:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，贴上官网</p><blockquote><p><a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a></p></blockquote><p><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><hr><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><pre><code>&lt;dependency&gt;   &lt;groupId&gt;com.baomidou&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;   &lt;version&gt;2.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.12&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;   &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;   &lt;version&gt;1.1.11&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;com.mchange&lt;/groupId&gt;   &lt;artifactId&gt;c3p0&lt;/artifactId&gt;   &lt;version&gt;0.9.5.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--spring--&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;   &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;   &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-web&lt;/artifactId&gt;   &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;   &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;   &lt;version&gt;5.1.2.RELEASE&lt;/version&gt;  &lt;/dependency&gt;</code></pre><hr><p><strong>新建一个pojo类，对应表的字段</strong></p><pre><code>package com.xff.pojo;  import com.baomidou.mybatisplus.annotations.TableId;  import com.baomidou.mybatisplus.enums.IdType;  import java.util.Date;  /**   * * 这里可以使用@TableName()指定映射的表名 */public class User {      @TableId(value = &quot;id&quot;,type = IdType.AUTO)//value是对应数据库字段的名称，type为主键策略    private int id;   private String name;   private Date birth;   private int age;   private String dog;    /**   * 如果变量名和表里的字段名不符 * 可以使用@TableField指定对应表中的字段 * * @return    */    public int getId() {          return id;    }      public void setId(int id) {          this.id = id;    }      public String getName() {          return name;    }      public void setName(String name) {          this.name = name;    }      public Date getBirth() {          return birth;    }      public void setBirth(Date birth) {          this.birth = birth;    }      public int getAge() {          return age;    }      public void setAge(int age) {          this.age = age;    }      public String getDog() {          return dog;    }      public void setDog(String dog) {          this.dog = dog;    }      @Override    public String toString() {          return &quot;User{&quot; +                  &quot;id=&quot; + id +                  &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +                  &quot;, birth=&quot; + birth +                  &quot;, age=&quot; + age +                  &quot;, dog=&apos;&quot; + dog + &apos;\&apos;&apos; +                  &apos;}&apos;;    }  }</code></pre><hr><p><strong>新建一个Mapper并继承Mybatis Plus里的BaseMapper类</strong></p><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {  }</code></pre><hr><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;   &lt;context:component-scan base-package=&quot;com.xff.service&quot;/&gt;   &lt;context:component-scan base-package=&quot;com.xff.mapper&quot; /&gt;   &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;   &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;   &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;   &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;   &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;   &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;   &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean&quot;&gt;    &lt;!-- 加载mybatis的配置文件 --&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot; /&gt;    &lt;!-- 数据源 --&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;property name=&quot;globalConfig&quot; ref=&quot;globalConfiguration&quot; /&gt;   &lt;/bean&gt;    &lt;!--mybatisplus全局配置--&gt;    &lt;bean id=&quot;globalConfiguration&quot; class=&quot;com.baomidou.mybatisplus.entity.GlobalConfiguration&quot;&gt;    &lt;!--   在2.3版本以后，dbColumnUnderline 默认值就是true 驼峰命名转换为下划线命名 user_name对应userName --&gt;  &lt;property name=&quot;dbColumnUnderline&quot; value=&quot;true&quot;&gt;&lt;/property&gt;    &lt;!--   全局的主键策略 省去了@TableId(value = &quot;id&quot;, type = IdType.AUTO)为主键策略 --&gt; &lt;!-- &lt;property name=&quot;idType&quot; value=&quot;0&quot;&gt;&lt;/property&gt; --&gt;   &lt;!-- 全局的表前缀策略配置 省略了@TableName(&quot;employee&quot;) ，如果你的表名为bt1_user --&gt; &lt;!-- &lt;property name=&quot;tablePrefix&quot; value=&quot;tbl_&quot;&gt;&lt;/property&gt; --&gt;  &lt;/bean&gt;    &lt;!--Mapper注册--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;   &lt;property name=&quot;basePackage&quot; value=&quot;com.xff.mapper&quot; /&gt;   &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;    &lt;!--事务配置--&gt;    &lt;bean id=&quot;transactionManager&quot;    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;   &lt;/bean&gt;   &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;  &lt;/beans&gt;</code></pre><hr><h2 id="数据库配置db-properties"><a href="#数据库配置db-properties" class="headerlink" title="数据库配置db.properties"></a>数据库配置db.properties</h2><pre><code>jdbc.driver=com.mysql.jdbc.Driver  jdbc.url=jdbc:mysql://localhost:3306/mpdemo  jdbc.username=root  jdbc.password=olonn</code></pre><hr><h2 id="mybatis配置文件"><a href="#mybatis配置文件" class="headerlink" title="mybatis配置文件"></a>mybatis配置文件</h2><pre><code>&lt;!DOCTYPE configuration    PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;   &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  &lt;configuration&gt;  &lt;/configuration&gt;</code></pre><hr><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>import com.xff.mapper.UserMapper;  import com.xff.pojo.User;  import com.xff.service.UserService;  import org.junit.Test;  import org.springframework.beans.BeansException;  import org.springframework.context.ApplicationContext;  import org.springframework.context.support.ClassPathXmlApplicationContext;  import java.util.Date;  import java.util.List;  public class TestMP {      public TestMP() throws BeansException {      }      @Test    public void test() throws BeansException {          ApplicationContext ioc=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    UserMapper userMapper=ioc.getBean(UserMapper.class);    UserService userService=ioc.getBean(UserService.class);    System.out.println(userService.selectById(1));    User user=new User();    user.setAge(111);    user.setBirth(new Date());    user.setName(&quot;嘻哈哈&quot;);    user.setDog(&quot;MDOG&quot;);    userService.insert(user);    List&lt;User&gt; alist=userService.selectList(null);    System.out.println(alist.get(0).toString()+alist.get(1).toString());    /* new com.xff.Test().selectMM();*/    }  }</code></pre><hr><p>打印信息</p><pre><code>User{id=1, name=&apos;呜哈哈&apos;, birth=Wed Jan 09 00:00:00 CST 2019, age=43, dog=&apos;tony&apos;}User{id=2, name=&apos;嘻哈哈&apos;, birth=Wed Jan 09 00:00:00 CST 2019, age=111, dog=&apos;MDOG&apos;}</code></pre><hr><p>可以看到mybatis plus并不需要我们写对应的mapperxml文件，就能进行数据库访问。</p><p>实际上好像是封装了一个mapperProxy代理类，会生成对应的sql语句，只需要继承BaseMapper接口类即可。后续再追详细代码…</p><hr><h2 id="过程中遇到的问题"><a href="#过程中遇到的问题" class="headerlink" title="过程中遇到的问题:"></a>过程中遇到的问题:</h2><blockquote><p><a href="https://blog.csdn.net/m0_38064463/article/details/80795840" target="_blank" rel="noopener"># org.xml.sax.SAXParseException; lineNumber: 2; columnNumber: 1; 文件提前结束。</a></p></blockquote><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/qq_37171353/article/details/80887280" target="_blank" rel="noopener">https://blog.csdn.net/qq_37171353/article/details/80887280</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，贴上官网&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.baomidou.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.baomidou.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis_plus" scheme="http://xfff.xyz/tags/mybatis-plus/"/>
    
  </entry>
  
  <entry>
    <title>使用StackEdit为markdown格式画图</title>
    <link href="http://xfff.xyz/2019/01/07/%E4%BD%BF%E7%94%A8StackEdit%E4%B8%BAmarkdown%E6%A0%BC%E5%BC%8F%E7%94%BB%E5%9B%BE/"/>
    <id>http://xfff.xyz/2019/01/07/使用StackEdit为markdown格式画图/</id>
    <published>2019-01-07T02:21:22.000Z</published>
    <updated>2019-01-07T02:32:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h2><p>SmartyPants converts ASCII punctuation characters into “smart” typographic punctuation HTML entities. For example:</p><table><thead><tr><th></th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><h2 id="KaTeX"><a href="#KaTeX" class="headerlink" title="KaTeX"></a>KaTeX</h2><p>You can render LaTeX mathematical expressions using <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">KaTeX</a>:</p><p>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p><p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p><blockquote><p>You can find more information about <strong>LaTeX</strong> mathematical expressions <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="UML-diagrams"><a href="#UML-diagrams" class="headerlink" title="UML diagrams"></a>UML diagrams</h2><p>You can render UML diagrams using <a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">Mermaid</a>. For example, this will produce a sequence diagram:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Alice -&gt;&gt; Bob: Hello Bob, how are you?</span><br><span class="line">Bob--&gt;&gt;John: How about you John?</span><br><span class="line">Bob--x Alice: I am good thanks!</span><br><span class="line">Bob-x John: I am good thanks!</span><br><span class="line">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.</span><br><span class="line"></span><br><span class="line">Bob--&gt;Alice: Checking with John...</span><br><span class="line">Alice-&gt;John: Yes... John, how are you?</span><br></pre></td></tr></table></figure><p>And this will produce a flow chart:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Square Rect] -- Link text --&gt; B((Circle))</span><br><span class="line">A --&gt; C(Rod Rect)</span><br><span class="line">B --&gt; D&#123;Rhombus&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure><hr><hr><pre><code>## SmartyPants  SmartyPants converts ASCII punctuation characters into &quot;smart&quot; typographic punctuation HTML entities. For example:  |  |ASCII |HTML |  |----------------|-------------------------------|-----------------------------|  |Single backticks|`&apos;Isn&apos;t this fun?&apos;`  |&apos;Isn&apos;t this fun?&apos; |  |Quotes |`&quot;Isn&apos;t this fun?&quot;`  |&quot;Isn&apos;t this fun?&quot; |  |Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|  ## KaTeX  You can render LaTeX mathematical expressions using [KaTeX](https://khan.github.io/KaTeX/):  The *Gamma function* satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral  $$  \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.  $$  &gt; You can find more information about **LaTeX** mathematical expressions [here](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference).  ## UML diagrams  You can render UML diagrams using [Mermaid](https://mermaidjs.github.io/). For example, this will produce a sequence diagram:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram  </span><br><span class="line">Alice -&gt;&gt; Bob: Hello Bob, how are you?  </span><br><span class="line">Bob--&gt;&gt;John: How about you John?  </span><br><span class="line">Bob--x Alice: I am good thanks!  </span><br><span class="line">Bob-x John: I am good thanks!  </span><br><span class="line">Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.  </span><br><span class="line">  </span><br><span class="line">Bob--&gt;Alice: Checking with John...  </span><br><span class="line">Alice-&gt;John: Yes... John, how are you?  </span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">And this will produce a flow chart:  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">```mermaid  </span><br><span class="line">graph LR  </span><br><span class="line">A[Square Rect] -- Link text --&gt; B((Circle))  </span><br><span class="line">A --&gt; C(Rod Rect)  </span><br><span class="line">B --&gt; D&#123;Rhombus&#125;  </span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SmartyPants&quot;&gt;&lt;a href=&quot;#SmartyPants&quot; class=&quot;headerlink&quot; title=&quot;SmartyPants&quot;&gt;&lt;/a&gt;SmartyPants&lt;/h2&gt;&lt;p&gt;SmartyPants converts ASCII punctua
      
    
    </summary>
    
      <category term="tools" scheme="http://xfff.xyz/categories/tools/"/>
    
    
      <category term="Markdown" scheme="http://xfff.xyz/tags/Markdown/"/>
    
      <category term="StackEdit" scheme="http://xfff.xyz/tags/StackEdit/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis传参方法</title>
    <link href="http://xfff.xyz/2019/01/07/Mybatis%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95/"/>
    <id>http://xfff.xyz/2019/01/07/Mybatis传参方法/</id>
    <published>2019-01-07T02:15:05.000Z</published>
    <updated>2019-01-07T02:58:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Mybatis在xml文件中使用接口类传来的参数一般设置parameterType类型，然后在对应的接口方法中传入相应类型的参数，即可在xml语句中使用上面的参数</em></p><p>然而我今天在使用中遇到了不使用parameterType的方式，记录一下</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>一般来说，我们传多个参数可以使用parameterType，自定义一个pojo类，然后把想传入的多个参数放入该类中，parameterType指定该类，即可通过该类调用其中包含的多个参数。</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>若是不想多定义pojo类</p><p>那么可以定义参赛为一个Map类型，如何取其中的参数呢？</p><p>在xml文件中可以不用写parameterType类型，然后想使用时使用#{key}，key填入你map里的键值，即可取到对应的值</p><blockquote><p>参考 <a href="https://blog.csdn.net/u014268482/article/details/80622216" target="_blank" rel="noopener">https://blog.csdn.net/u014268482/article/details/80622216</a></p></blockquote><h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>不用传Map，直接传入多个参数，在调用时直接#{0},#{1}….</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyxtywczrkj30hm0620tf.jpg" alt=""></p><h2 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h2><p>基于注解</p><p>在接口方法中传入Map类型参数，并在参数前加上@<strong>param</strong>(“<strong>myparam</strong>“)注解，然后在xml中调用参数时</p><ul><li>${myparam.key}，参数默认为字符串</li><li>#{myparam.key}，参数可以为多种类型</li></ul><blockquote><p>参考 <a href="https://blog.csdn.net/earthhour/article/details/79635633" target="_blank" rel="noopener">https://blog.csdn.net/earthhour/article/details/79635633</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Mybatis在xml文件中使用接口类传来的参数一般设置parameterType类型，然后在对应的接口方法中传入相应类型的参数，即可在xml语句中使用上面的参数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然而我今天在使用中遇到了不使用parameterType的方式，记录一下&lt;/p
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="传参" scheme="http://xfff.xyz/tags/%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>fish学习</title>
    <link href="http://xfff.xyz/2019/01/03/fish%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xfff.xyz/2019/01/03/fish学习/</id>
    <published>2019-01-03T09:02:07.000Z</published>
    <updated>2019-01-03T09:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>fish，前端框架。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fyticwu43jj30jc0aot9e.jpg" alt=""></p><hr><p>安装命令<br>$ npm i -g @ngweb/fish-cli –registry <a href="http://registry.npm.ztesoft.com" target="_blank" rel="noopener">http://registry.npm.ztesoft.com</a></p><h3 id="fish-new或n-lt-project-name-gt"><a href="#fish-new或n-lt-project-name-gt" class="headerlink" title="fish new或n &lt;project-name&gt;"></a><code>fish new或n &lt;project-name&gt;</code></h3><p>创建项目</p><h3 id="fish-config或c"><a href="#fish-config或c" class="headerlink" title="fish config或c"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-config%E6%88%96c" target="_blank" rel="noopener"></a><code>fish config或c</code></h3><p>在当前目录下，创建fish.config.js文件</p><h3 id="fish-serve或s-p-port-port-w-watch"><a href="#fish-serve或s-p-port-port-w-watch" class="headerlink" title="fish serve或s [-p port/--port] [-w / --watch]"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-serve%E6%88%96s-p-port-port-w-watch" target="_blank" rel="noopener"></a><code>fish serve或s [-p port/--port] [-w / --watch]</code></h3><p>启动服务，-p/–port设置启动端口号，-w/–watch设置是否热部署(实时编译，自动刷新)，一般适用于fish-cli初始化的项目(标准目录)，同时生成sourcemaps。</p><h3 id="fish-generate-module-lt-module-name-gt"><a href="#fish-generate-module-lt-module-name-gt" class="headerlink" title="fish generate module &lt;module-name&gt;"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-generate-module-module-name" target="_blank" rel="noopener"></a><code>fish generate module &lt;module-name&gt;</code></h3><p>创建模块，支持缩写  <code>fish g module &lt;module-name&gt;</code>，这里的  <code>module-name</code>  可以是相对路径</p><h3 id="fish-generate-view-lt-file-name-gt"><a href="#fish-generate-view-lt-file-name-gt" class="headerlink" title="fish generate view &lt;file-name&gt;"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-generate-view-file-name" target="_blank" rel="noopener"></a><code>fish generate view &lt;file-name&gt;</code></h3><p>在当前目录下创建文件/文件夹，支持缩写  <code>fish g view &lt;file-name&gt;</code>，这里的  <code>file-name</code>  可以是相对路径</p><h3 id="fish-update-version"><a href="#fish-update-version" class="headerlink" title="fish update [version]"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-update-version" target="_blank" rel="noopener"></a><code>fish update [version]</code></h3><p>更新目录fish-desktop版本。命令会自动找到目录下第一个fish-desktop所在目录，进行覆盖更新。可指定版本号，不指定则更新至最新版本</p><h3 id="fish-addon-lt-addon-name-gt"><a href="#fish-addon-lt-addon-name-gt" class="headerlink" title="fish addon &lt;addon-name&gt;"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-addon-addon-name" target="_blank" rel="noopener"></a><code>fish addon &lt;addon-name&gt;</code></h3><p>添加  <code>fish-desktop</code>  提供的第三方组件</p><h2 id="eslint检测"><a href="#eslint检测" class="headerlink" title="eslint检测"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#eslint%E6%A3%80%E6%B5%8B-1" target="_blank" rel="noopener"></a>eslint检测</h2><p>读取项目根目录下.eslintrc文件，运行eslint，检测js规范</p><h3 id="fish-build"><a href="#fish-build" class="headerlink" title="fish build"></a><a href="http://gitlab.iwhalecloud.com/fish/fish-cli/blob/develop/README.md#fish-build" target="_blank" rel="noopener"></a><code>fish build</code></h3><p>编译、压缩、autoprefix样式文件，输出到styles文件夹里，并将fontAweSome字体拷贝至styles，可在fish.config.js里配置编译文件和编译方式</p><hr><p>fish new myapp<br>新建一个fish项目<br><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fytiid3xs3j30g6077q3g.jpg" alt=""></p><p>项目结构为<br>fish serve -w<br>编译运行，进入localhost:8088<br>即可见到fish项目原始页面</p><hr><p>index.html为入口</p><pre><code>&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;    &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;    &lt;title&gt;myapp&lt;/title&gt;    &lt;link href=&quot;image/favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;frm/fish-desktop/css/fish-desktop-default.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/css/myapp-proj-all.css&quot;&gt;    &lt;!--[if lt IE 9]&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/libs/bootstrap/respond.js&quot;&gt;&lt;/script&gt;    &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/js/fish-desktop-all.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;frm/fish-desktop/js/fish-desktop-require.js&quot; data-main=&quot;main&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>加载到data-main时会读取main.js文件，在main.js中</p><pre><code>fish.View.configure({manage: true});require([&apos;modules/main/views/IndexView&apos;], function(IndexView){    new IndexView().render();})</code></pre><p>加载IndexView.js文件</p><p>在modules模块目录下<br>按照路径找到IndexView.js文件</p><pre><code>define([    &apos;hbs!modules/main/templates/IndexView.html&apos;,    &apos;i18n!modules/main/i18n/IndexView.i18n&apos;],function(tpl, i18n) {    var me = null;    return fish.View.extend({        el:&apos;body&apos;,        template: tpl,        i18nData: fish.extend({}, i18n), // i18nData: fish.extend({}, i18n, commonI18n),        //提供模板数据        serialize: function () {            return this.i18nData;        },        //视图事件定义        events:{},        //一些初始化设置 (不能进行dom操作)        initialize: function() {            me = this;        },        //视图渲染完毕处理函数        afterRender: function() {        },        // 视图被删除时候做的事情        cleanup: function () {            me = null;        }            });});</code></pre><p>指向templates/IndexView.html</p><p>找到IndexView.html</p><pre><code>&lt;p&gt;Welcome to fish...&lt;/p&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;fish，前端框架。&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sgy1fyticwu43jj30jc0aot9e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;安装命令&lt;br&gt;$ npm i -g @ngweb/f
      
    
    </summary>
    
      <category term="前端" scheme="http://xfff.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="fish" scheme="http://xfff.xyz/tags/fish/"/>
    
  </entry>
  
  <entry>
    <title>The Messenger通关</title>
    <link href="http://xfff.xyz/2019/01/02/The-Messenger%E9%80%9A%E5%85%B3/"/>
    <id>http://xfff.xyz/2019/01/02/The-Messenger通关/</id>
    <published>2019-01-02T01:02:26.000Z</published>
    <updated>2019-01-02T02:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>元旦通关了一款2018年出的解密复古风小游戏，感觉还蛮有意思的。<br>《The Messenger》中译叫信使。</p><p>游戏中会记录死亡数。</p><p>有只恶魔在旁边负责复活你，复活之后会把你吃的碎片（类似金币）给吞掉。并且，每死一次都要嘲讽你，特别烦人啊hhh</p><p>然后，后期来了一个叫堕落的未来的地方，遇到一直巨大的怪，bgm全变了，感觉有点恐怖。这个时候你死了，恶魔也不说话了，直接默默把你复活，感觉设计的还是很有意思。</p><p>就是下面这个东西。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fyrzpn1xzvj311y0lcqau.jpg" alt=""></p><p>就在我截图出来后回去，发现居然出bug了，大怪兽不知道为什么不追我了， 然后</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys07btpkhj311y0lcwmj.jpg" alt=""></p><p>调戏一下</p><p>要不是这个bug，我可能又要多死几十次</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys08upvhqj311y0lcgr7.jpg" alt=""></p><p>八音盒解锁</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys09oh8gyj311y0lctdj.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0a79ckmj311y0lcdks.jpg" alt=""></p><p>场景设计的很有意思</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0atb7ovj311y0lcnau.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sgy1fys0b5vij7j311y0lc0z7.jpg" alt=""></p><p>死了400+次总算是通关了。</p><p>最难拿的一个封印</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fys0c3502xj311y0lcdh6.jpg" alt=""></p><p>辛辛苦苦拿了四十几个封印，居然只是解锁一个回旋镖，这个做的太伤人心了叭！</p><hr><hr><p>通关还是蛮有成就感的233</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;元旦通关了一款2018年出的解密复古风小游戏，感觉还蛮有意思的。&lt;br&gt;《The Messenger》中译叫信使。&lt;/p&gt;
&lt;p&gt;游戏中会记录死亡数。&lt;/p&gt;
&lt;p&gt;有只恶魔在旁边负责复活你，复活之后会把你吃的碎片（类似金币）给吞掉。并且，每死一次都要嘲讽你，特别烦人啊hh
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记，游戏" scheme="http://xfff.xyz/tags/%E6%9D%82%E8%AE%B0%EF%BC%8C%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux&amp;shell学习</title>
    <link href="http://xfff.xyz/2018/12/27/linux-shell%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xfff.xyz/2018/12/27/linux-shell学习/</id>
    <published>2018-12-27T01:18:08.000Z</published>
    <updated>2018-12-27T01:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1m3hagrj321c10w1ca.jpg" alt=""></p><hr><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mmoq4jj32cg168nld.jpg" alt=""></p><hr><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyl1mw2ld7j321c10wwyg.jpg" alt=""></p><p>….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006azB5Sly1fyl1m3hagrj321c10w1ca.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006
      
    
    </summary>
    
      <category term="linux" scheme="http://xfff.xyz/categories/linux/"/>
    
    
      <category term="linux" scheme="http://xfff.xyz/tags/linux/"/>
    
      <category term="shell" scheme="http://xfff.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记2</title>
    <link href="http://xfff.xyz/2018/12/25/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://xfff.xyz/2018/12/25/Oracle学习笔记2/</id>
    <published>2018-12-25T05:13:32.000Z</published>
    <updated>2019-01-31T09:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DDL（database-define-language）数据库定义语言"><a href="#DDL（database-define-language）数据库定义语言" class="headerlink" title="DDL（database define language）数据库定义语言"></a>DDL（database define language）数据库定义语言</h2><p>创建表：create table tablename（….）</p><p>修改表：alter table tablename add（columnname type …）;<br>alter table tablename modify …</p><p>删除表：drop table tablename</p><hr><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>主键Primary key</li><li>非空约束NOT NULL</li><li>唯一约束Unique</li><li>外键约束foreign key</li><li>检查性约束check（加在列后写上对列条件）</li></ul><hr><h2 id="DML（database-manager-language）数据库操作语言"><a href="#DML（database-manager-language）数据库操作语言" class="headerlink" title="DML（database manager language）数据库操作语言"></a>DML（database manager language）数据库操作语言</h2><p>INSERT INTO TABLENAME() VALUES()</p><p>UPDATE TABLENAME SET COLUMN=VALUE… WHERE 条件</p><p>DELETE FROM TABLENAME WHERE 条件</p><hr><h2 id="视图view"><a href="#视图view" class="headerlink" title="视图view"></a>视图view</h2><p>简化复杂的查询，查询部分数据作为一个视图<br>create view view_name as (查询语句)<br>create or replace view view_name as ….</p><hr><h2 id="序列SEQUENCE"><a href="#序列SEQUENCE" class="headerlink" title="序列SEQUENCE"></a>序列SEQUENCE</h2><p>若想和mysql等数据库一样实现某列自动增长的功能，可以利用序列</p><p>其中有两个变量：<br>nextval：取得序列的下一个内容<br>currval：取得序列的当前内容<br>先创建序列：<br>CREATE SEQUENCE SEQUENCENAME<br>                                     INCREMENT BY 10<br>                                    START WITH 120<br>                                    MAXVALUE 9999<br>                                    NOCACHE<br>                                    NOCYCLE;</p><p>自增这样写：insert into tablename values(列名.nextval….)</p><h2 id="索引index"><a href="#索引index" class="headerlink" title="索引index"></a>索引index</h2><p>单列索引：<br>create index indexname on tablename(columnname)</p><p>复合索引<br>create index indexname on tablename(…)</p><p>当数据量较大的时候，索引能加快查询速度。</p><h2 id="同义词SYNONYM"><a href="#同义词SYNONYM" class="headerlink" title="同义词SYNONYM"></a>同义词SYNONYM</h2><p>CREATE PUBLIC SYNONYM synonymname for othertable.emp</p><hr><h1 id="PL-SQL"><a href="#PL-SQL" class="headerlink" title="PL/SQL"></a>PL/SQL</h1><p>declare<br>这里写一些说明（变量定义什么的。。。）<br>begin<br>代码部分，语句序列，DML<br>exception<br>例外语句，类似异常处理<br>End;</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvio5aq1j30ev09dt9p.jpg" alt=""></p><p><strong>选择</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvj6bwbgj309u0ant9h.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvji4pvvj30e4064q3j.jpg" alt=""><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvjw7525j30hy07tmyb.jpg" alt=""></p><p><strong>循环</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvk97rujj30bt0frwg5.jpg" alt=""></p><hr><h2 id="游标cursor"><a href="#游标cursor" class="headerlink" title="游标cursor"></a>游标cursor</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjvr2tozmj30gd05edhp.jpg" alt=""><br>使用</p><p>例：</p><pre><code>declare    //声明部分    cursor cl is  //声明游标        select * from emp;  //游标指向    pemp emp%rowtype;    //声明变量，类型为emp表begin      open cl;    //打开游标        loop                fetch cl    //取一行游标的值                into pemp;    //放入pemp变量中            exit when cl%notfound;    //当游标为空的时候跳出循环            dbms_output.put_line(pemp.empno || &apos; &apos; || pemp.ename);    //打印变量所指行的信息        end loop    close cl    //关闭游标end; </code></pre><p>也可以指定游标的类型为特定的某一行<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjw17a91wj30f801imxv.jpg" alt=""></p><hr><h2 id="例外exception"><a href="#例外exception" class="headerlink" title="例外exception"></a>例外exception</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjw41x9ltj30a103s3yz.jpg" alt=""></p><p>类似与java，也可以自己手动抛出异常。</p><p>自定义异常需要在declare中定义，然后使用时可以加入条件控制中，如果不正确可以抛出（raise）一个异常，然后进入exception块中</p><pre><code>exception     when   自定义异常名   then         处理语句</code></pre><hr><h2 id="存储过程procedure"><a href="#存储过程procedure" class="headerlink" title="存储过程procedure"></a>存储过程procedure</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwafrjz7j30de08gaav.jpg" alt=""><br>在AS或者IS后可以加变量定义。<br>调用<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwifmffyj309f04hmxo.jpg" alt=""></p><h2 id="存储函数function"><a href="#存储函数function" class="headerlink" title="存储函数function"></a>存储函数function</h2><p>存储函数和存储过程一般来说没有什么区别，返回结果的数量可以通过参数里的<strong>out</strong>指定</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwpj3k0kj30gp04iwf7.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjwu2zddoj30b1013aa1.jpg" alt=""></p><pre><code>create or replace function  empincome (eno in emp.empno%type) return number is  //声明存储过程    psal emp.sal%type;  //定义薪水变量    pcomm emp.comm%type;  //定义奖金变量begin    select t.sal,t.pcomm into psal,pcomm from emp t where t.empno=eno;    return psal*12+nvl(pcomm,0);end</code></pre><p>用存储过程实现<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx0o7by5j30i60bvadt.jpg" alt=""></p><hr><h2 id="java调用存储过程"><a href="#java调用存储过程" class="headerlink" title="java调用存储过程"></a>java调用存储过程</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx2q44rzj30ga0bk415.jpg" alt=""></p><p>若使用游标<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjx6rz4flj30g305rq4e.jpg" alt=""><br>只需要将游标提取，然后用ResultSet类型转换即可查询游标所指内容</p><p>另外，写在过程中out语句后的用来返回结果集的游标类型应该为sys_refcursor，具体可以查看</p><blockquote><p><a href="https://www.cnblogs.com/liuqiyun/p/6796740.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuqiyun/p/6796740.html</a></p></blockquote><hr><h2 id="触发器TRIGGER"><a href="#触发器TRIGGER" class="headerlink" title="触发器TRIGGER"></a>触发器TRIGGER</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxr3dooij309p06674r.jpg" alt=""></p><p>触发器自带变量<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxsqbtsuj30hx047t9o.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyjxyacxucj30fv0dkju9.jpg" alt=""></p><p>另外一般不允许多个触发器对同一张表进行操作或者在触发器中对同一张表进行操作，容易产生递归循环触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DDL（database-define-language）数据库定义语言&quot;&gt;&lt;a href=&quot;#DDL（database-define-language）数据库定义语言&quot; class=&quot;headerlink&quot; title=&quot;DDL（database define 
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://xfff.xyz/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle学习笔记1</title>
    <link href="http://xfff.xyz/2018/12/23/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://xfff.xyz/2018/12/23/Oracle学习笔记1/</id>
    <published>2018-12-23T04:34:45.000Z</published>
    <updated>2019-01-31T09:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。</em></p><ul><li><a href="#a">01基础</a></li><li><a href="#b">02多表查询、子查询</a></li></ul><hr><p><span id="a"></span></p><h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><p>Oracle中distinct可以消除重复的行，如果指定多个列名，则要保证多列的数据皆重复才会消除。</p><pre><code>select distinct name,sal from emp</code></pre><hr><p>Oracle中有独特的字符串连接符’<strong>||</strong>‘，相当于java里的’+’,MYSQL里可以用concat连接字符串。</p><pre><code>select &apos;姓名是:&apos; || NAME || &apos;的年龄为&apos; || AGE from emp;select concat(NAME,&apos;是姓名&apos;，AGE，&apos;是年龄&apos;    ) from emp;</code></pre><hr><p>查询列取别名时，若别名中有特殊字符或者关键字需要加上双引号。(其他地方大部分使用单引号）</p><pre><code>select name &quot;my name&quot; from emp;</code></pre><hr><p>LIKE关键字使用时，若匹配的字符里有特殊字符，需要使用escape关键字<br>如，要查询员工姓名里有’%’字符的员工信息。</p><pre><code>select * from emp where name like &apos;%\%%&apos; escape &apos;\&apos;;</code></pre><p>其中第一和最后一个%号都表示任意字符，而escape声明’\‘为转义字符，所以第二个%表示字符’%’。<br>也可以这样写:</p><pre><code>select * from emp where name like &apos;%#%%&apos; escape &apos;#&apos;;</code></pre><p>所以我猜想在oracle里反斜杠并不代表转义字符的意思吧。。</p><hr><p>在排序的时候，如果有空值，需要在末尾加上null的说明</p><pre><code>select * from emp order by number desc nulls last;</code></pre><p>表示null值放在末尾，还有nulls first.</p><hr><p>oracle里有一个伪表用来做返回字符或者数值，叫做<strong>dual</strong>，在MYSQL中不用加from dual；</p><p>同样的，oracle里也有很多一样的函数</p><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><ul><li><p>concat():    字符串连接</p><pre><code>select concat(&apos;hello&apos;,&apos;world&apos;) from dual;</code></pre></li><li>substr():字符串的截取substr(str,0,3)表示从索引位置0（<strong>0和1效果相同</strong>）开始截取str，截取3个字符的长度。</li><li>length()：获取字符串长度    </li><li>replace()：replace(str,’a’,’b’)表示把str里所有的a替换成b</li><li>round()：四舍五入round(num,2)，2表示保留2位小数0</li><li>ceil()：进1取整</li><li>trunc()：截断trunc(num,2)去掉小数点后2位的尾数</li><li>MOD()：求余MOD(NUM1,NUM2)</li><li>MONTHS_BETWEEN()：获得两个时间段中的月数，months_between(sysdate,finishdate)——<strong>sysdate</strong>表示系统时间</li><li>ADD_MONTHS()：获取几个月后的日期，add_months(sysdate,3)系统时间3个月后。</li><li>TO_CHAR：字符串转换函数</li><li>TO_NUMBER：数值转换函数</li><li>TO_DATE：日期转换函数<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fygwfj010wj30h407sjt2.jpg" alt=""><br>如：<br>TO_CHAR(date,’yyyy-mm-dd’)<br>TO_CHAR(date,’yyyy’)等<br>把月和日前面的0去掉要在后面的model前加上fm<br>TO_CHAR(date,’fmyyyy-mm-dd’)<br>TO_CHAR(sysdate,’d’)一个d代表一个星期的第几天，两个d代表一个月的第几天，三个d代表一年中的第几天<br>TO_CHAR(sysdate,’day’)星期几–返回monday什么的，如果是dy，则返回简写–mon之类的</li></ul><p>也就是这三种类型的相互转换函数<br>TO_CHAR(sal,’L9,999.99’),可以格式化货币，L表示本地货币</p><ul><li>NVL()：空值处理，如果为空值就取后面的值为默认值，nvl(name,’Peter’)</li><li>NVL2()：nvl2(参数1，参数2，参数3)，如果参数1为空值，就返回参数3，否则返回参数2</li><li>nullif()：nullif(参数1，参数2)如果参数1等于参数2，那么就返回null，否则返回参数1</li><li>coalesce()：这个函数传入很多参数，然后返回第一个不为null的值</li></ul><hr><p>条件表达式：在SQL语句中使用IF-THEN-ELSE</p><p><strong>CASE</strong>表达式：SQL99的语法，类似Basic，比较繁琐</p><pre><code>select    case name        when &apos;Peter&apos; then &apos;P&apos;        when &apos;Bob&apos; then &apos;B&apos;        else             &apos;C&apos;        endfrom emp;</code></pre><p>就是当name等于when里的值就改为then后面的值，这种写法通用于MYSQL和Oracle</p><p><strong>DECODE</strong>函数：Oracle自己的语法，类似java，比较简洁</p><pre><code>select decode(name,&apos;Peter&apos;,&apos;P&apos;,&apos;Bob&apos;,&apos;B&apos;,&apos;C&apos;) from emp;</code></pre><p>效果和上面一样</p><hr><h2 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h2><ul><li>max()：某列最大值</li><li>min()：某列最小值</li><li>count()：统计行数</li><li>avg()：平均数，注意空值影响</li><li>sum()：求和<br>多行函数常与分组关键字Group by配合使用，另外having关键字在group by后执行，where后不能接多行函数。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fygz2iqixhj30kg02yjtb.jpg" alt=""></li></ul><p>就是说只能这样写</p><pre><code>select 列名a，分组函数 from 表 group by 这个列名a having 条件</code></pre><hr><p><span id="b"></span></p><h2 id="多表查询、子查询"><a href="#多表查询、子查询" class="headerlink" title="多表查询、子查询"></a>多表查询、子查询</h2><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>内外连接我在前面sql写过了，就写一些oracle不同的地方</p><p>全外连接为俩表都完全匹配。不加where条件即为外连接</p><p>内连接，加where条件</p><p>左（外）连接<br>显示左边表的全部，匹配右边的表<br>select e.empno,e.ename,m.empno,m.ename from emp e,emp m where e.mgr=m.empno(+)<br>在右边加+号表示用该表匹配左表，故为左连接。</p><p>右连接反之。</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>也就是在一个大的主查询里先做一个小的子查询供主查询使用。</p><p>例</p><pre><code>select name,job,sal from emp where sal=(select min(sal) from emp)</code></pre><p>子查询返回结果类型要和比较类型相同。</p><p>多行子查询<br>若子查询返回多行结果，应与多行比较符匹配：in、&gt;any….</p><p>子查询返回空值可能会报错，这个时候需要使用<strong>exists()</strong>，括号里加入子查询语句，若查询结果为空，返回false</p><pre><code>select * from emp where exists(select * from dept where deptno=1)</code></pre><p><strong>Rownum</strong><br>当要查询第几行到第几行的数据时，我们使用rownum。</p><p>rownum是oracle预处理字段，默认标序是1，只有记录集已经满足条件后才会进行后续编号。这样你查询表时遍历第一条数据时rownum是1，不符合条件，继续遍历到第二条数据rownum仍为1，仍不符合条件，直至遍历完所有数据，都无数据返回。</p><p>查询第二行之后的数据</p><pre><code>select * from(select rownum no ,id,name from student) where no&gt;2;</code></pre><p>rownum不能直接使用判断&gt;的条件。<br>另外，rownum是按照插入顺序排列的，所以要按某列排序需要使用子查询</p><pre><code>select rownum ,id,name from (select * from student order by name)</code></pre><p>查询第n行到m行的数据</p><pre><code>(select empno,ename from emp where rownum&lt;m)minus(select empno,ename from emp where rownum&lt;n)</code></pre><hr><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>就是俩条语句的结果集的运算<br>有</p><ul><li>UNION并集</li><li>intersect交集</li><li>minus差集</li></ul><p>特征：<br>两边查询的字段数量、字段类型、顺序必须一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Oracle数据库是一个对象关系数据库管理系统（ORDBMS）。它通常被称为Oracle RDBMS或简称为Oracle，是一个收费的数据库。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#a&quot;&gt;01基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#b&quot;
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="http://xfff.xyz/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>工作第一天</title>
    <link href="http://xfff.xyz/2018/12/19/%E5%B7%A5%E4%BD%9C%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://xfff.xyz/2018/12/19/工作第一天/</id>
    <published>2018-12-19T06:40:39.000Z</published>
    <updated>2018-12-19T06:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>经过大半个月的折腾，我找到了自己的第一份IT工作。</p><p>今天是第一天，负责带我的导师，出差了……</p><p>是的，没错，出差了。</p><p>干坐了一天，看看这个看看那个，刷刷这个刷刷那个，无聊呀…</p><p>说到无聊，我就想起了《西游记》里的无花果树。今年下半年…开拍…文体两开花…</p><p>咳咳，由于昨天一天的搬家折腾，晚上也没睡好，感冒（类似）鼻塞了，很难受，而且还很困，希望今晚能好好睡一觉，鼻塞快点好吧，明天也要元气满满。</p><p>这里就随便记一下皮一下—–</p><p>加油吧。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fyc25phdx5j30xc0sqx6p.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;经过大半个月的折腾，我找到了自己的第一份IT工作。&lt;/p&gt;
&lt;p&gt;今天是第一天，负责带我的导师，出差了……&lt;/p&gt;
&lt;p&gt;是的，没错，出差了。&lt;/p&gt;
&lt;p&gt;干坐了一天，看看这个看看那个，刷刷这个刷刷那个，无聊呀…&lt;/p&gt;
&lt;p&gt;说到无聊，我就想起了《西游记》里的
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="日常生活" scheme="http://xfff.xyz/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】工作流程理解（一）</title>
    <link href="http://xfff.xyz/2018/12/10/%E3%80%90springmvc%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xfff.xyz/2018/12/10/【springmvc】工作流程理解（一）/</id>
    <published>2018-12-10T09:02:07.000Z</published>
    <updated>2019-02-19T06:15:27.261Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用户通过URL发送请求，到达<strong>DispatcherServlet-前端(核心)控制器</strong>(通过在web.xml中配置)</li><li><strong>DispatcherServlet</strong>把请求转发给<strong>HandlerMapper-处理器映射器</strong>（在springmvc配置文件中注册）</li><li><strong>HandlerMapper</strong>根据请求返回映射的<strong>controller控制器对象链</strong>给<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>把<strong>controller</strong>对象处理链转发给<strong>HandlerAdapter处理器适配器（在springmvc配置文件中注册）</strong></li><li><strong>HandlerAdapter</strong>根据请求通知<strong>controller处理器</strong>应该实现的方法（配置扫描、注解）</li><li><strong>controller</strong>调用对应的方法，返回<strong>ModelAndView</strong>对象（配置注解）</li><li>经<strong>HandlerAdapter</strong>又发送回<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>对象发送给<strong>ViewResolver</strong>视图解析器（在springmvc配置文件中配置）</li><li><strong>ViewResolver</strong>对传来的<strong>Model</strong>（数据..）和<strong>View</strong>（对应的页面..）进行渲染返回给<strong>DispatcherServlet</strong></li><li><strong>Response</strong> 响应给用户</li></ol><hr><p>上诉为自己总结，可能有些错误，是我初学理解不够深刻。</p><hr><p><strong><em>网图:</em></strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw4bmgbq81j30pj09h75h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;用户通过URL发送请求，到达&lt;strong&gt;DispatcherServlet-前端(核心)控制器&lt;/strong&gt;(通过在web.xml中配置)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;把请求转发给&lt;strong&gt;
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>SQL一些基本语句使用</title>
    <link href="http://xfff.xyz/2018/11/29/SQL%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/11/29/SQL一些基本语句使用/</id>
    <published>2018-11-28T16:18:06.000Z</published>
    <updated>2019-01-31T09:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>选出不重复的列<br>SELECT DISTINCT COLUMN FROM TABLE<br>用某列来进行排序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN<br>逆序<br>SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN DESC<br>选出开始几行<br>SELECT TOP NUMBER|PERCENT * FROM TABLE<br>MYSQL中用LIMIT关键字</p><hr><p>like关键字<br>Where column like ‘pattern’<br>_表示一位<br>%表示任何多位<br>[]表示方括号里的某一单一字符<br>[^]反向</p><hr><p>范围条件IN<br>Where column in （VALUES…）<br>BETWEEN…AND..<br>a&lt;x&lt;b</p><hr><p>内连接、左外连接、右外连接、全连接<br>Inner JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN</p><hr><p>创建索引</p><p><strong>CREATE INDEX 语句用于在表中创建索引。</strong></p><p><strong>在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。</strong></p><p>更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引</p><p>CREATE INDEX index_name<br>ON table_name (column_name)</p><p>删除索引–MYSQL<br>ALTER TABLE table_name DROP INDEX index_name</p><p>删除表、数据库<br>DROP TABLE 表名称<br>DROP DATABASE 数据库名称</p><hr><p>创建视图</p><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p><p>注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响<br><a href="http://www.w3school.com.cn/sql/sql_view.asp" target="_blank" rel="noopener">CLICK</a></p><hr><p>关键字ALTER用于修改表以及行<br>ALTER TABLE table_name<br>ALTER COLUMN column_name datatype</p><hr><p>SQL函数<br>平均AVG()<br>例：希望找到 OrderPrice 值高于 OrderPrice 平均值的客户<br>SELECT Customer FROM Orders<br>WHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders)</p><p>计数COUNT()<br>SELECT COUNT(column_name) FROM table_name//括号里可加DISTINCT关键字</p><p>第一、最后一条记录<br>FIRST()、LAST()</p><p>最大值、最小值<br>MAX()、MIN()</p><p>计和<br>SUM()</p><p>按列分项算总和<br>例SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer</p><p>计和增加条件用关键字HAVING</p><p>转大小写<br>UCASE()、LCASE()</p><p>MID() 函数<br>MID 函数用于从文本字段中提取字符<br>SELECT MID(column_name,start[,length]) FROM table_name<br>例SELECT MID(City,1,3) as SmallCity FROM Persons</p><p>LEN()<br>LEN 函数返回文本字段中值的长度。</p><p>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>SELECT ROUND(column_name,decimals) FROM table_name</p><p>NOW()<br>NOW 函数返回当前的日期和时间</p><p>FORMAT 函数用于对字段的显示进行格式化。<br>SELECT FORMAT(column_name,format) FROM table_name</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选出不重复的列&lt;br&gt;SELECT DISTINCT COLUMN FROM TABLE&lt;br&gt;用某列来进行排序&lt;br&gt;SELECT COLUMN FROM TABLE ORDER BY ONECOLUMN&lt;br&gt;逆序&lt;br&gt;SELECT COLUMN FROM TABLE
      
    
    </summary>
    
      <category term="数据库" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="sql" scheme="http://xfff.xyz/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>比较器Comparator和Comparable的使用</title>
    <link href="http://xfff.xyz/2018/11/23/%E6%AF%94%E8%BE%83%E5%99%A8Comparator%E5%92%8CComparable%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/11/23/比较器Comparator和Comparable的使用/</id>
    <published>2018-11-23T08:45:52.000Z</published>
    <updated>2018-11-23T09:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们需要对一些数组和集合进行排序的时候，经常会用到Arrays.sort和Collections.sort方法。<br>但当sort里的数组或集合里的对象不适合用默认的比较方法时，我们就需要手动对排序方式重新定义。</p><hr><p>比如，现在定义一个Person对象：</p><pre><code>public class Person {    private int id;    private int age;    public Person(int id,int age) {        this.age=age;        this.id=id;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }        @Override    public String toString()         return &quot;Person&quot;+id+&quot;-&gt;age:&quot;+age;    }}</code></pre><p>现在我们要对一堆person集合进行按年龄从小到大的排序或者年龄和id的和的大小的排序，这个时候默认的方法就无法实现我们的要求。</p><hr><p>一般我们有两种方法来实现：</p><h2 id="1-实现Comparable接口"><a href="#1-实现Comparable接口" class="headerlink" title="1.实现Comparable接口"></a>1.实现Comparable接口</h2><p>让需要进行特殊排序的对象实现Comparable接口，并重写其中的compareTo方法</p><pre><code>public class Person implements Comparable&lt;Person&gt;</code></pre><p>compareTo中，如果想按从小到大的顺序排列，当符合小于规定时就返回-1。否则可以反向排序返回1。</p><pre><code>@Overridepublic int compareTo(Person o) {    if (age&lt;o.age) {        return -1;    }else {        return 1;    }}</code></pre><p>测试：</p><pre><code>public class ComparaTest {    public static void main(String[] args) {        List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();        aList.add(new Person(1,13));        aList.add(new Person(2, 42));        aList.add(new Person(3, 5));        aList.add(new Person(45, 32));        aList.add(new Person(42, 88));        aList.add(new Person(4, 5));        System.out.println(&quot;排序前:&quot;);        aList.stream().forEach(System.out::println);        Collections.sort(aList);        System.out.println(&quot;排序后:&quot;);        aList.stream().forEach(System.out::println);    }}</code></pre><p>输出</p><pre><code>排序前:Person1-&gt;age:13Person2-&gt;age:42Person3-&gt;age:5Person45-&gt;age:32Person42-&gt;age:88Person4-&gt;age:5排序后:Person3-&gt;age:5Person4-&gt;age:5Person1-&gt;age:13Person45-&gt;age:32Person2-&gt;age:42Person42-&gt;age:88</code></pre><h2 id="2-创建比较类继承Comparator"><a href="#2-创建比较类继承Comparator" class="headerlink" title="2.创建比较类继承Comparator"></a>2.创建比较类继承Comparator</h2><p>Comparator位于包java.util下，而Comparable位于包java.lang下。</p><p>创建一个比较类MyComparator：<br>这里我直接创建一个静态内部类用来比较，并定义为倒序</p><pre><code>static class MyComparator implements Comparator&lt;Person&gt;{    @Override    public int compare(Person o1, Person o2) {        if (o1.getAge()&lt;o2.getAge()) {            return 1;        }else {            return -1;        }    }}</code></pre><p>测试：</p><pre><code>public static void main(String[] args) {    List&lt;Person&gt; aList=new ArrayList&lt;Person&gt;();    aList.add(new Person(1,13));    aList.add(new Person(2, 42));    aList.add(new Person(3, 5));    aList.add(new Person(45, 32));    aList.add(new Person(42, 88));    aList.add(new Person(4, 5));    System.out.println(&quot;排序前:&quot;);    aList.stream().forEach(System.out::println);    Collections.sort(aList,new MyComparator());    System.out.println(&quot;排序后:&quot;);    aList.stream().forEach(System.out::println);}</code></pre><p>输出：</p><pre><code>排序前:Person1-&gt;age:13Person2-&gt;age:42Person3-&gt;age:5Person45-&gt;age:32Person42-&gt;age:88Person4-&gt;age:5排序后:Person42-&gt;age:88Person2-&gt;age:42Person45-&gt;age:32Person1-&gt;age:13Person4-&gt;age:5Person3-&gt;age:5</code></pre><hr><p>另外，在leetcode第23题有配合优先级队列使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们需要对一些数组和集合进行排序的时候，经常会用到Arrays.sort和Collections.sort方法。&lt;br&gt;但当sort里的数组或集合里的对象不适合用默认的比较方法时，我们就需要手动对排序方式重新定义。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;比如，现在定义一个Person对
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="比较器" scheme="http://xfff.xyz/tags/%E6%AF%94%E8%BE%83%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】逆向工程及详解</title>
    <link href="http://xfff.xyz/2018/11/17/%E3%80%90mybatis%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xfff.xyz/2018/11/17/【mybatis】逆向工程及详解/</id>
    <published>2018-11-17T09:02:07.000Z</published>
    <updated>2019-02-19T06:13:36.127Z</updated>
    
    <content type="html"><![CDATA[<p>逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理<a href="https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433?fr=aladdin" target="_blank" rel="noopener">^1</a>。</p><hr><ol><li><p>最好先创建一个新的空项目</p></li><li><p>引入Maven依赖</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwaecl9jgvj308w038dfr.jpg" alt=""></p><ol start="3"><li>创建逆向工程配置文件</li><li><p>文件配置内容</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatist&quot;             userId=&quot;root&quot;            password=&quot;olonn&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.me&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;buser&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;bcard&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;ctou&quot;&gt;&lt;/table&gt;        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>创建一个类用来运行生成文件</p><pre><code>package com.mapper;import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class Zzz {    public void generate() throws Exception {        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        boolean overwrite = true;        File configFile = new File(&quot;src/main/resources/GeneratorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        myBatisGenerator.generate(null);    }    public static void main(String[] args) throws Exception {        try {            Zzz zzz=new Zzz();            zzz.generate();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre></li></ol><p>注意配置文件的目录，相对根路径是从项目根目录开始的。运行即可。</p><p>运行完刷新目录，见：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwael724nzj306s0av0sx.jpg" alt=""></p><p>我们就得到了想要的Mapper接口、配置文件和pojo类。</p><hr><hr><p>select主要通过criteria对象<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafj73fpkj30ds02jdfu.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafimt96uj305n06hglo.jpg" alt=""></p><hr><p>总的来说，还是非常方便的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="逆向工程" scheme="http://xfff.xyz/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】与spring整合</title>
    <link href="http://xfff.xyz/2018/11/15/%E3%80%90mybatis%E3%80%91%E4%B8%8Espring%E6%95%B4%E5%90%88/"/>
    <id>http://xfff.xyz/2018/11/15/【mybatis】与spring整合/</id>
    <published>2018-11-15T09:02:07.000Z</published>
    <updated>2019-02-19T06:14:59.470Z</updated>
    
    <content type="html"><![CDATA[<p><em>只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。</em></p><hr><p>导入相应的整合包后，首先将数据库的配置交给spring配置：</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis的配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>使用mapper代理开发时，在spring容器中配置mapper的接口生成代理对象：</p><pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        //mapperInterface指定mapper接口        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过MapperScannerConfigurer进行mapper扫描可以实现批量配置：</p><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 指定扫描的包名    如果扫描多个包，每个包中间使用半角逗号分隔    --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><hr><p>这样，要使用mapper时，只需要通过注解的方式：</p><pre><code>@Autowiredprivate UserMapper userMapper;</code></pre><p>或加载spring配置文件的方式（Test方法里使用）:</p><pre><code>private ApplicationContext applicationContext;applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);UserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;导入相应的整合包
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(三)</title>
    <link href="http://xfff.xyz/2018/11/10/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89/"/>
    <id>http://xfff.xyz/2018/11/10/【mybatis】学习总结-三/</id>
    <published>2018-11-10T09:02:07.000Z</published>
    <updated>2019-02-19T06:13:55.662Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查询的语句，然后在之后才对这个数据进行使用（比如输出），那么在输出的时候，数据库才会真正去运行这条语句返回查询的对象。</p><p>开启延迟加载的方式：</p><ul><li><strong>使用association实现延迟加载</strong></li></ul><p>在association标签里加入select和column属性，select指向查询关联数据的方法，column指向在主表中关联的列（外键那列）。</p><ul><li><p><strong>在全局配置文件中配置</strong></p><pre><code>&lt;settings&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre></li></ul><p>settings标签配置在property下面，typeAlias上面。</p><table><thead><tr><th style="text-align:left">延迟加载开关</th><th style="text-align:left">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</th><th style="text-align:right">lazyLoadingEnabled</th><th style="text-align:center">默认为false</th></tr></thead><tbody><tr><td style="text-align:left">消极加载</td><td style="text-align:left">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td><td style="text-align:right">aggressiveLazyLoading</td><td style="text-align:center">默认为true</td></tr><tr><td style="text-align:left">二级缓存</td><td style="text-align:left"><a href="#a">CLICK</a></td><td style="text-align:right">cacheEnabled</td><td style="text-align:center">默认为false</td></tr></tbody></table><ul><li><strong>一级缓存</strong></li></ul><p>Mybatis默认开启一级缓存，在同一个SqlSession中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则SqlSession的缓存清空。<br>SqlSession关闭也清空，比如一个service调用的结束，会关闭一个sqlsession，则缓存结束。</p><p><span id="a"></span></p><ul><li><strong>二级缓存</strong></li></ul><p>Mybatis需要手动设置启动二级缓存，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存,添加：</p><pre><code>&lt;cache/&gt;</code></pre><p>二级缓存的作用域是同一个namespace下的mapper映射文件内容（HashMap），多个SqlSession共享。<br>在同一个namespace下的mapper文件中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则二级缓存清空。<br>一个SqlSession关闭不会导致二级缓存清空，如果设置了二级缓存，service重复被调用查询同一条记录，只会一直从二级缓存中查询。</p><p><strong>实现序列化</strong></p><p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。</p><p>如果该类存在父类，那么父类也要实现序列化。</p><p><strong>设置禁用二级缓存</strong></p><p>在select中添加属性useCache=”false”默认为true。</p><p><strong>设置刷新二级缓存</strong></p><p>在select中添加属性flushCache=”true”。</p><h2 id="mybatis整合ehcache"><a href="#mybatis整合ehcache" class="headerlink" title="mybatis整合ehcache"></a>mybatis整合ehcache</h2><p>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。</p><p>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。</p><p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><ul><li><strong>整合方法：</strong></li></ul><p>整合ehcache所需包：</p><ul><li>ehcache-core-2.6.11.jar</li><li>mybatis-ehcache-1.1.0.jar</li></ul><p>设置mapper配置文件中</p><pre><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><p>加入ehcache的配置文件ehcache.xml（classpath下）：</p><pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt;    &lt;defaultCache         maxElementsInMemory=&quot;1000&quot;         maxElementsOnDisk=&quot;10000000&quot;        eternal=&quot;false&quot;         overflowToDisk=&quot;false&quot;         timeToIdleSeconds=&quot;120&quot;        timeToLiveSeconds=&quot;120&quot;         diskExpiryThreadIntervalSeconds=&quot;120&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;延迟加载&quot;&gt;&lt;a href=&quot;#延迟加载&quot; class=&quot;headerlink&quot; title=&quot;延迟加载&quot;&gt;&lt;/a&gt;延迟加载&lt;/h2&gt;&lt;p&gt;为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】笔记2</title>
    <link href="http://xfff.xyz/2018/11/08/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B02/"/>
    <id>http://xfff.xyz/2018/11/08/【leetcode】笔记2/</id>
    <published>2018-11-08T08:57:46.000Z</published>
    <updated>2019-01-31T09:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h2><p>Given  _n_  non-negative integers  _a1_,  _a2_, …,  _an_ , where each represents a point at coordinate (_i_,  _ai_).  _n_  vertical lines are drawn such that the two endpoints of line  _i_  is at (_i_,  _ai_) and (_i_, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note:</strong> You may not slant the container and  _n_  is at least 2.</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fx0riuv5qxj30m90anq3j.jpg" alt=""></p><p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> [1,8,6,2,5,4,8,3,7]<br><strong>Output:</strong> 49</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public int maxArea(int[] height) {        if(height.length&lt;2)return 0;        int head=0,tail=height.length-1;        int max = 0;        while (head!=tail) {            if (height[head]&gt;height[tail]) {                if((tail-head)*height[tail]&gt;max) {                    max=(tail-head)*height[tail];                }                tail--;            }else {                if((tail-head)*height[head]&gt;max) {                    max=(tail-head)*height[head];                }                head++;            }        }        return max;    }}</code></pre><p>定义两个下标变量从两端往中间遍历，比较俩下标对应的高度，若想中间的面积更大，则只改变高度较低的那一端的下标值向中间靠拢，最后通过一个变量记录最大值即可。</p><hr><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><p>Given an array  <code>nums</code>  of  _n_  integers, are there elements  _a_,  _b_,  _c_  in  <code>nums</code>  such that  _a_  +  _b_  +  _c_  = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><p>Given array nums = [-1, 0, 1, 2, -1, -4],</p><p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        if(nums.length&lt;3) return Arrays.asList();        List&lt;List&lt;Integer&gt;&gt; aList=new ArrayList&lt;&gt;();        Arrays.sort(nums);        for(int i=0;i+2&lt;nums.length;i++) {            if (i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;            if (nums[i]&gt;0) break;            int target=-nums[i];            int j=i+1,k=nums.length-1;            while(k&gt;j) {                if(target==nums[j]+nums[k]) {                    aList.add(Arrays.asList(nums[i],nums[j],nums[k]));                    j++;                    k--;                    while(j&lt;k&amp;&amp;nums[j]==nums[j-1])j++;                    while(j&lt;k&amp;&amp;nums[k]==nums[k+1])k--;                }else if(target&lt;nums[j]+nums[k]){                    k--;                }else {                    j++;                }            }        }        return aList;    }}</code></pre><p>大概思想就是让每个数负数作为和，定义两个指针从这个数的右边和数组末向中间遍历，若有符合条件的加入list，跳过重复项</p><hr><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h2><p>Given a string containing digits from  <code>2-9</code>  inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png" alt=""></p><p><strong>Example:</strong></p><p><strong>Input:</strong> “23”<br><strong>Output:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p><strong>Note:</strong></p><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {     HashMap&lt;Character, List&lt;Character&gt;&gt; map=new HashMap&lt;&gt;();     StringBuilder stringBuilder=new StringBuilder();     List&lt;String&gt; aList=new ArrayList&lt;&gt;();    public  List&lt;String&gt; letterCombinations(String digits) {        if(digits.length()==0||digits==null) return Arrays.asList();               map.put(&apos;2&apos;, Arrays.asList(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;));        map.put(&apos;3&apos;, Arrays.asList(&apos;d&apos;,&apos;e&apos;,&apos;f&apos;));        map.put(&apos;4&apos;, Arrays.asList(&apos;g&apos;,&apos;h&apos;,&apos;i&apos;));        map.put(&apos;5&apos;, Arrays.asList(&apos;j&apos;,&apos;k&apos;,&apos;l&apos;));        map.put(&apos;6&apos;, Arrays.asList(&apos;m&apos;,&apos;n&apos;,&apos;o&apos;));        map.put(&apos;7&apos;, Arrays.asList(&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;));        map.put(&apos;8&apos;, Arrays.asList(&apos;t&apos;,&apos;u&apos;,&apos;v&apos;));        map.put(&apos;9&apos;, Arrays.asList(&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;));        doAdd(digits,0);        return aList;    }    private void doAdd(String digits, int i) {        if (i&lt;digits.length()) {            for (Character character : map.get(digits.charAt(i))) {                stringBuilder.append(character);                doAdd(digits, i+1);                stringBuilder.deleteCharAt(i);            }        }else {            aList.add(stringBuilder.toString());            return;        }    }}</code></pre><hr><h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><pre><code>/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {        if(l1==null) return l2;        if(l2==null) return l1;        ListNode node;        if(l1.val&gt;l2.val) {            node=l2;            l2=l2.next;        }else {            node=l1;            l1=l1.next;        }        ListNode head=new ListNode(0);        head.next=node;        while(l1!=null||l2!=null) {            if(l1==null) {                node.next=l2;                break;            }else if(l2==null) {                node.next=l1;                break;            }            if (l1.val&gt;l2.val) {                node.next=l2;                l2=l2.next;            }else {                node.next=l1;                l1=l1.next;            }            node=node.next;        }        return head.next;    }}</code></pre><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h2><p>Given  _n_  pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given  _n_  = 3, a solution set is:</p><pre><code>[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]</code></pre><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public List&lt;String&gt; generateParenthesis(int n) {        List&lt;String&gt; aList=new ArrayList&lt;&gt;();        StringBuilder sBuilder=new StringBuilder();        doListCur(0,0,sBuilder,n,aList);        return aList;    }    private void doListCur(int left, int right, StringBuilder sBuilder,int n,List&lt;String&gt; aList) {        if(n==right) {            aList.add(sBuilder.toString());            return;        }        if (left&lt;n) {            sBuilder.append(&apos;(&apos;);            doListCur(left+1, right, sBuilder, n, aList);            sBuilder.deleteCharAt(sBuilder.length()-1);        }        if (right&lt;left) {            sBuilder.append(&apos;)&apos;);            doListCur(left, right+1, sBuilder, n, aList);            sBuilder.deleteCharAt(sBuilder.length()-1);        }    }}</code></pre><p>类似上题</p><hr><h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h2><p>Merge  _k_  sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p><strong>Example:</strong></p><p><strong>Input:</strong></p><pre><code>[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]</code></pre><p><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><pre><code>class Solution {    public ListNode mergeKLists(ListNode[] lists) {         Comparator&lt;ListNode&gt; cmp;        cmp = new Comparator&lt;ListNode&gt;() {          @Override        public int compare(ListNode o1, ListNode o2) {            // TODO Auto-generated method stub            return o1.val-o2.val;        }        };        Queue&lt;ListNode&gt; q = new PriorityQueue&lt;ListNode&gt;(cmp);        for(ListNode l : lists){            if(l!=null){                q.add(l);            }                }        ListNode head = new ListNode(0);        ListNode point = head;        while(!q.isEmpty()){             point.next = q.poll();            point = point.next;             ListNode next = point.next;            if(next!=null){                q.add(next);            }        }        return head.next;    }}</code></pre><p>另外还可以利用第21题的两两链表合并，速度更快</p><hr><h2 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h2><p>Implement  <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be  <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong>  and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><p><code>1,2,3</code>  →  <code>1,3,2</code><br><code>3,2,1</code>  →  <code>1,2,3</code><br><code>1,1,5</code>  →  <code>1,5,1</code></p><pre><code>class Solution {    public void nextPermutation(int[] nums) {        if(nums.length&lt;2) return;        int n=nums.length-1;        List&lt;Integer&gt; aList=new ArrayList&lt;&gt;();        aList.add(nums[n]);        while(n&gt;0) {            int j=n-1;            for(int i=0;i&lt;aList.size();i++) {                if (aList.get(i)&gt;nums[j]) {                    int anum=nums[nums.length-1-i];                    nums[nums.length-1-i]=nums[j];                    nums[j]=anum;                    Arrays.sort(nums, j+1, nums.length);                    return;                }            }            aList.add(nums[j]);            n--;        }        Arrays.sort(nums);    }}</code></pre><p>用list里的数去和它前面一位的数比较，如果遇到某一个数大于这个数，就互换这两个数的位置，并把前面数后面的位置重新排序。否则就把这个数加入到list里，再次循环。如果一直到循环结束未发现任何后面的数大于前面的数，就把数组从小到大重新排序。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11. Container With Most Water&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://xfff.xyz/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://xfff.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(二)</title>
    <link href="http://xfff.xyz/2018/11/07/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://xfff.xyz/2018/11/07/【mybatis】学习总结(二)/</id>
    <published>2018-11-07T09:02:07.000Z</published>
    <updated>2019-02-19T06:14:15.452Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="动态Sql"><a href="#动态Sql" class="headerlink" title="动态Sql"></a>动态Sql</h2><p>mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。</p><ul><li><strong>if语句</strong></li></ul><p>在mapper映射文件中可以使用\<if>标签来对语句接收的参数进行判断，从而动态改变sql语句。</if></p><p>为了避免多次遇到同一段判断代码时的累赘，可以使用<strong>SQL片段</strong>来重复利用代码。<br>如下：</p><pre><code>&lt;sql id=&quot;thereissqlblock&quot;&gt;        &lt;if test=&quot;goods!=null and user!=null&quot;&gt;            &lt;if test=&quot;user.name!=null and user.name!=&apos;&apos; &quot;&gt;                AND user.password=#{goods.price}            &lt;/if&gt;        &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;selectUseIf&quot; parameterType=&quot;userQuery&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM USER    &lt;where&gt;        &lt;include refid=&quot;thereissqlblock&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p><strong>具体分析：</strong><br>if标签\&lt;&gt;里的test判断的是输入的参数的值，而\&lt;&gt;外则是相应的sql语句块（另外，#表示占位符,$为匹配符）。若不符合if test里的条件，则会执行select * from user，及不设置条件会查询出所有记录，若符合，则会把sql片段拼接到原语句。</p><ul><li><strong>foreach语句</strong></li></ul><p>foreach对应sql语句为：</p><pre><code>SELECT * FROM USER WHERE userid=1 OR userid=2 OR userid=3SELECT * FROM USER WHERE userid IN(1,2,3)</code></pre><p>对于多个对象的输入查询，foreach可以解决遍历参数数组的问题。首先在参数对象中定义一个list集合并生成set和get方法，</p><pre><code>private    List&lt;T&gt; list;//set和get方法 </code></pre><p>在mapper参数类型parameterType设置为list存放对象类型，接着：</p><pre><code>&lt;if test=&quot;users!=null&quot;&gt;    &lt;foreach collection=&quot;users&quot; item=&quot;theuser&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;        userid=#{theuser.userid}    &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>使用：</p><pre><code>User user1=new User();User user2=new User();user1.setUserid(1111);user2.setUserid(1112);List&lt;User&gt; users=new ArrayList&lt;&gt;();users.add(user1);users.add(user2);userQuery.setUsers(users);userMapper.selectForeach(userQuery).stream().forEach(System.out::println);</code></pre><p>即可查出id为1111,1112的俩条记录。</p><hr><h2 id="sql的一对一、一对多"><a href="#sql的一对一、一对多" class="headerlink" title="sql的一对一、一对多"></a>sql的一对一、一对多</h2><p>定义表，orders：订单，custom：用户。外键关联<br>一个用户可发起多个订单，一个订单对应一个用户。<br>在对应类里添加属性。<br>orders:private Custom custom；<br>custom:private List\<orders> orders;</orders></p><ul><li><strong>一对一：</strong></li></ul><pre><code>订单对用户为一对一关系，则根据订单查用户有如下几种方法：</code></pre><ol><li><p>创建一个新类继承Orders,在该类里添加custom的属性并生成set和get方法。然后直接使用该类查询即可，实际应用中应该加上一个输入的参数ordersid<del>这里我懒没加</del></p><pre><code>&lt;mapper namespace=&quot;com.me.mapper.OrdersMapper&quot;&gt;    &lt;select id=&quot;findCO&quot; resultType=&quot;customOrders&quot;&gt;        SELECT custom.*,orders.* FROM custom,orders WHERE orders.customid=custom.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li>上面方法是在没有设置private Custom custom属性时候用的，所以其实可以直接把resultType改成orders，但得不到custom对象，不会把写在mapper里的custom.*映射到orders里的custom属性。</li><li><p>怎么解决2的问题呢？使用resultMap添加association标签关联即可解决</p><pre><code>&lt;resultMap type=&quot;orders&quot; id=&quot;resultmap1&quot;&gt;    &lt;id column=&quot;orderid&quot; property=&quot;orderid&quot; /&gt;    &lt;result column=&quot;thing&quot; property=&quot;thing&quot;/&gt;    &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;association property=&quot;custom&quot; javaType=&quot;com.me.domain.Custom&quot;&gt;        &lt;id column=&quot;customid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findCCO&quot; resultMap=&quot;resultmap1&quot;&gt;    SELECT orders.*,custom.* FROM custom,orders WHERE orders.customid=custom.id&lt;/select&gt;</code></pre><p>这里，在resultMap里少添加或者在select后面少写一项属性，得到的对象属性就会少一项属性的值（<del>所以不要偷懒少写属性</del>）。</p></li></ol><hr><ul><li><strong>一对多：</strong></li></ul><p>上面的一对一反过来，问题就变成了一对多，即一个custom对应多个orders。<br>对于一对多关系，我直接介绍最有效率的方法：<br>使用resultMap：</p><pre><code>&lt;resultMap type=&quot;custom&quot; id=&quot;ccus&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;    &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;com.me.domain.Orders&quot;&gt;        &lt;id column=&quot;order_id&quot; property=&quot;orderid&quot;/&gt;        &lt;result column=&quot;thing&quot; property=&quot;thing&quot; /&gt;        &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectCus&quot; resultMap=&quot;ccus&quot;&gt;    SELECT c.*,o.orderid order_id,o.thing,o.customid FROM custom c,orders o WHERE c.id=o.customid&lt;/select&gt;</code></pre><p>注意这里是collection，执行后会把符合条件的orders一条一条映射到custom的list\<orders>属性。</orders></p><p><strong>注意事项：</strong>如果关联表中有列名和主表列名相同，必须要设置别名，否则查询结果会有问题。</p><blockquote><p><a href="https://blog.csdn.net/xzm_rainbow/article/details/15336933" target="_blank" rel="noopener">具体可以看这里</a></p></blockquote><hr><ul><li><strong>多对多：</strong></li></ul><p><a href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/">具体看这篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;动态Sql&quot;&gt;&lt;a href=&quot;#动态Sql&quot; class=&quot;headerlink&quot; title=&quot;动态Sql&quot;&gt;&lt;/a&gt;动态Sql&lt;/h2&gt;&lt;p&gt;mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】笔记1</title>
    <link href="http://xfff.xyz/2018/11/06/%E3%80%90leetcode%E3%80%91%E7%AC%94%E8%AE%B01/"/>
    <id>http://xfff.xyz/2018/11/06/【leetcode】笔记1/</id>
    <published>2018-11-06T06:40:33.000Z</published>
    <updated>2019-01-31T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p><strong>Given an array of integers, return  </strong>indices<strong>  of the two numbers such that they add up to a specific target.<br>You may assume that each input would have  </strong><em>exactly</em><strong>  one solution, and you may not use the  <em>same</em>  element twice.</strong></p><p><strong>Example:</strong></p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[**0**] + nums[**1**] = 2 + 7 = 9,return [**0**, **1**].</code></pre><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">    int[] result = new int[2];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    for (int i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        if (map.containsKey(target - numbers[i])) &#123;</span><br><span class="line">            result[1] = i;</span><br><span class="line">            result[0] = map.get(target - numbers[i]);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(numbers[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Hashmap结构，将值存在key，数组索引序号存在value里，使用containsKey方法简易地寻找和为target的对应项，若存在则返回对应下标，不存在就加入到map中。</p><hr><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><p>Given a string, find the length of the  <strong>longest substring</strong>  without repeating characters.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> “abcabcbb”<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The answer is <code>&quot;abc&quot;</code>, with the length of 3. </p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> “bbbbb”<br><strong>Output:</strong> 1 <strong>Explanation:</strong> The answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> “pwwkew”<br><strong>Output:</strong> 3 <strong>Explanation:</strong> The answer is <code>&quot;wke&quot;</code>, with the length of 3.<br>             Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.<br>即寻找最长连续子串</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><pre><code>public int lengthOfLongestSubstring(String s) {    int n=s.length();    HashSet&lt;Character&gt; sett=new HashSet&lt;&gt;();    int maxlen=0,j=0,k=0;    while (j&lt;n&amp;&amp;k&lt;n) {        if(sett.contains(s.charAt(j))) {            sett.remove(s.charAt(k));            k++;        }else {            sett.add(s.charAt(j));            j++;            maxlen=Math.max(maxlen, j-k);        }    }    return maxlen;}</code></pre><p>利用HashSet结构，从字符串开始处索引，当没有重复字符时，定义的一个指针j递增，并计算最长的子串长度，当遇到重复字符时，另一指针k递增，并逐个移除Set集合里的值，直到将重复的字符移出。</p><hr><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h2><p>There are two sorted arrays  <strong>nums1</strong>  and  <strong>nums2</strong>  of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume  <strong>nums1</strong>  and  <strong>nums2</strong> cannot be both empty.</p><p><strong>Example 1:</strong></p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0</p><p><strong>Example 2:</strong></p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>A</p><pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {    int m=nums1.length,n=nums2.length;    int slen=m+n;    int num[]=new int[slen];    int j=0,k=0,i=0;    while(j&lt;m&amp;&amp;k&lt;n){        num[i]=(nums1[j]&gt;nums2[k]?nums2[k++]:nums1[j++]);        i++;    }    while(j&lt;m){        num[i++]=nums1[j++];    }    while(k&lt;n){        num[i++]=nums2[k++];    }    if(slen%2==1){        return num[slen/2];    }else{        return (double)(num[slen/2]+num[slen/2-1])/2;    }}</code></pre><p>这个算法很容易理解，就是把两个数组重新排序到一个大数组里，再算中位数就很容易。</p><p>B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">    int m = nums1.length;</span><br><span class="line">    int n = nums2.length;</span><br><span class="line">    int len = m + n;</span><br><span class="line">    if(len % 2 == 0)&#123;</span><br><span class="line">        double left =  (double)findKthHelper(nums1, 0, nums2, 0, len/2);</span><br><span class="line">        double right =  (double)findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class="line">        return (double)(left + right)/2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return findKthHelper(nums1, 0, nums2, 0, len/2 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private int findKthHelper(int[] A, int aStart, int[] B, int bStart, int k)&#123;</span><br><span class="line">    if(aStart &gt;= A.length)&#123;</span><br><span class="line">        return B[bStart + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(bStart &gt;= B.length)&#123;</span><br><span class="line">        return A[aStart + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(k == 1)&#123;</span><br><span class="line">        return Math.min(A[aStart], B[bStart]);</span><br><span class="line">    &#125;</span><br><span class="line">    int aMid = aStart + k/2 - 1;</span><br><span class="line">    int bMid = bStart + k/2 - 1;</span><br><span class="line">    int aVal = aMid &gt;= A.length ? Integer.MAX_VALUE : A[aMid];</span><br><span class="line">    int bVal = bMid &gt;= B.length ? Integer.MAX_VALUE : B[bMid];</span><br><span class="line">    if(aVal &lt;= bVal)&#123;</span><br><span class="line">        return findKthHelper(A, aMid + 1, B, bStart, k - k/2);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return findKthHelper(A, aStart, B, bMid + 1, k - k/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于二分法，比较AMid和BMid保留应该保留的部分递归，直至K==1.</p><hr><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><p>Given a string  <strong>s</strong>, find the longest palindromic substring in  <strong>s</strong>. You may assume that the maximum length of  <strong>s</strong>  is 1000.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> “babad”<br><strong>Output:</strong> “bab”<br><strong>Note:</strong> “aba” is also a valid answer.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> “cbbd”<br><strong>Output:</strong> “bb”</p><h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><pre><code>public String longestPalindrome(String s) {    if(s.length()&lt;1) return s;    StringBuilder str=new StringBuilder(s);    StringBuilder rs=new StringBuilder(s);    rs.reverse();    int len=s.length();    String outstr=&quot;&quot;;    for(int i=0;i&lt;=len-1;i++) {        for(int n=2;n&lt;=len-i;n++) {            if(str.substring(i, n+i).equals(rs.substring(len-n-i, len-i))) {                if(str.substring(i, n+i).length()&gt;outstr.length()) {                    outstr=str.substring(i, n+i);                }             }        }    }    if(outstr.equals(&quot;&quot;)) {        outstr=str.substring(0, 1);    }    return outstr;}</code></pre><p>将原字符串反转，通过比较对应位置的子字符串</p><p>Better Solution</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private int lo, maxLen;</span><br><span class="line"></span><br><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">int len = s.length();</span><br><span class="line">if (len &lt; 2)</span><br><span class="line">return s;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; len-1; i++) &#123;</span><br><span class="line">     extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible</span><br><span class="line">     extendPalindrome(s, i, i+1); //assume even length.</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substring(lo, lo + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void extendPalindrome(String s, int j, int k) &#123;</span><br><span class="line">while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span><br><span class="line">j--;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">if (maxLen &lt; k - j - 1) &#123;</span><br><span class="line">lo = j + 1;</span><br><span class="line">maxLen = k - j - 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extendPalindrome方法选定一个中心，以两个指针j和k分别向俩个方向延伸，遍历完字符串即可。</p><hr><h2 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for  <code>&#39;.&#39;</code>  and  <code>&#39;*&#39;</code>.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p><p>The matching should cover the  <strong>entire</strong>  input string (not partial).</p><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters  <code>a-z</code>.</li><li><code>p</code>  could be empty and contains only lowercase letters  <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p><strong>Example 1:</strong></p><p><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong><br>s = “aa”<br>p = “a<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘</em>‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong><br>s = “ab”<br>p = “.<em>“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “.</em>“ means “zero or more (*) of any character (.)”.</p><p><strong>Example 4:</strong></p><p><strong>Input:</strong><br>s = “aab”<br>p = “c<em>a</em>b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p><p><strong>Example 5:</strong></p><p><strong>Input:</strong><br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br><strong>Output:</strong> false</p><h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p>正则表达式</p><pre><code>public boolean isMatch(String s, String p) {    java.util.regex.Pattern pattern=java.util.regex.Pattern.compile(p);    java.util.regex.Matcher matcher=pattern.matcher(s);    if(matcher.matches()) {        return true;    }else {        return false;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">    if (s == null || p == null) &#123;</span><br><span class="line">        return s == p;</span><br><span class="line">    &#125;</span><br><span class="line">    char[] sArray = s.toCharArray();</span><br><span class="line">    char[] pArray = p.toCharArray();</span><br><span class="line">    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];</span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">        if (p.charAt(j - 1) == &apos;*&apos;) &#123; // * is promised not to be the first char</span><br><span class="line">            dp[0][j] = dp[0][j - 2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; dp.length; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt; dp[0].length; j++) &#123;</span><br><span class="line">            if (pArray[j - 1] == sArray[i - 1] || pArray[j - 1] == &apos;.&apos;) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else if (pArray[j - 1] == &apos;*&apos;) &#123;</span><br><span class="line">                if (sArray[i - 1] == pArray[j - 2] || pArray[j - 2] == &apos;.&apos;) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - 2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[dp.length - 1][dp[0].length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Given an array of integers, retu
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://xfff.xyz/tags/LeetCode/"/>
    
      <category term="算法" scheme="http://xfff.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】多对多关系</title>
    <link href="http://xfff.xyz/2018/11/05/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/"/>
    <id>http://xfff.xyz/2018/11/05/【mybatis】多对多关系/</id>
    <published>2018-11-05T09:02:07.000Z</published>
    <updated>2019-02-19T06:14:33.178Z</updated>
    
    <content type="html"><![CDATA[<p><em>关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。</em></p><hr><ul><li><strong>首先，创建表，建立连接关系。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2l7b67ej30ib0e8jrg.jpg" alt=""></li></ul><ul><li><strong>然后，插入示例数据。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2mq19o5j30ib0e8q30.jpg" alt=""></li></ul><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2n7k9vwj30ib0e8glp.jpg" alt=""></p><p>打印一下，记录<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2nxp4o4j30ib0kiaa1.jpg" alt=""></p><p>分别为三张表，一张银行用户表，简单起见，只有id和name两列，一张银行卡表，有id和money两列，最后是一张关系维护表，有三列，id、对应用户的buserid、对应卡的bcardid。</p><p>我设定的银行卡为家庭卡，可以多个人用一个账号，一个人可以用多张卡。</p><h2 id="前提准备做完了，开始建立多对多关系映射。"><a href="#前提准备做完了，开始建立多对多关系映射。" class="headerlink" title="前提准备做完了，开始建立多对多关系映射。"></a>前提准备做完了，开始建立多对多关系映射。</h2><ol><li>创建用户和卡的表对应的实体类，并设置对应的映射属性，分别加入一个list\<t>属性。如下：</t></li></ol><pre><code>package com.test.domain;import java.util.List;public class Buser {    private int id;    private String name;    private List&lt;Bcard&gt; bcards;    public List&lt;Bcard&gt; getBcards() {        return bcards;    }    public void setBcards(List&lt;Bcard&gt; bcards) {        this.bcards = bcards;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><ol start="2"><li><p>创建并配置对应的mapper映射文件</p><pre><code>&lt;mapper namespace=&quot;com.test.mapper.BuserMapper&quot;&gt;    &lt;resultMap type=&quot;buser&quot; id=&quot;resultUmap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;&lt;!--         &lt;collection property=&quot;uList&quot; ofType=&quot;com.test.domain.Ctou&quot;&gt;            &lt;id column=&quot;c_id&quot; property=&quot;id&quot; /&gt;            &lt;result column=&quot;buserid&quot; property=&quot;buserid&quot; /&gt;            &lt;result column=&quot;bcardid&quot; property=&quot;bcardid&quot; /&gt;        &lt;/collection&gt; --&gt;        &lt;collection property=&quot;bcards&quot; ofType=&quot;com.test.domain.Bcard&quot;&gt;                &lt;id column=&quot;b_id&quot; property=&quot;id&quot; /&gt;                &lt;result column=&quot;money&quot; property=&quot;money&quot; /&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectMtoM&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;resultUmap&quot;&gt;        SELECT buser.*,bcard.id b_id,bcard.money from buser,ctou,bcard        where buser.id=#{value} and buser.id=ctou.buserid and ctou.bcardid=bcard.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li></ol><ol start="3"><li>创建对应接口和方法</li></ol><pre><code>public interface BuserMapper {    public Buser selectMtoM(Integer value) throws Exception;}</code></pre><ol start="4"><li><p>记得在总配置文件里配置</p><pre><code>&lt;typeAliases&gt;    &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;package name=&quot;com.test.domain&quot;/&gt;&lt;/typeAliases&gt;&lt;mappers&gt;    &lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; --&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;     &lt;package name=&quot;com.test.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre></li><li><p>测试</p><pre><code>Buser buser=buserMapper.selectMtoM(111);System.out.println(buser.getName());for (Bcard bcard : buser.getBcards()) {    System.out.println(bcard.getId()+&quot; &quot;+bcard.getMoney());}</code></pre></li></ol><ol start="6"><li>结果输出：<br>胡歌<br>1002 0<br>1003 10000</li></ol><hr><p>反过来从bcard来查buser也一样的步骤。</p><p>over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先，创建表，建立连接关系。&lt;/stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】大概总结(一)</title>
    <link href="http://xfff.xyz/2018/11/03/%E3%80%90mybatis%E3%80%91%E5%A4%A7%E6%A6%82%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://xfff.xyz/2018/11/03/【mybatis】大概总结(一)/</id>
    <published>2018-11-03T09:02:07.000Z</published>
    <updated>2019-02-19T06:13:14.530Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#c">原生访问数据库方法</a><br><a href="#a">总配置文件</a><br><a href="#mapper">mapper配置</a><br><a href="#mapperj">mapper接口</a><br><a href="#mapperc">使用示例</a></p><hr><p><span id="c"></span></p><h2 id="原生访问数据库方法-jdbc"><a href="#原生访问数据库方法-jdbc" class="headerlink" title="原生访问数据库方法:jdbc"></a>原生访问数据库方法:jdbc</h2><p><strong>jdbc编程步骤:</strong></p><ol><li>加载数据库驱动</li><li>创建并获取数据库链接</li><li>创建jdbc statement对象</li><li>设置sql语句</li><li>设置sql语句中的参数(使用preparedStatement)</li><li>通过statement执行sql并获取结果</li><li>对sql执行结果进行解析处理</li><li>释放资源(resultSet、preparedstatement、connection)</li></ol><p><strong>缺点</strong>：每次对数据库操作时就得建立连接，用完又得释放，非常不方便，且对数据库造成压力较大。不灵活， 程序耦合度高。</p><hr><h1 id="–Mybatis–"><a href="#–Mybatis–" class="headerlink" title="–Mybatis–"></a>–Mybatis–</h1><p>与hibernate类似，mybatis也让表和java类产生映射关系，通过配置映射文件实现。</p><p>可创建相应实体类.xml，并在mybatis配置文件中加载（这里省略这种方法）。</p><p><span id="a"></span></p><h2 id="首先配置mybatis总配置文件SqlMapConfig-xml"><a href="#首先配置mybatis总配置文件SqlMapConfig-xml" class="headerlink" title="首先配置mybatis总配置文件SqlMapConfig.xml"></a>首先配置mybatis总配置文件SqlMapConfig.xml</h2><p><strong>注意事项:</strong></p><ul><li><strong>标签有固定的配置顺序</strong>：<br>properties（属性）<br>settings（全局配置参数）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）</li><li><strong>mybatis使用自带的数据库连接池，不支持第三方连接池（网上有添加方法）</strong></li></ul><p><strong>配置建议：</strong></p><ul><li><p><strong>别名配置typeAliases</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.domain&quot;/&gt;</code></pre><p>其中com.me.domain是你要自动配置的包里类的别名（用对应类名配置）</p></li></ul><ul><li><p><strong>mappers映射器配置</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.mapper&quot;/&gt;</code></pre><p>其中com.me.mapper对应配置的mapper的包名（同上）</p></li></ul><hr><p>示例（只配置了部分配置）:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><p><span id="mapper"></span></p><h2 id="mapper映射器配置"><a href="#mapper映射器配置" class="headerlink" title="mapper映射器配置"></a>mapper映射器配置</h2><p><strong>输入映射：</strong><br>resultType指定输入参数类型：</p><ul><li>简单类型(直接使用)</li><li>hashmap(直接使用)</li><li>pojo的包装类型（<strong>常用</strong>）：<br>通过创建一个新的类，在这个类里创建想用来操作的输入参数，并生成set和get方法</li></ul><p><strong>输出映射：</strong></p><ul><li><strong>resultType</strong>：列名与属性名一致才能成功映射<ul><li>输出简单类型</li><li>输出pojo对象和列表</li></ul></li><li><strong>resultMap</strong>：可以定义列的别名，通过别名来映射<ul><li>输出配置的resultMap的id对应的对象</li></ul></li></ul><p>resultMap需要先在mapper里配置resultMap（使用时若要用其他mapper里的resultMap配置，需要在前面加上对应mapper的namespace）示例：</p><pre><code>&lt;!-- 定义resultMap将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系type：resultMap最终映射的java对象类型,可以使用别名id：对resultMap的唯一标识 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;    &lt;!-- id表示查询结果集中唯一标识     column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）    --&gt;    &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;    &lt;!--     result：对普通名映射定义    column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）     --&gt;    &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt;</code></pre><p>使用示例:</p><pre><code>&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    SELECT id id_,username username_ FROM USER WHERE id=#{value}&lt;/select&gt;</code></pre><p>另外在接口中，返回类型写map对应实体类就OK</p><hr><p>Mapper配置示例:</p><pre><code>&lt;!DOCTYPE mapper    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.me.mapper.GoodsMapper&quot;&gt;&lt;resultMap type=&quot;goods&quot; id=&quot;goodsResultMap&quot;&gt;    &lt;id column=&quot;gname_haha&quot; property=&quot;gname&quot; /&gt;    &lt;result column=&quot;price_haha&quot; property=&quot;price&quot; /&gt;&lt;/resultMap&gt;&lt;insert id=&quot;insertGoods&quot; parameterType=&quot;goods&quot;&gt;    INSERT INTO GOODS(gname,price) VALUE(#{gname},#{price})&lt;/insert&gt;&lt;select id=&quot;selectall&quot; resultMap=&quot;goodsResultMap&quot;&gt;    SELECT gname gname_haha,price price_haha FROM goods&lt;/select&gt;</code></pre><p></p><hr><p><span id="mapperj"></span></p><h2 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a><strong>Mapper接口：</strong></h2><p>创建mapper.xml映射器对应的接口。<br>在mapper.xml中配置的方法，需要在mapper接口类里配置:<br>其中必须符合以下<strong>四</strong>个规范:</p><ul><li>mapper接口类和映射文件在同一包下</li><li>mapper接口里方法名与映射文件配置id一致</li><li>mapper接口方法参数和映射文件配置参数类型一致</li><li>mapper接口方法返回类型和映射文件配置参数类型一致（可以用list&lt;类&gt;，会自动调用selectlist返回对应对象的list集合）</li></ul><p>示例:</p><pre><code>package com.me.mapper;import java.util.List;import com.me.domain.User;import com.me.domain.UserQuery;public interface UserMapper {    public User findUserById(Integer userid) throws Exception;    public User selectUserQuery(UserQuery userQuery) throws Exception;    public void updateUser(User user) throws Exception;    public List&lt;User&gt; findUserByName(String string) throws Exception;    public List&lt;User&gt; selectUserList(UserQuery userQuery) throws Exception;}</code></pre><hr><p><span id="mapperc"></span></p><h2 id="使用mapper操作数据："><a href="#使用mapper操作数据：" class="headerlink" title="使用mapper操作数据："></a>使用mapper操作数据：</h2><p>示例:</p><pre><code>import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.me.domain.Goods;import com.me.domain.User;import com.me.domain.UserQuery;import com.me.mapper.GoodsMapper;import com.me.mapper.UserMapper;public class Tmybati {    SqlSessionFactory sessionFactory;    //这个注解会让这个方法在test方法前执行    @Before    public void a() throws IOException {        String string=&quot;SqlMapConfig.xml&quot;;        InputStream inputStream=Resources.getResourceAsStream(string);        sessionFactory=new SqlSessionFactoryBuilder().build(inputStream);    }    //测试方法    @Test    public void tess() throws Exception {        SqlSession session=sessionFactory.openSession();        UserMapper userMapper=session.getMapper(UserMapper.class);/*                User user2=new User();        user2.setUserid(1111);        Goods goods=new Goods();        goods.setGname(&quot;吴克&quot;);        goods.setPrice(1111);        UserQuery userQuery=new UserQuery();        userQuery.setUser(user2);        userQuery.setGoods(goods);        List&lt;User&gt; users=userMapper.selectUserList(userQuery);        users.stream().forEach(System.out::println);        User user=userMapper.findUserById(1111);        System.out.println(user);*/        Goods dGoods =new Goods();        dGoods.setGname(&quot;吴克5&quot;);        dGoods.setPrice(1111);        GoodsMapper goodsMapper=session.getMapper(GoodsMapper.class);        List&lt;Goods&gt; goods=goodsMapper.selectall();        goods.stream().filter(n-&gt;n.getPrice()==123).forEach(System.out::println);        session.commit();        session.close();    }}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#c&quot;&gt;原生访问数据库方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#a&quot;&gt;总配置文件&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapper&quot;&gt;mapper配置&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapperj&quot;&gt;mapper接口&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#ma
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>线程池的基本使用</title>
    <link href="http://xfff.xyz/2018/10/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/30/线程池的基本使用/</id>
    <published>2018-10-30T06:23:35.000Z</published>
    <updated>2018-10-30T08:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>要用到线程池，就要先介绍一个类：<strong>ThreadPoolExecutor</strong>.</p><p>通过查看源码发现继承及实现关系为<br><img src="http://www.plantuml.com/plantuml/png/SoWkIImgAStDuGh9A4fDJ0d8pyznhKXDBYt9BrBGjLDmJ2ekAKfCBe691QSMbMKcfreff5QKfEQb57FXK03IYw4dCxSW9pKtDQ-ac0kFSYkOqGv04kWo0000" alt=""></p><hr><p>在ThreadPoolExecutor类中，发现有四种构造方法，需要传入很多参数。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    if (corePoolSize &lt; 0 ||        maximumPoolSize &lt;= 0 ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; 0)        throw new IllegalArgumentException();    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    this.acc = System.getSecurityManager() == null ?            null :            AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}</code></pre><h2 id="这里对常见的参数进行解释："><a href="#这里对常见的参数进行解释：" class="headerlink" title="这里对常见的参数进行解释："></a>这里对常见的参数进行解释：</h2><ul><li><strong>corePoolSize</strong>：核心池的大小</li><li><strong>maximumPoolSize</strong>：线程池大小（最大能容纳线程数）</li><li>keepAliveTime：允许线程空闲时间。当线程池中线程数大于核心池大小时，当有线程空闲时间超过keepAliveTime就会终止。如果调用了allowCoreThreadTimeOut(boolean)方法，则核心池中的空闲线程也会被终止。</li><li>unit：keepAliveTime的时间单位，格式TimeUnit.XXXX(XXXX用HOURS、MILLISECONDS等替代)</li><li><strong>workQueue</strong>：阻塞队列，一般可选三种类型<ul><li>ArrayBlockingQueue数组类型，指定大小</li><li>LinkedBlockingQueue链表类型，不用指定大小</li><li>SynchronousQueue：<a href="https://www.cnblogs.com/duanxz/p/3252267.html" target="_blank" rel="noopener">CLICK</a></li><li>PriorityBlockingQueue</li></ul></li><li>threadFactory：线程工厂，主要用来创建线程</li><li>handler：指定拒绝处理任务时的策略</li></ul><hr><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>实例化一个ThreadPoolExecutor类</p><pre><code>ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;,5));</code></pre><p>核心池大小为5，线程池大小为10，线程允许空闲200ms，阻塞队列大小5.</p><p>然后，创建20个线程并每次打印线程池中的状态</p><pre><code>for(int a=0;a&lt;20;a++) {    executor.execute(new ThreadPoolT(a));    System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());}</code></pre><p>其中线程的run方法为</p><pre><code>    @Overridepublic void run() {    // TODO Auto-generated method stub    System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);    try {        Thread.sleep(2000);    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }    System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);}</code></pre><p>关闭线程池</p><pre><code>executor.shutdown();</code></pre><p>总代码</p><pre><code>package com.test;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class ThreadPoolT implements Runnable{    private int id;    public ThreadPoolT(int id) {        super();        this.id = id;    }    public static void main(String[] args) {        ThreadPoolExecutor executor=new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5));        for(int a=0;a&lt;20;a++) {            executor.execute(new ThreadPoolT(a));            System.out.println(&quot;线程池中线程数目&quot;+executor.getPoolSize()+&quot;正在等待执行的任务数目&quot;+executor.getQueue().size()+&quot;已经执行完的任务数目:&quot;+executor.getCompletedTaskCount());        }        System.out.println(executor.getLargestPoolSize());        System.out.println(executor.getPoolSize());        executor.shutdown();    }    @Override    public void run() {        // TODO Auto-generated method stub        System.out.print(&quot;线程&quot;+id+&quot;正在执行...&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;线程&quot;+id+&quot;结束..&quot;);    }}</code></pre><hr><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwqbapglbpj30xw0ezgnm.jpg" alt=""></p><p>可见</p><ol><li>线程池会先创建核心池大小量的线程数，并加入需运行的线程</li><li>然后再往线程池中加线程时，就会往阻塞队列里添加，等待执行</li><li>当阻塞队列满了，再往线程池里添加线程，这个时候线程池就会再创建新线程来弥补不足</li><li>当线程池满了（达到了maximumPoolSize ），再往线程池里添加线程时，线程池就会拒绝任务，而拒绝策略和之前参数的设置有关，这里是抛出RejectedExecutionException异常，并停止添加更多线程执行。</li><li>等待线程运行完</li></ol><hr><p>如果把前面的队列里的参数5去掉，并在线程池结束前加下列代码：</p><pre><code>Thread.sleep(10000);System.out.println(executor.getPoolSize()+&quot;AAAAAAAAAAAAAAA&quot;);executor.shutdown();</code></pre><p>则运行结果为：</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwqbr9olgfj30rn0hwgnk.jpg" alt=""></p><p>可见线程全部运行结束后核心池仍有5个线程，这便是线程池使用的优点，不用频繁开线程关线程，而是提供一些线程代理运行需要运行的线程，提高了程序效率。</p><hr><p>另外，其实一般使用线程池不用我们每次指定那么多参数。一般使用Executors类中提供的静态方法来创建线程池：</p><pre><code>//corePoolSize和maximumPoolSize值相等，它使用LinkedBlockingQueuepublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;(),                                  threadFactory);}//corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueuepublic static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}//corePoolSize设置为0，maximumPoolSize设置为Integer.MAX_VALUE，使用SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><hr><h2 id="合理设置线程池大小"><a href="#合理设置线程池大小" class="headerlink" title="合理设置线程池大小"></a>合理设置线程池大小</h2><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看：<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务 （2*cpu核心）<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要用到线程池，就要先介绍一个类：&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;通过查看源码发现继承及实现关系为&lt;br&gt;&lt;img src=&quot;http://www.plantuml.com/plantuml/png/SoWkIImgAS
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="java" scheme="http://xfff.xyz/tags/java/"/>
    
      <category term="多线程" scheme="http://xfff.xyz/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://xfff.xyz/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>文件上传解析冲突问题</title>
    <link href="http://xfff.xyz/2018/10/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>http://xfff.xyz/2018/10/25/文件上传解析冲突问题/</id>
    <published>2018-10-25T13:27:07.000Z</published>
    <updated>2018-10-25T13:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于在上一篇写ajax提交表单时，在springmvc.xml里配置了<strong>MultipartResolver</strong>，导致我引入的图片上传插件失效（上传显示成功，但是后台没有接收到），在利用各种搜索引擎查找问题之后，终于找到了原因。</p><hr><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>文件上传有两种方式，spring框架里的<strong>MultipartResolver</strong>解析以及传统的<strong>ServletFileUpload</strong>。<br>由于我引入的图片上传插件是第二种方式，而上篇写到的ajax提交表单需要MultipartResolver解析，<strong>两种方式一起使用会产生冲突</strong>。传统方式上传文件的请求会被multipartResolver拦截，导致没有解析出文件。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>统一使用同一种方式上传请求</li><li>继承MultipartResolver，并重写其中的方法，当遇到某些url请求的时候跳过</li></ol><p>由于我引入的插件代码稍微封装的有点麻烦，改起来肯定不方便，而另一边虽然可以改成传统方式发送表单数据，但是需要更多js代码来解析表单数据发送，所以我选择第二种方法。</p><p>事实证明第二种方法确实也更方便。</p><hr><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul><li><p>创建一个类MyMultipartResolver并让它继承MultipartResolver，下面代码贴出：</p><pre><code>package com.me.resolver;import javax.servlet.http.HttpServletRequest;import org.springframework.web.multipart.commons.CommonsMultipartResolver;public class MyMultipartResolver extends CommonsMultipartResolver {    //单url过滤以及多url过滤    private String excludeUrls;    private String[] excludeUrlArray;    public String getExcludeUrls() {        return excludeUrls;    }    //以逗号分隔    public void setExcludeUrls(String excludeUrls) {        this.excludeUrls=excludeUrls;        this.excludeUrlArray=excludeUrls.split(&quot;,&quot;);    }    //重写的方法，判断url是否需要multipartResolver解析    @Override    public boolean isMultipart(HttpServletRequest request) {        for(String url:excludeUrlArray) {            if(request.getRequestURI().contains(url)) {                return false;            }        }        return super.isMultipart(request);    }}</code></pre></li></ul><p>关键在于isMultipart里的判断</p><ul><li><p>接下来在springmvc.xml配置，删除之前MultipartResolver 的配置内容，修改为</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;com.me.resolver.MyMultipartResolver&quot;&gt;     &lt;property name=&quot;excludeUrls&quot; value=&quot;update&quot; /&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxUploadSize&quot; value=&quot;2097152&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;由此，两种方法就能和睦相处啦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于在上一篇写ajax提交表单时，在springmvc.xml里配置了&lt;strong&gt;MultipartResolver&lt;/strong&gt;，导致我引入的图片上传插件失效（上传显示成功，但是后台没有接收到），在利用各种搜索引擎查找问题之后，终于找到了原因。&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="error" scheme="http://xfff.xyz/tags/error/"/>
    
      <category term="resolver" scheme="http://xfff.xyz/tags/resolver/"/>
    
      <category term="文件上传" scheme="http://xfff.xyz/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>【ajax】springmvc下使用</title>
    <link href="http://xfff.xyz/2018/10/25/%E3%80%90ajax%E3%80%91springmvc%E4%B8%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/25/【ajax】springmvc下使用/</id>
    <published>2018-10-25T10:02:04.000Z</published>
    <updated>2018-10-25T10:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做ssm项目的时候用到ajax的记录…</p><hr><p>post方法：<br>动态获取div的value，隐藏对应的div项</p><pre><code>var str=this.value;$.post(&quot;lover/deleteL&quot;,{&quot;id&quot;:str},function(data){    alert(data);    $(&quot;#div&quot;+str).hide();});</code></pre><p>data为后台printwriter.write数据</p><hr><p>当用ajax提交form表单的时候<br>直接：</p><pre><code>$(&quot;#btntj&quot;).click(function(){    var form=new FormData(document.getElementById(&quot;forml&quot;));    $.ajax({        url:&quot;lover/addl&quot;,        type:&quot;post&quot;,         processData:false,        contentType:false,        data:form,        success:function(data){            alert(&quot;添加成功&quot;);            window.location.reload()        },        error:function(){            alert(&quot;添加失败&quot;);        }    }); });</code></pre><p>FormData类能自动把表单内的数据封装好，后台用request.getparemeter(“”)就能获得对应的值，可以说是十分方便了。另外，<strong>表单支持file文件上传类型</strong>。</p><p>后台代码（我这个项目暂时用到的提取方法）：</p><pre><code>@RequestMapping(&quot;/addl&quot;)public void addl(@RequestParam(&quot;lname&quot;) String name,@RequestParam(&quot;month&quot;) String month,@RequestParam(&quot;day&quot;) String day,@RequestParam(&quot;year&quot;)String year,HttpServletRequest request,PrintWriter writer) throws ParseException {    User user=(User) request.getSession().getAttribute(&quot;user&quot;);    Lover lover=new Lover();    lover.setUserid(user.getId());    lover.setName(name);    lover.setBirth(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(year+&quot;-&quot;+month+&quot;-&quot;+day));    loverServiece.saveLover(lover);    writer.write(name);}</code></pre><hr><p><strong>另外</strong>，由于表单提交的是request payload，要在springmvc配置文件中添加</p><pre><code>&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;   &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;maxInMemorySize&quot; value=&quot;10240000&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>才能生效。</p><p>可以通过maxUploadSize设置上传文件的总大小上限，maxInMemorySize设置上传时允许写到内存中的最大值（默认为10240字节）</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做ssm项目的时候用到ajax的记录…&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;post方法：&lt;br&gt;动态获取div的value，隐藏对应的div项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var str=this.value;
$.post(&amp;quot;lover/deleteL&amp;quot;,{
      
    
    </summary>
    
      <category term="ajax" scheme="http://xfff.xyz/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>【ajax】请求服务器+参数双向传递</title>
    <link href="http://xfff.xyz/2018/10/24/%E3%80%90ajax%E3%80%91%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8F%82%E6%95%B0%E5%8F%8C%E5%90%91%E4%BC%A0%E9%80%92/"/>
    <id>http://xfff.xyz/2018/10/24/【ajax】请求服务器-参数双向传递/</id>
    <published>2018-10-24T09:02:07.000Z</published>
    <updated>2019-02-19T06:12:49.496Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。</strong></p><hr><p> <strong>1. GET方式</strong></p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;GET&quot;,&quot;ajax!findRecord.action?&quot;+str,true);        xmlhttp.send();    });});</code></pre><p>通过在请求的URL”？”后加参数而达到传参的目的。<br>对于URL尾部的参数，后台action中只要通过request域对象即可取值。</p><pre><code>HttpServletRequest request=ServletActionContext.getRequest();HttpServletResponse response=ServletActionContext.getResponse();response.setContentType(&quot;text/html&quot;);response.setCharacterEncoding(&quot;UTF-8&quot;);Integer cardId=Integer.parseInt(request.getParameter(&quot;cardId&quot;));String date=request.getParameter(&quot;date&quot;);</code></pre><p>struts2里配置为:</p><pre><code>&lt;package name=&quot;actionA&quot; extends=&quot;json-default&quot;&gt;    &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt;    &lt;action name=&quot;ajax!*&quot; class=&quot;ajaxAction&quot; method=&quot;{1}&quot;&gt;        &lt;result type=&quot;json&quot;&gt;&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;</code></pre><hr><p> <strong>2. —- POST方式</strong><br>    &nbsp;post请求方式相对于get请求方式更加安全（数据信息不会显示在URL中），发送请求能提交的数据也更大。</p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;POST&quot;,&quot;ajax!findRecord.action&quot;,true);        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);        xmlhttp.send(str);    });});</code></pre><p>后台action内获取ajax发送来的数据参数方式同上。</p><hr><hr><h3 id="Ajax-ajax"><a href="#Ajax-ajax" class="headerlink" title="Ajax-ajax()"></a><strong>Ajax-ajax()</strong></h3><p>它是最底层、功能最强大的请求服务器数据方式，它的调用格式为：</p><pre><code>$.ajax([settings]);</code></pre><p>接下来是实际使用:</p><pre><code>$(document).ready(function(){    function doappend(list){        var tbody=&quot;&quot;;        for(i in list){            tbody+=&quot;&lt;tr&gt;&lt;td&gt;&quot;+list[i].userId+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].userName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].password+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].cards+&quot;&lt;/td&gt;&lt;td&gt;&lt;a href=\&quot;#\&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=\&quot;#\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;        }         document.getElementById(&quot;divtable&quot;).innerHTML=tbody;    };    $(&quot;#btnSend&quot;).click(function(){        $(this).attr(&quot;disabled&quot;,true);        var pag=document.getElementById(&quot;thepage&quot;).innerText;        $.ajax({            type:&quot;POST&quot;,            url:&quot;ajax!findall.action&quot;,            data:{&quot;page&quot;:pag},            dataType:&quot;json&quot;,            success:function(data){                var a=eval(&apos;(&apos;+data+&apos;)&apos;);                var am=a.aMap;                var list=am.user;                doappend(list);            }        });    });});</code></pre><p>data:标签对应为发送给服务器后台的数据，必须要使用json格式｛”name”:name,”id”:id｝。type对应请求方式，url为请求的定位，dataType为服务器返回数据的类型，success为成功获取服务器返回数据后可以执行的操作（这里我正在做分页，把页数发送给服务器，服务器查询数据库后返回相应条数的数据）。<br>function里的data为服务器返回的数据，这里是一个hashmap类型，先对data用eval方法进行json格式解析，aMap为当时hashmap设置的name值，在hashmap格式里，key值为‘user’对应的对象，为一个list<user>类型，具体可以看下面的后台代码，然后执行doappend方法，将数据一条一条加入到表格格式里。</user></p><pre><code>private String page;HashMap&lt;String, Object&gt; aMap=new HashMap&lt;String,Object&gt;();public HashMap&lt;String, Object&gt; getaMap() {    return aMap;}public String getPage() {    return page;}public void setPage(String page) {    this.page = page;}public String findall() {    int c=userService.count();    int d;    if(0==c%5) {        d=c/5;    }else {        d=(c/5)+1;    }    aMap.clear();    int p=Integer.parseInt(page);    if(p&lt;1||p&gt;d) {        return NONE;    }else {        int begin=(p-1)*5;        List&lt;User&gt; pList=userService.findPage(begin, 5);        List&lt;UserForAjax&gt; uList=new ArrayList&lt;UserForAjax&gt;();        for (User user : pList) {            StringBuffer sv=new StringBuffer(&quot;&quot;);            for(BankCard bCard:user.getSetBank()) {                sv.append(bCard.getCardId()+&quot; &quot;);            }            String str=sv.toString();            UserForAjax userForAjax=new UserForAjax();            userForAjax.setUserId(user.getUserId());            userForAjax.setEmail(user.getEmail());            userForAjax.setPassword(user.getPassword());            userForAjax.setUserName(user.getUserName());            userForAjax.setCards(str);            uList.add(userForAjax);        }        aMap.put(&quot;user&quot;, uList);        aMap.put(&quot;result&quot;, &quot;success&quot;);        return SUCCESS;    }}</code></pre><p>后台代码中，通过命名一个叫做page的string对象，并生成set和get方法，接收请求后，就能直接得到请求数据中的page对象的值（会调用set方法给this.page赋值），另外创建一个hashmap对象用来存放返回给前端的数据，并生成<strong>get</strong>方法，这样ajax那边才能得到返回的aMap，在方法中给aMap存入需要传递的值。</p><hr><p>一个简单的分页就做好啦!<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw7552c8jpj30x30at74d.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw755vane7j30x80apq30.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;strong&gt;1. GET方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(func
      
    
    </summary>
    
      <category term="ajax" scheme="http://xfff.xyz/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>mybatis操作text等长文本类型</title>
    <link href="http://xfff.xyz/2018/10/24/mybatis%E6%93%8D%E4%BD%9Ctext%E7%AD%89%E9%95%BF%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://xfff.xyz/2018/10/24/mybatis操作text等长文本类型/</id>
    <published>2018-10-24T06:41:17.000Z</published>
    <updated>2018-10-24T08:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>在实现将图片以base64编码为字符串存入数据库时，我遇到了这个问题。<br>由于字符串过长，创建表时我用text类型来存放图片对应的base64编码字符串。</p><hr><p><strong>最初，我以为是事务配置有问题，导致对表数据修改没有提交，在我试了各种配置方法。</strong></p><pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;        &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.me.service.*.*(..))&quot;/&gt;&lt;/aop:config&gt;</code></pre><p>注解扫描配置：</p><pre><code>&lt;bean id=&quot;transactionManager&quot;  class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;  &lt;/bean&gt;  &lt;!--使用注释事务 --&gt;  &lt;tx:annotation-driven  transaction-manager=&quot;transactionManager&quot; /&gt;</code></pre><hr><p>检验无误后我又认为是字符串不够长，把数据库的text类型改为mediumtext类型</p><pre><code>ALTER TABLE tableName modify column columnName 类型</code></pre><p>发现还是没用，问题依然不出在这。</p><p>网上说现在不推荐使用text类型，建议改为varchar(MAX)类型，于是我又尝试，发现mysql里没有该类型。</p><hr><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>最后终于发现，mybatis对于text这些大文本类型，有特殊的操作方法接口。在逆向工程生成的方法里，有一些方法后面带有WithBloBs字样，这些就是针对这些类型的方法。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdmuerbcj309x00ma9u.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdnupkygj30bw00rjr6.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdon8yb8j30jk00sdfo.jpg" alt=""></p><p>使用这些方法后，终于成功。</p><p>其中xml中的实现如下<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwjdpyqowxj30gf033t8s.jpg" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;在实现将图片以base64编码为字符串存入数据库时，我遇到了这个问题。&lt;br&gt;由于字符串过长，创建表时我用text类型来存放图片对应的base64编码字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;最初，我以为是事务配置有问题，导致对表数据修改没有提交，在我试了
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="图片" scheme="http://xfff.xyz/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>图片的上传和下载以及存入数据库</title>
    <link href="http://xfff.xyz/2018/10/22/%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://xfff.xyz/2018/10/22/图片的上传和下载以及存入数据库/</id>
    <published>2018-10-22T14:55:10.000Z</published>
    <updated>2018-10-22T15:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="首先添加jar包"><a href="#首先添加jar包" class="headerlink" title="首先添加jar包"></a>首先添加jar包</h2><p>这里我直接写maven依赖<br><span id="a"></span></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-logging&lt;/groupId&gt;    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;    &lt;type&gt;pom.lastUpdated&lt;/type&gt;&lt;/dependency&gt;</code></pre><hr><h2 id="表单："><a href="#表单：" class="headerlink" title="表单："></a>表单：</h2><pre><code>&lt;form action=&quot;Aservlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;tname&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;tfile&quot; /&gt;    &lt;button type=&quot;submit&quot;&gt;SSSS&lt;/button&gt;&lt;/form&gt;</code></pre><p>这里注意enctype的值</p><hr><h2 id="创建一个Servlet处理接收数据"><a href="#创建一个Servlet处理接收数据" class="headerlink" title="创建一个Servlet处理接收数据"></a>创建一个Servlet处理接收数据</h2><pre><code>PrintWriter out=response.getWriter();response.setContentType(&quot;text/html&quot;);try {    DiskFileItemFactory factory=new DiskFileItemFactory();    ServletFileUpload upload=new ServletFileUpload(factory);    upload.setHeaderEncoding(&quot;utf-8&quot;);    if(!ServletFileUpload.isMultipartContent(request)) {        return;    }    List&lt;FileItem&gt; list=upload.parseRequest(request);    for (FileItem fileItem : list) {        if(fileItem.isFormField()) {            //处理表单内非文件内容            String name=fileItem.getFieldName();            String value=fileItem.getString(&quot;UTF-8&quot;);        }else {            String filename=fileItem.getName();            if(filename.endsWith(&quot;.png&quot;)) {                //这里只接收以png结尾的文件                filename=filename.substring(filename.lastIndexOf(&quot;\\&quot;)+1);                //得到文件输入流                InputStream inputStream=fileItem.getInputStream();                        //创建一个新数组存放内容                byte data[]=new byte[inputStream.available()];                //写入数组                inputStream.read(data);                /*byte buffer[]=new byte[1024];                int len=0;                while((len=inputStream.read(buffer))&gt;0) {                    outputStream.write(buffer, 0, len);                }*/                inputStream.close();                //用base64编码为字符串，接下来就能存入数据库（未写）                String str=Base64.getEncoder().encodeToString(data);                request.getSession().setAttribute(&quot;img&quot;, str);                fileItem.delete();            }            else {                continue;            }        }    }}catch (Exception e) {    // TODO: handle exception}request.getRequestDispatcher(&quot;img.jsp&quot;).forward(request, response);</code></pre><p>这里是doget()里的内容</p><hr><h2 id="创建输出图片的servlet"><a href="#创建输出图片的servlet" class="headerlink" title="创建输出图片的servlet"></a>创建输出图片的servlet</h2><pre><code>//禁止缓存response.setDateHeader(&quot;Expires&quot;, -1);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);// 通知jsp以图片方式打开发送过去的数据response.setHeader(&quot;Content-Type&quot;, &quot;image/jpeg&quot;);String str=(String) request.getSession().getAttribute(&quot;img&quot;);OutputStream outputStream=response.getOutputStream();byte data[]=Base64.getDecoder().decode(str);outputStream.write(data);outputStream.close();</code></pre><p>base64解码，用response的输出流输出</p><hr><h2 id="显示图片的jsp"><a href="#显示图片的jsp" class="headerlink" title="显示图片的jsp"></a>显示图片的jsp</h2><pre><code>&lt;label&gt;图片:&lt;/label&gt;&lt;img width=&quot;200&quot; height=&quot;200&quot; src=&quot;${pageContext.request.contextPath}/Imgg&quot;/&gt;&lt;a href=&quot;${pageContext.request.contextPath}/DownS&quot;&gt;hahah&lt;/a&gt;</code></pre><p>可以设置图片的高和宽</p><hr><h2 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h2><p>通过上面的超链接请求downs这个servlet下载图片<br>doget()内容</p><pre><code>response.setDateHeader(&quot;Expires&quot;, -1);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);response.setHeader(&quot;content-disposition&quot;, &quot;attachment;&quot;);String str=(String) request.getSession().getAttribute(&quot;img&quot;);OutputStream outputStream=response.getOutputStream();byte data[]=Base64.getDecoder().decode(str);outputStream.write(data);outputStream.close();</code></pre><hr><p>遇到的错误或异常：<br><a href="https://blog.csdn.net/xiaoye142034/article/details/78852661" target="_blank" rel="noopener">使用EL表达式标红</a><br><a href="#a">缺少commons-logging</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;首先添加jar包&quot;&gt;&lt;a href=&quot;#首先添加jar包&quot; class=&quot;headerlink&quot; title=&quot;首先添加jar包&quot;&gt;&lt;/a&gt;首先添加jar包&lt;/h2&gt;&lt;p&gt;这里我直接写maven依赖&lt;br&gt;&lt;span id=&quot;a&quot;&gt;&lt;/span&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="数据库" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="javaweb" scheme="http://xfff.xyz/tags/javaweb/"/>
    
      <category term="图片的上传下载" scheme="http://xfff.xyz/tags/%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA8新特性】</title>
    <link href="http://xfff.xyz/2018/10/20/%E3%80%90JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/20/【JAVA8新特性】/</id>
    <published>2018-10-20T09:02:07.000Z</published>
    <updated>2019-02-19T06:12:20.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Lambda表达式"><a href="#一-Lambda表达式" class="headerlink" title="(一)Lambda表达式"></a>(一)Lambda表达式</h2><p>java8新特性支持lambda表达式，能让代码看起来更简洁。</p><pre><code>interface Aaa{public void printz(String z);}//老版本    String t=&quot;gggg&quot;;    Aaa olda=new Aaa() {        @Override        public void printz(String z) {            // TODO Auto-generated method stub            System.out.println(z);        }    };    olda.printz(t);    //JAVA 8    //变量t在只后不得更改值，否则会报错，Local variable t defined in an enclosing    //scope must be final or effectively final    //lambda表达式内部只能调用final修饰的变量    Aaa zAaa=((String z)-&gt;System.out.println(z+&quot;qq&quot;+t));    zAaa.printz(t);    //老版本    Runnable oldrunnable=new Runnable() {        @Override        public void run() {            // TODO Auto-generated method stub            System.out.println(&quot;helloWorld&quot;);        }    };    new Thread(oldrunnable).start();    //java 8    new Thread(()-&gt;System.out.print(&quot;helloWorld8&quot;)).start();</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6ltopgbuj303k01q0hu.jpg" alt=""></p><h2 id="（二）方法引用"><a href="#（二）方法引用" class="headerlink" title="（二）方法引用"></a>（二）方法引用</h2><pre><code>      List&lt;Name&gt; names = new ArrayList&lt;Name&gt;();      names.add(new Name(&quot;Bob&quot;));      names.add(new Name(&quot;JECK&quot;));      names.add(new Name(&quot;AICE&quot;));      names.add(new Name(&quot;SENCE&quot;));      names.add(new Name(&quot;MONTE&quot;));      names.forEach(Name::printz);}class Name{    private String name;    public Name(String name) {        this.name=name;    }    public void printz() {        System.out.println(name);    }}`</code></pre><p>输出<br>Bob<br>JECK<br>AICE<br>SENCE<br>MONTE</p><h2 id="（三）函数式接口"><a href="#（三）函数式接口" class="headerlink" title="（三）函数式接口"></a>（三）函数式接口</h2><p>java8新提供了很多函数式接口，具体自行搜索，这里用其中一种做例子。</p><pre><code>    public static void method1(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate) {    for (Integer integer : list) {        if(predicate.test(integer)) {            System.out.print(integer+&quot; &quot;);        }    }}    List&lt;Integer&gt; nIntegers=Arrays.asList(1,2,3,4,5,6,7,8,9,10);    //如何获取list里大于5的元素呢？    //老方法    for (Integer integer : nIntegers) {        if(integer&gt;5) {            System.out.print(integer+&quot; &quot;);        }    }    System.out.println();    //运用java8提供的函数接口    method1(nIntegers, n-&gt;n&gt;5);    System.out.println();    //运用java8新特性省略方法，更简洁    nIntegers.stream().filter(n-&gt;n&gt;5).forEach(System.out::print);</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6nh9r48ij303p01h0gw.jpg" alt=""></p><h2 id="（四）默认方法"><a href="#（四）默认方法" class="headerlink" title="（四）默认方法"></a>（四）默认方法</h2><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个default关键字即可实现默认方法<br>    为了解决接口的修改与现有的实现不兼容的问题。</p><pre><code>public class Java8Test {@Testpublic void test() {    System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));    CarS car=new CarS();    car.ss();}public interface Car{default void haha() {    System.out.println(&quot;haha&quot;);}}public interface Bus{default void haha() {    System.out.println(&quot;heihei&quot;);}}public class CarS implements Car,Bus{public void ss() {    haha();}@Overridepublic void haha() {    // TODO Auto-generated method stub    Bus.super.haha();    Car.super.haha();}}}</code></pre><h2 id="（五）Stream"><a href="#（五）Stream" class="headerlink" title="（五）Stream"></a>（五）Stream</h2><p>java8引入一种新的抽象称做流Stream，能以声明的方式来处理数据。</p><p>下面代码实现了随机产生10个数，并把大于0的数输出。</p><pre><code>Random random=new Random();random.ints().limit(10).filter(n-&gt;n&gt;0).forEach(System.out::println);</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teiaq9ij305j01g0mq.jpg" alt=""></h2><p>下面代码对list里的字符串重复拼接输出到5条记录的数组里，并输出数组。            </p><pre><code>List&lt;String&gt; sList=Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);System.out.println(sList.stream().map(n-&gt;n+n).limit(5).collect(Collectors.toList()));</code></pre><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teszddcj306w00m0cp.jpg" alt=""></p><p>另外，parallelStream()相对于stream()，是流并行处理方式。<br>统计结果的收集器</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);                 IntSummaryStatistics  stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum());System.out.println(&quot;平均数 : &quot; + stats.getAverage());</code></pre><h2 id="（六）Optional类"><a href="#（六）Optional类" class="headerlink" title="（六）Optional类"></a>（六）Optional类</h2><p>一个可以存放null的容器，解决了nullpoint空指针问题。</p><pre><code>    Integer value1 = null;Integer value2 = 222;Optional&lt;Integer&gt; a = Optional.ofNullable(value1);  // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerExceptionOptional&lt;Integer&gt; b = Optional.of(value2);System.out.println(a.orElse(555));System.out.println(b.get());</code></pre><p>输出555<br>222<br>其中a.orElse为如果为空值则取555，b若为空则抛出异常。</p><h2 id="（七）Nashorn-JavaScript"><a href="#（七）Nashorn-JavaScript" class="headerlink" title="（七）Nashorn JavaScript"></a>（七）Nashorn JavaScript</h2><p>Nashorn 一个 javascript 引擎。</p><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p><p>实现了java和JavaScript互相调用。</p><pre><code>ScriptEngineManager  scriptEngineManager = new  ScriptEngineManager(); ScriptEngine  nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); String  name = &quot;Runoob&quot;; Integer  result = null; try  {  nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;); result = (Integer)   nashorn.eval(&quot;10 + 2&quot;);  }catch(ScriptException  e){   System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());    }     System.out.println(result.toString());</code></pre><p>输出Runoob  12</p><pre><code>var  BigDecimal  =  Java.type(&apos;java.math.BigDecimal&apos;); function calculate(amount, percentage)  { var result =  new  BigDecimal(amount).multiply(  new  BigDecimal(percentage)).divide(new  BigDecimal(&quot;100&quot;),  2,  BigDecimal.ROUND_HALF_EVEN);return result.toPlainString();  }  var result = calculate(568000000000000000023,13.9);  print(result);</code></pre><p>命令行运行上诉程序 : jjs xxx.js<br>结果：78952000000000002017.94</p><h2 id="（八）日期时间API"><a href="#（八）日期时间API" class="headerlink" title="（八）日期时间API"></a>（八）日期时间API</h2><p>旧版java中，日期时间相关的类存在诸多问题：<strong>非线程安全</strong>、<strong>设计差</strong>（java.util和java.sql中日期类名相同，但对应内容不一致，前者多了具体时间）、<strong>时区处理麻烦</strong>。</p><p>java8在java.time包里引入了很多新的API：local、 zoned….</p><pre><code>    // 获取当前的日期时间LocalDateTime currentTime = LocalDateTime.now();System.out.println(&quot;LocalDateTime.now: &quot; + currentTime);LocalDate date1 = currentTime.toLocalDate();System.out.println(&quot;localdatetime.tolocaldate=localdate: &quot; + date1);Month month = currentTime.getMonth();int day = currentTime.getDayOfMonth();int seconds = currentTime.getSecond();System.out.println(&quot;localdatetime.getmonth=month: &quot; + month +&quot;, localdatetime.getdayofmonth=int: &quot; + day +&quot;, localdatetime.getseconds=int: &quot; + seconds);//用当前时间，修改天数和年份LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);System.out.println(&quot;date2: &quot; + date2);//设置一个日期对象的值LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);System.out.println(&quot;date3: &quot; + date3);//设置时间的值LocalTime date4 = LocalTime.of(22, 15);System.out.println(&quot;date4: &quot; + date4);//用另一种格式设置时间LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);System.out.println(&quot;date5: &quot; + date5);</code></pre><p>输出：LocalDateTime.now: 2018-10-13T20:14:29.390<br>localdatetime.tolocaldate=localdate: 2018-10-13<br>localdatetime.getmonth=month: OCTOBER, localdatetime.getdayofmonth=int: 13, localdatetime.getseconds=int: 29<br>date2: 2012-10-10T20:14:29.390<br>date3: 2014-12-12<br>date4: 22:15<br>date5: 20:15:30</p><p><strong>时区相关:</strong></p><pre><code>    ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);System.out.println(&quot;date1: &quot; + date1);ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);System.out.println(&quot;ZoneId: &quot; + id);ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone);ZonedDateTime dateTime=ZonedDateTime.now(currentZone);System.out.println(&quot;当前时区时间:&quot;+dateTime);</code></pre><p>输出：<br>date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]<br>ZoneId: Europe/Paris<br>当期时区: Asia/Shanghai<br>当前时区时间:2018-10-13T20:20:45.466+08:00[Asia/Shanghai]</p><hr><p>时间相关的计算:计算上个月的今天是周几?</p><pre><code>LocalDateTime currentTime = LocalDateTime.now();currentTime=currentTime.withMonth(currentTime.getMonthValue()-1);System.out.println(currentTime.getDayOfWeek());</code></pre><p>结果:THURSDAY</p><h2 id="（九）Base64"><a href="#（九）Base64" class="headerlink" title="（九）Base64"></a>（九）Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><pre><code>   try {   // 使用基本编码   String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 比那么字符串 (基本) :&quot; + base64encodedString);   // 解码   byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);   System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));   base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);   StringBuilder stringBuilder = new StringBuilder();   for (int i = 0; i &lt; 10; ++i) {      stringBuilder.append(UUID.randomUUID().toString());   }   byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);   String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);   System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);   byte[] aString=Base64.getMimeDecoder().decode(mimeEncodedString);   String aString2=new String(aString,&quot;utf-8&quot;);   System.out.println(aString2);}catch(UnsupportedEncodingException e){   System.out.println(&quot;Error :&quot; + e.getMessage());}</code></pre><p>结果:<br>Base64 比那么字符串 (基本) :cnVub29iP2phdmE4<br>原始字符串: runoob?java8<br>Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=<br>Base64 编码字符串 (MIME) :ZDEzM2E2MGEtNTllMS00ZGI5LWE5OWItNDFkNWMwZWU4ZWRlNzVkMmM5NTctMjFmNi00NTM3LWE2<br>NjQtMTUwNmJkOGU0ZWZjNDk0YjEyMTctM2RhZi00NDQ0LTgzNGItYzE0ZWFiY2ZhZWUxYzUxYjNj<br>N2MtMjQ0My00Y2UwLTlhZWItNjE0M2EzZDUzNmQ5OGNjMTgxZTgtMjg3MS00ZDY0LTg0MDktZTgw<br>MGE2OTNlZDdiM2QyOTBiNmQtYTUyYi00NzY3LWFjZmYtMWM0ODRiOGNmNGQzZjhkZjQ0MDItOWMw<br>Ni00YjMzLWEyZGUtZDcxYzc4N2NiZjBkMzQ2ZTY1OWQtMjU1OS00ZDVjLWE3ZjktMDQyMWNmYmY4<br>MjVlMmNhMDhkZGItMDU5OC00Yjk1LTg2ZjktNTdmYWRjZDBjMDBiOWYyYmMzYWMtZDAwNi00ZThk<br>LTlhNjQtNTU3OTcxODk1NjZi<br>d133a60a-59e1-4db9-a99b-41d5c0ee8ede75d2c957-21f6-4537-a664-1506bd8e4efc494b1217-3daf-4444-834b-c14eabcfaee1c51b3c7c-2443-4ce0-9aeb-6143a3d536d98cc181e8-2871-4d64-8409-e800a693ed7b3d290b6d-a52b-4767-acff-1c484b8cf4d3f8df4402-9c06-4b33-a2de-d71c787cbf0d346e659d-2559-4d5c-a7f9-0421cfbf825e2ca08ddb-0598-4b95-86f9-57fadcd0c00b9f2bc3ac-d006-4e8d-9a64-55797189566b</p><hr><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Lambda表达式&quot;&gt;&lt;a href=&quot;#一-Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;(一)Lambda表达式&quot;&gt;&lt;/a&gt;(一)Lambda表达式&lt;/h2&gt;&lt;p&gt;java8新特性支持lambda表达式，能让代码看起来更简洁。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="java8" scheme="http://xfff.xyz/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>【ssm】ssm整合配置</title>
    <link href="http://xfff.xyz/2018/10/19/%E3%80%90ssm%E3%80%91ssm%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"/>
    <id>http://xfff.xyz/2018/10/19/【ssm】ssm整合配置/</id>
    <published>2018-10-19T09:46:56.000Z</published>
    <updated>2018-10-19T17:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>导入所有需要的包（添加maven依赖）:</strong></li></ul><pre><code>&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.mybatis&lt;/groupId&gt;         &lt;artifactId&gt;mybatis&lt;/artifactId&gt;         &lt;version&gt;3.4.5&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;         &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-core&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-web&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;         &lt;version&gt;3.1.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;jstl&lt;/artifactId&gt;         &lt;version&gt;1.2&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;junit&lt;/groupId&gt;         &lt;artifactId&gt;junit&lt;/artifactId&gt;         &lt;version&gt;4.12&lt;/version&gt;         &lt;type&gt;pom.lastUpdated&lt;/type&gt;     &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;        &lt;version&gt;3.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;        &lt;type&gt;pom.lastUpdated&lt;/type&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;        &lt;version&gt;1.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;/groupId&gt;        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;8.0.11&lt;/version&gt;      &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.mchange&lt;/groupId&gt;          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;          &lt;version&gt;0.9.5.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;aopalliance&lt;/groupId&gt;          &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;          &lt;version&gt;1.0&lt;/version&gt;          &lt;type&gt;pom.lastUpdated&lt;/type&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;</code></pre><hr><ul><li><strong>配置spring</strong></li></ul><p>为dao、service、transaction等层分别创建配置文件，方便管理。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe0l9i9lnj3080055wei.jpg" alt=""></p><p><strong>applicationContext-dao.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.me.mapper&quot; /&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-service.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.me.service&quot; /&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-trans.xml</strong>：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 切面aop&lt;aop:config&gt;    &lt;aop:pointcut expression=&quot;execution(* com.me.entity.TestClass.*(..))&quot; id=&quot;pointcut1&quot;/&gt;    &lt;aop:aspect ref=&quot;incretestclass&quot;&gt;        &lt;aop:before method=&quot;inc&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;aop:after method=&quot;afterturning&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt; --&gt;&lt;/beans&gt;</code></pre><hr><ul><li><p><strong>数据库配置文件</strong><br><strong>db.properties</strong></p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://localhost\:3306/photo?characterEncoding\=utf-8jdbc.username=rootjdbc.password=olonn</code></pre></li></ul><hr><p>##mybatis</p><ul><li><strong>SqlMapConfig.xml</strong></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;       &lt;!-- 配置扫描的包 --&gt;       &lt;context:component-scan base-package=&quot;com.me.controller&quot; /&gt;       &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;       &lt;mvc:annotation-driven /&gt;        &lt;!--访问静态资源 --&gt;       &lt;mvc:default-servlet-handler /&gt;       &lt;!-- 视图解析器 --&gt;       &lt;bean           class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;           &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;           &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;filter&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:springmvc/springmvc.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><hr><p>可使用逆向工程生成对应数据库下的pojo类和mapper配置文件及接口，复制到对应的包下。</p><hr><hr><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>创建一个service类</p><pre><code>package com.me.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.me.mapper.UserMapper;import com.me.pojo.User;@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public User selectUser(int i) {        return userMapper.selectByPrimaryKey(i);    }}</code></pre><p>创建一个controller</p><pre><code>package com.me.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.me.service.UserService;@Controllerpublic class LoginController {    @Autowired    private UserService uService;    @RequestMapping(value=&quot;/login&quot;)    public ModelAndView login() {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;/login&quot;);        modelAndView.addObject(&quot;user&quot;, uService.selectUser(101));        return modelAndView;    }}</code></pre><p>view目录下创建一个login.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    hahaha+${user.name}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe14h61gsj30m906tdg9.jpg" alt=""></p><hr><ul><li><strong>配置中遇到的异常和错误</strong><blockquote><p><a href="https://blog.csdn.net/u014805893/article/details/52016570" target="_blank" rel="noopener">通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明</a><br><a href="https://blog.csdn.net/eacter/article/details/44624505" target="_blank" rel="noopener">关于spring”通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明“的错误</a></p></blockquote></li></ul><p>其实都是spring配置中的schema配置错误，当缺少哪条时就应该补上对应的xsd文件，具体可以在org.springframework.context.config包下找到，但添加内容并不在这里面，如缺少context的xsd，就加</p><pre><code>http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsd</code></pre><p>配对存在，第二条后面加上具体内容和版本（导入什么包，就加写什么版本）。</p><hr><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入所有需要的包（添加maven依赖）:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;or
      
    
    </summary>
    
      <category term="ssm" scheme="http://xfff.xyz/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="spring" scheme="http://xfff.xyz/tags/spring/"/>
    
      <category term="ssm" scheme="http://xfff.xyz/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】注解开发的详细使用</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】注解开发的详细使用/</id>
    <published>2018-10-18T07:17:03.000Z</published>
    <updated>2018-10-24T17:33:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先，所有注解都要提前在配置文件中开启扫描。</strong><br><strong>&lt; context:component-scan base-package = “” /&gt;</strong><br>\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a> //指定扫描的路径<br>\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a> //排除扫描的路径</p><p>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:include-filter type=”regex” expression=”.controller.<em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.service.</em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.dao.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>=<br>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:exclude-filter type=”regex” expression=”.model.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>无论哪种情况\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a>和\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a>都不能同时存在</p><hr><p><strong>@Controller</strong><br>注册一个bean到spring，标记一个类为controller，这样才能被外界访问到</p><p><strong>@RequestMapping(“/xxx”)</strong><br>注册xxx请求绑定注解下面的类或方法.<br>该注解一共有六个属性，分别为value、method、consumes、produces、 params、headers。<br><strong>value</strong>：指定请求的实际地址，指定的地址可以是URI Template 模式，即请求的URI中可以包含变量，如<br>/test/{variable}/log.jsp,当请求/test/haha/log.jsp时，variable1对应为’haha’，配合@PathVariable使用。<br>另外，该注解还支持通配符</p><p><strong>method</strong>：指定请求的method类型， GET、POST、PUT、DELETE等</p><pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })public String testMethod() {        return &quot;method&quot; ;    }</code></pre><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法</p><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html<br><strong>produces</strong>：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br><strong>params</strong>：指定request中必须包含某些参数值时，才让该方法处理</p><pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })public String testParams() {       System. out .println( &quot;test Params...........&quot; ); return &quot;testParams&quot; ;    }</code></pre><p>上面代码表面当/aa.action?后面有param1=value&amp;param2={something}且无param3时才能成功访问下面的方法</p><p><strong>headers</strong>：指定request中必须包含某些指定的header值，才能让该方法处理请求<br>与params类似</p><pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; }) public String testHeaders() {         return &quot;headers&quot; ;    }</code></pre><p>在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法</p><hr><p><strong>@Resource和@Autowired</strong><br>两者都用来注入bean，@Resource其实并不是spring的注解，仔细看import部分可以看到是javax.annotation.*下的包。<br>共同点：可以写在bean的声明或者setter方法上，如果写在字段上，就不用写setter方法。<br>不同点：<br>@Autowired是按照类型装配对象，默认要求依赖对象必须存在，如果允许存在，设置required属性为false。按名称装配时要加@Qualifier(“xxx”)<br>@Resource默认按名称装配，需要配置name属性@Resource(name=”xxx”)，也可以设置type属性来按类型装配。</p><hr><p><strong>attribute类型{</strong><br><strong>@ModelAttribute</strong><br>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p><pre><code>@ModelAttribute ( &quot;hello&quot; ) public String getModel() {      System. out .println( &quot;-------------Hello---------&quot; );      return &quot;world&quot; ;   }</code></pre><p>上面代码会在访问方法执行前执行，打印，并把字符串”world”存入model对象中，对应关键字为”hello”<br>也可以在另外的方法参数前加上@ModelAttribute(“xxx”)即可把model里的xxx值映射到这个参数里</p><p><strong>@SessionAttributes</strong><br>将值放到session作用域中，写在class上面。</p><pre><code>@SessionAttributes(value={&quot;name&quot;,&quot;theid&quot;},type={User.class})public class MyController{    //xxxxxx....}</code></pre><p>上面的代码指定了遇到属性name或者theid或者User类型使用modelattribute注解存放的时候，都会存放到session对象里。当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称<br><strong>}</strong></p><hr><p><strong>request uri部分</strong>(variable/)<br><strong>@PathVariable</strong><br>用来将URL中的变量映射到方法的参数里</p><pre><code>@RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId,      @PathVariable(&quot;roleId&quot;) String roleId){      System.out.println(&quot;User Id : &quot; + userId);      System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;;  }</code></pre><hr><p><strong>request body部分</strong>{</p><p><strong>@RequestParam</strong><br>主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型</p><pre><code>public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {      //xxx  }    </code></pre><p><strong>@ResponseBody</strong><br>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT) public void handle(@RequestBody String body, Writer writer) throws IOException {    writer.write(body);  }</code></pre><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><p><strong>}</strong></p><hr><p><strong>request header部分{</strong><br><strong>@RequestHeader</strong></p><pre><code>public  void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,@RequestHeader(&quot;Keep-Alive&quot;)   long  keepAlive) {}</code></pre><p>这段代码把request header部分的Accept-Encoding和Keep-Alive值映射到对应的参数里。</p><p><strong>@CookieValue</strong></p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  }</code></pre><p>上面代码把cookie里的JSESSIONID值映射到对应的参数里。</p><p><strong>}</strong></p><hr><p>@Component<br>通用的注解，当不知道一个类归于哪层时，使用。不推荐使用。</p><p>@Repository<br>注解dao层，在daoImpl类上注解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;首先，所有注解都要提前在配置文件中开启扫描。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&amp;lt; context:component-scan base-package = “” /&amp;gt;&lt;/strong&gt;&lt;br&gt;\&lt;a href=&quot;context:incl
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="注解" scheme="http://xfff.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】配置和使用(二)</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】配置和使用-二/</id>
    <published>2018-10-18T03:38:00.000Z</published>
    <updated>2018-10-18T07:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据前面描述的工作流程，现在来对springmvc进行配置。</p><ul><li>首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。</li></ul><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;  &lt;/dependency&gt;</code></pre><hr><ul><li><p>创建springmvc的配置文件springmvc.xml (<del>可以任意，最好规范</del>)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;/beans&gt;</code></pre></li></ul><hr><ul><li><p>在web.xml中配置前端控制器。</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li></ul><p>注意param-value中的路径无误，<br>在url-pattern中有两种配置方式：<br>第一种:  *.action  ,访问以.action结尾，由DispatcherServlet进行解析<br><strong>第二种:  \/  ,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方式实现RESTful风格的url</strong></p><p> 错误配置:  \/*  ,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错404</p><hr><ul><li><p>配置处理器映射器</p><pre><code>&lt;bean  class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre></li></ul><ul><li><p>配置处理器适配器</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;</code></pre></li><li><p><strong>注解方式配置</strong></p><pre><code>&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;&lt;mvc:annotation-driven /&gt;</code></pre></li></ul><hr><ul><li>配置处理器Handler(controller)</li></ul><pre><code>&lt;bean  name=&quot;/xxx.action&quot;  class=&quot;com.iot.ssm.controller.xxx&quot;/&gt;</code></pre><ul><li><p><strong>注解批量扫描法</strong></p><pre><code>&lt;!-- 配置扫描的包 --&gt;&lt;context:component-scan base-package=&quot;com.springdemo.*&quot; /&gt;</code></pre></li></ul><hr><ul><li><p><strong>配置视图解析器</strong></p><pre><code>&lt;!-- 视图解析器 --&gt;&lt;bean    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><p>property中prefix对应要查找的目录，suffix对应自动添加的后缀</p><hr><hr><p>测试：</p><p>controller:</p><pre><code>package com.springdemo.controller;import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.swing.text.View;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.springdemo.domain.User;@Controller@RequestMapping(&quot;/demo&quot;)public class TestController implements org.springframework.web.servlet.mvc.Controller{    @RequestMapping(&quot;/demo&quot;)    public String index() {        return &quot;index&quot;;    }    @Override    @RequestMapping(&quot;/test&quot;)    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception {        Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;();         User user=new User();        user.setName(&quot;梁非凡&quot;);        user.setId(&quot;123&quot;);        map.put(&quot;user&quot;, user);        String str=&quot;刘醒&quot;;        map.put(&quot;str&quot;, str);        ModelAndView modelAndView=new ModelAndView();        modelAndView.addAllObjects(map);        modelAndView.setViewName(&quot;test&quot;);        return modelAndView;    }}</code></pre><p>test.jsp :</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${user.name}Hbbbbbbbbb&lt;/body&gt;&lt;/html&gt;</code></pre><p>配置到tomcat上，启动tomcat，打开浏览器，输入地址<br><a href="http://localhost:8888/SpringMVCTest/demo/test" target="_blank" rel="noopener">http://localhost:8888/SpringMVCTest/demo/test</a></p><p>得到：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwce2yvwflj311n0a7aan.jpg" alt=""></p><p>成功…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据前面描述的工作流程，现在来对springmvc进行配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
     
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="springmvc配置" scheme="http://xfff.xyz/tags/springmvc%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【好用的工具合集】</title>
    <link href="http://xfff.xyz/2018/10/10/%E3%80%90%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/10/【好用的工具合集】/</id>
    <published>2018-10-10T10:02:04.000Z</published>
    <updated>2019-01-11T09:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="项目开发类："><a href="#项目开发类：" class="headerlink" title="项目开发类："></a>项目开发类：</h2><ul><li><a href="https://www.cnblogs.com/xdp-gacl/p/4233289.html" target="_blank" rel="noopener">maven &gt;&gt;struts项目示例及插件</a></li><li><a href="#">git</a></li><li><a href="http://www.w3school.com.cn/tiy/t.asp?f=ajax_xml" target="_blank" rel="noopener">ajax普通请求示例</a></li><li><a href="https://blog.csdn.net/thinkscape/article/details/7467153" target="_blank" rel="noopener">ajax规范请求示例</a></li><li><a href="https://www.cnblogs.com/fjsnail/p/3491033.html" target="_blank" rel="noopener">springmvc上传文件</a>+<a href="https://www.cnblogs.com/hahaxiaoyu/p/5102900.html" target="_blank" rel="noopener">读取</a></li><li><a href="https://www.cnblogs.com/sunniest/p/4555801.html" target="_blank" rel="noopener">springmvc操作集合</a></li></ul><hr><h2 id="图形设计类"><a href="#图形设计类" class="headerlink" title="图形设计类:"></a>图形设计类:</h2><ul><li><a href="https://www.runoob.com/try/bootstrap/layoutit/#" target="_blank" rel="noopener">bootstrapHtml简易设计工具</a></li><li><a href="http://color.oulu.me/" target="_blank" rel="noopener">颜色渐变</a></li><li><a href="https://pan.baidu.com/s/1eQiXZKu" target="_blank" rel="noopener">截图工具FastStone Capture</a></li><li><a href="http://www.jq22.com/webide/" target="_blank" rel="noopener">jquery在线编辑器</a></li><li><a href="http://www.dmanywhere.cn/" target="_blank" rel="noopener">sql数据模型pdm文件在线解析</a></li></ul><hr><h2 id="github："><a href="#github：" class="headerlink" title="github："></a>github：</h2><ul><li><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">hexo</a>+<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">hexo</a></li><li><a href="https://www.cnblogs.com/YingYue/p/5894680.html" target="_blank" rel="noopener">git命令集合</a></li></ul><hr><h2 id="Markdown设计："><a href="#Markdown设计：" class="headerlink" title="Markdown设计："></a>Markdown设计：</h2><ul><li><a href="https://stackedit.io/app#" target="_blank" rel="noopener">Stackedit编辑器</a></li><li><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf" target="_blank" rel="noopener">图床-用来插入图片</a></li></ul><hr><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具:"></a>其他工具:</h2><ul><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴 Tampermonkey</a>+<a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">脚本资源</a></li><li><a href="https://chrome.google.com/webstore/detail/isearch/jmalocgcmlilelcdekhigpadlhfbjpnp" target="_blank" rel="noopener">搜索引擎相关</a></li><li><a href="https://blog.csdn.net/wanwuguicang/article/details/80716178" target="_blank" rel="noopener">chrome插件伴侣</a></li><li><a href="https://pan.baidu.com/s/1XII8zxn5HAAcW2-4dLWGAg" target="_blank" rel="noopener">google学术搜索</a><br><del>这些链接咋不发光啊？？</del></li></ul><hr><p>持续更新……..<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3kxn6swfj31hc0u0wgk.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;项目开发类：&quot;&gt;&lt;a href=&quot;#项目开发类：&quot; class=&quot;headerlink&quot; title=&quot;项目开发类：&quot;&gt;&lt;/a&gt;项目开发类：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xdp-gacl/p
      
    
    </summary>
    
      <category term="tools" scheme="http://xfff.xyz/categories/tools/"/>
    
    
      <category term="tools" scheme="http://xfff.xyz/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>【Error集合】</title>
    <link href="http://xfff.xyz/2018/10/03/%E3%80%90Error%E9%9B%86%E5%90%88%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/03/【Error集合】/</id>
    <published>2018-10-03T09:02:07.000Z</published>
    <updated>2019-02-19T06:53:00.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h2><ul><li><a href="https://www.cnblogs.com/zhaideyou/p/5964509.html" target="_blank" rel="noopener">Struts2配置问题java.lang.ClassNotFoundException:org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</a></li><li><a href="https://blog.csdn.net/li7134600/article/details/78071785" target="_blank" rel="noopener">动态通配符配置Action出错</a>  </li><li><a href="https://blog.csdn.net/T_just_for_tomorrow/article/details/79504049" target="_blank" rel="noopener">动态调用action</a>  </li><li><a href="https://blog.csdn.net/cgy_workman/article/details/40862993" target="_blank" rel="noopener">关于struts2配置struts.devMode问题解释</a>  </li></ul><hr><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li><a href="https://blog.csdn.net/H_anxx/article/details/78983591" target="_blank" rel="noopener">org.springframework.web.context.ContextLoaderListener解决方法</a></li></ul><hr><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ul><li><a href="https://blog.csdn.net/u010504064/article/details/47832721" target="_blank" rel="noopener">关于Hibernate一对多关系加载方式fetch配置</a></li></ul><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><a href="https://zhidao.baidu.com/question/1894863609449400500.html" target="_blank" rel="noopener">JS中字符串与数字进行算术运算eval使用注意</a></li></ul><hr><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li><a href="https://www.cnblogs.com/bsn-huang/p/3933442.html" target="_blank" rel="noopener">githubSSHkey添加</a></li><li><a href="https://www.cnblogs.com/sheldonxu/archive/2012/09/17/2688281.html" target="_blank" rel="noopener">伴随问题</a></li></ul><hr><p>持续更新…….<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3j95uqblj31hc0u0b29.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts2&quot;&gt;&lt;a href=&quot;#Struts2&quot; class=&quot;headerlink&quot; title=&quot;Struts2&quot;&gt;&lt;/a&gt;Struts2&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaideyou/p
      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="errors" scheme="http://xfff.xyz/tags/errors/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】基础结构实现集合</title>
    <link href="http://xfff.xyz/2018/10/03/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/"/>
    <id>http://xfff.xyz/2018/10/03/【数据结构】基础结构实现集合/</id>
    <published>2018-10-03T09:02:07.000Z</published>
    <updated>2019-02-19T06:07:17.956Z</updated>
    
    <content type="html"><![CDATA[<p>一些我早期学数据结构的时候用C++实现的代码。<del>指针在实现上比较方便</del></p><hr><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="(1)栈"></a>(1)栈</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int SElemType;typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStack;int InitStack(LinkStack &amp;top){    top = (StackNode*)malloc(sizeof(StackNode));    if(top!=NULL){        top = NULL;    }    return OK;}int Push(LinkStack &amp;top,SElemType e){    LinkStack p =(StackNode*)malloc(sizeof(StackNode));    p-&gt;data=e;    p-&gt;next=top;    top=p;    return OK;}int CreateStack(LinkStack &amp;top){    int n;    cout &lt;&lt; &quot;输入入栈元素个数:&quot;;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        int m;        cout&lt;&lt;&quot;输入进栈元素:&quot;;        cin&gt;&gt;m;        Push(top,m);    }    return OK;}int Pop(LinkStack &amp;top,SElemType &amp;e){    LinkStack p;    if(top!=NULL){        p=top;        e = top-&gt;data;        top = top-&gt;next;        free(p);    }    else        return ERROR;    return OK;}int GetTop(LinkStack top,SElemType &amp;e){    if(top!=NULL)        e = top-&gt;data;    else        return ERROR;    return OK;}void outStack(LinkStack top){    while(top!=NULL){        cout&lt;&lt;top-&gt;data&lt;&lt;endl;        top=top-&gt;next;    }}int main(){    LinkStack top;    InitStack(top);    CreateStack(top);    outStack(top);    int e;    cout&lt;&lt;&quot;出栈一次;&quot;;    Pop(top,e);    cout&lt;&lt;&quot;出栈元素:&quot;&lt;&lt;e&lt;&lt;endl;    outStack(top);    GetTop(top,e);    cout&lt;&lt;&quot;栈顶元素为:&quot;&lt;&lt;e&lt;&lt;endl;    return 0;}</code></pre><h2 id="2-静态链表"><a href="#2-静态链表" class="headerlink" title="(2)静态链表"></a>(2)静态链表</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 1000#define OK 1#define ERROR 0#define FALSE 0#define TRUE 1typedef int status;typedef struct{    status data;    int cur;}component,    SLinkList[MAXSIZE];//初始化status InitList(SLinkList space){    int i;    for(i=0;i&lt;MAXSIZE-1;i++)        space[i].cur = i+1;    space[MAXSIZE-1].cur=0;    return OK;}//若备用空间链表非空，返回分配的结点下标int Malloc_SLL(SLinkList space){    int i = space[0].cur;    if(space[0].cur)        space[0].cur = space[i].cur;    return i;}int ListLength(SLinkList sl){    int j=0;    int i=sl[MAXSIZE-1].cur;    while(i){        i=sl[i].cur;        j++;    }    return j;}//插入status ListInsert(SLinkList L,int i,status e){    int j,k,l;    k=MAXSIZE-1;    if(i&lt;1||i&gt;ListLength(L)+1)        return ERROR;    j=Malloc_SLL(L);    if(j){        L[j].data=e;        for(l=1;l&lt;=i-1;l++)            k=L[k].cur;        L[j].cur=L[k].cur;        L[k].cur=j;        return OK;    }    return ERROR;}//回收空闲结点void Free_SSL(SLinkList space,int k){    space[k].cur=space[0].cur;    space[0].cur=k;}//删除status ListDelete(SLinkList L,int i){    int j,k;    if(i&lt;1||i&gt;ListLength(L))        return ERROR;    k = MAXSIZE-1;    for(j=1;j&lt;=i-1;j++)        k=L[k].cur;    j=L[k].cur;    L[k].cur=L[j].cur;    Free_SSL(L,j);    return OK;}int main(){    return 0;}</code></pre><p>(3)链式存储结构表及表间操作</p><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;using namespace std;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef struct LNode{    Status data;    struct LNode *next;                }LNode ,*LinkList;Status InitList(LinkList &amp;L){    L = (LNode*)malloc(sizeof(LNode));    if(L == NULL)        return ERROR;    L-&gt;next=NULL;    return OK;}Status GetElem(LinkList L,int i,Status *e){    int j;    LinkList p;    p = L-&gt;next;    j = 1;    while(p&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    *e = p-&gt;data;    return OK;}Status ListInsert(LinkList &amp;L,int i,Status e){    int j;    LinkList p,s;    p = L;    j=1;    while( p &amp;&amp; j&lt;i ){        p=p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    s =(LinkList)malloc(sizeof(LNode));    s-&gt;data = e;    s-&gt;next = p-&gt;next;    p-&gt;next = s;      return OK;}Status ListDelete(LinkList &amp;L,int i,Status *e){    int j;    LinkList p,q;    p = L;    j = 1;    while(p-&gt;next&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!(p-&gt;next)||j&gt;i)        return ERROR;    q=p-&gt;next;    p-&gt;next=q-&gt;next;    *e = q-&gt;data;    free(q);    return OK;}void CreateList(LinkList &amp;L,int n){    LinkList p ;    int i;    srand(time(0));    L-&gt;next=NULL;    for(i=0;i&lt;n;i++){        p=(LinkList) malloc(sizeof(LNode));        p-&gt;data=rand()%100+1;        p-&gt;next=L-&gt;next;        L-&gt;next = p;    }}Status ClearList(LinkList &amp;L){    LinkList p,q;    p=L-&gt;next;    while(p){        q=p-&gt;next;        free(p);        p=q;    }    L-&gt;next=NULL;    return OK;}void unionList(LinkList &amp;L,LinkList L1){    LinkList p;    p=L;    L=p;    while(p-&gt;next){        p = p-&gt;next;    }    p-&gt;next=L1-&gt;next;}void outList(LinkList L){    L=L-&gt;next;    while(L!=NULL){        cout&lt;&lt;L-&gt;data&lt;&lt;&quot; &quot;;        L=L-&gt;next;    }    cout&lt;&lt;endl;}int main(){    LinkList p;    InitList(p);    CreateList(p,4);    outList(p);    cout &lt;&lt; &quot;请输入插入元素位置：&quot;;    int i;    cin&gt;&gt;i;    cout&lt;&lt;&quot;请输入插入元素:&quot;;    int e;    cin&gt;&gt;e;    ListInsert(p,i,e);    outList(p);    cout&lt;&lt;&quot;请输入删除元素位置:&quot;;    int j;    int num;    cin&gt;&gt;j;    ListDelete(p,j,&amp;num);    outList(p);    cout&lt;&lt;&quot;删除元素为:&quot;&lt;&lt;num&lt;&lt;endl;    cout &lt;&lt; &quot;表2:&quot;;    LinkList p1;    InitList(p1);    CreateList(p1,7);    outList(p1);    cout &lt;&lt; &quot;合并得:&quot;&lt;&lt;endl;    unionList(p,p1);    outList(p);    return 0;}</code></pre><h2 id="4-堆实现字符串"><a href="#4-堆实现字符串" class="headerlink" title="(4)堆实现字符串"></a>(4)堆实现字符串</h2><pre><code>//字符串的堆分配表示与实现#include&lt;iostream&gt;using namespace std;#define MAXISIZE 100#define ERROR 0#define OK 1typedef struct string {    char *str;    int length;}HeapString;//初始化串int initString(HeapString &amp;pH){    pH.str =&apos;\0&apos;;    pH.length = 0;    return OK;}//给指定的字符串赋值int strAssign(HeapString &amp;pH,char cstr[]){    int i;    int len;    if(pH.str)        free(pH.str);    for( i = 0;cstr[i]!=&apos;\0&apos;;i++);        len = i;    if(!cstr)    {        pH.length = 0;        pH.str = &apos;\0&apos;;    }    else    {        pH.str = (char * )malloc(len*sizeof(char));        if(!pH.str)        {            return ERROR;        }        for(i = 0;i&lt;len;i++)        {            pH.str[i] = cstr[i];        }        pH.length = len;    }    return OK;}//字符串的插入int strInsert(HeapString &amp;pH,int pos,HeapString S){    int i;    if(pos&lt;1||pos&gt;pH.length+1)        return ERROR;    pH.str = (char *)realloc(pH.str,(pH.length+S.length)*sizeof(char));    if(!pH.str)        return ERROR;    for(i = pH.length-1;i&gt;=pos-1;i--)    {        pH.str[i+S.length] = pH.str[i];    }    for(i = 0;i&lt;S.length;i++)    {        pH.str[i+pos-1]= S.str[i];    }    pH.length = pH.length+ S.length;    return OK;}//字符串的复制int strCopy(HeapString pH,HeapString &amp;T){    int i;    int len = pH.length;    T.str = (char * )malloc(len*sizeof(char));    if(!T.str)    {        return ERROR;    }    for( i = 0;i&lt;pH.length;i++)    {        T.str[i] = pH.str[i];    }    T.length = pH.length;    return OK;}//字符串的输出int outStr(HeapString pH){    int i;    for(i = 0;i&lt;pH.length;i++)    {        cout&lt;&lt;pH.str[i];    }    cout&lt;&lt;endl;    return OK;}int main(){    HeapString pH;    char cstr[MAXISIZE];    initString(pH);    cout&lt;&lt;&quot;请输入一个字符串:&quot;;    gets(cstr);    strAssign(pH,cstr);    cout &lt;&lt; &quot;串1:&quot;;    outStr(pH);    HeapString pH1;    initString(pH1);    strCopy(pH,pH1);    cout &lt;&lt; &quot;串2:&quot;;    outStr(pH1);    int pos;    cout&lt;&lt;&quot;请输入插入位置:&quot;;    cin&gt;&gt;pos;    strInsert(pH,pos,pH1);    cout&lt;&lt;&quot;插入操作后的串1:&quot;;    outStr(pH);    return 0;}</code></pre><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="(5)队列"></a>(5)队列</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define ERROR 0#define OK 1typedef int QElemType;typedef struct QNode{    QElemType data;    struct QNode *next;}QNode,*QueuePtr;typedef struct{    QueuePtr front,rear;}LinkQueue;int InitDL(LinkQueue &amp;Q){    Q.front = Q.rear=(QNode*)malloc(sizeof(QNode));    if(!Q.front)        return ERROR;    Q.front-&gt;next=NULL;    return OK;} int InDL(LinkQueue &amp;Q,QElemType e){    QueuePtr p;    p=(QueuePtr)malloc(sizeof(QNode));    if(!p)        return ERROR;    p-&gt;data=e;    p-&gt;next=NULL;    Q.rear-&gt;next=p;    Q.rear=p;    return OK;}int OutDL(LinkQueue &amp;Q,QElemType &amp;e){    QueuePtr p;    if(Q.front==Q.rear)        return ERROR;    p = Q.front-&gt;next;    e=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)        Q.rear=Q.front;    free(p);    return OK;}int getheadDL(LinkQueue Q,QElemType &amp;e){    e=Q.front-&gt;next-&gt;data;    return OK;}int prinftDL(LinkQueue Q){    QueuePtr p;    p=Q.front-&gt;next;    while(p){        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;  &quot;;        p=p-&gt;next;    }    cout &lt;&lt; endl;    return OK;}int main(){    LinkQueue Q;    InitDL(Q);    int m,n,e;    cout&lt;&lt;&quot;输入进队元素个数:&quot;;    cin&gt;&gt;m;    for(int i=0;i&lt;m;i++){        cout &lt;&lt; &quot;输入入队元素:&quot;;        cin&gt;&gt;n;        InDL(Q,n);    }    prinftDL(Q);    getheadDL(Q,e);    cout &lt;&lt; &quot;队头元素为:&quot;&lt;&lt;e&lt;&lt;endl;    OutDL(Q,e);        cout &lt;&lt; &quot;出队一次，出队元素为:&quot;&lt;&lt;e&lt;&lt;endl;    prinftDL(Q);    return 0;}</code></pre><p>循环队列:</p><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 5#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int QElemType;typedef struct{    QElemType data[MAXSIZE];    int front;    int rear;}SqQueue;//初始化int InitQueue(SqQueue *Q){    Q-&gt;front=0;    Q-&gt;rear=0;    return OK;}//返回长度int QueueLength(SqQueue Q){    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;}//插入元素e到队尾int EnQueue(SqQueue *Q,QElemType e){    if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)        return ERROR;    Q-&gt;data[Q-&gt;rear]=e;    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;    return OK;}//若队列不空，则删除队头元素，用e返回其值int DeQueue(SqQueue *Q,QElemType *e){    if(Q-&gt;front==Q-&gt;rear)        return ERROR;    *e=Q-&gt;data[Q-&gt;front];    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;    return OK;}//输出队列void outQueue(SqQueue Q){    int j = (Q.rear-1+MAXSIZE)%MAXSIZE;    for(int i=0;i&lt;QueueLength(Q);i++){        cout &lt;&lt; (Q.data[j])&lt;&lt;&quot; &quot;;        j=((--j) + MAXSIZE)%MAXSIZE;    }    cout &lt;&lt; endl;}int main(){    SqQueue sq;    InitQueue(&amp;sq);    int a;    int count;    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int i=0;i&lt;count;i++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    int e;    int num;    cout &lt;&lt; &quot;删除元素个数:&quot;;    cin &gt;&gt; num;    for(int n=0;n&lt;num;n++){        DeQueue(&amp;sq,&amp;e);        cout &lt;&lt; &quot;删除元素:&quot;&lt;&lt; e &lt;&lt; endl;            }    outQueue(sq);    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int m=0;m&lt;count;m++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    cout &lt;&lt; &quot;队列长度:&quot; &lt;&lt; QueueLength(sq) &lt;&lt;endl;    return 0;}</code></pre><h2 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="(6)二叉树"></a>(6)二叉树</h2><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;#define TRUE 1#define FALSE 0typedef struct BiTNode{    int data;    struct BiTNode *lchild,*rchild;}BiTNode,*BiTree;int SearchBST(BiTree T,int key,BiTree f,BiTree &amp;p){    if(T==NULL){        p = f;        return FALSE;    }    else if(key == T-&gt;data){        p=T;        return TRUE;    }    else if(key&lt;T-&gt;data)        return SearchBST(T-&gt;lchild,key,T,p);    else         return SearchBST(T-&gt;rchild,key,T,p);}int InsertBST(BiTree &amp;T,int key){    BiTree p,s;    if(!SearchBST(T,key,NULL,p))    {        s = (BiTree)malloc(sizeof(BiTree));        s-&gt;data=key;        s-&gt;lchild=s-&gt;rchild=NULL;        if(!p)            T=s;        else if(key&lt;p-&gt;data)            p-&gt;lchild=s;        else            p-&gt;rchild=s;        return TRUE;    }    else        return FALSE;}int Delete(BiTree *p){    BiTree q,s;    if((*p)-&gt;lchild==NULL&amp;&amp;(*p)-&gt;rchild==NULL)        *p=NULL;    else if((*p)-&gt;rchild==NULL){        q=(*p);        (*p)=(*p)-&gt;lchild;        free(q);    }    else if((*p)-&gt;lchild==NULL){        q=(*p);        (*p)=(*p)-&gt;rchild;        free(q);    }    else{        q=(*p);        s=(*p)-&gt;lchild;        while(s-&gt;rchild!=NULL){            q=s;            s=s-&gt;rchild;        }        (*p)-&gt;data=s-&gt;data;        if(!s-&gt;lchild){            if(q!=(*p))                (q)-&gt;rchild=s-&gt;lchild;            else                (q)-&gt;lchild=s-&gt;lchild;            }        free(s);    }    return TRUE;}int DeleteBST(BiTree *T,int key){    if(!*T)        return FALSE;    else{        if(key==(*T)-&gt;data)            return Delete(T);        else if(key&lt;(*T)-&gt;data)            return DeleteBST(&amp;(*T)-&gt;lchild,key);        else            return DeleteBST(&amp;(*T)-&gt;rchild,key);    }}int CreateBST(BiTree &amp;T){    int n;    cout &lt;&lt; &quot;输入树的结点个数:&quot;;    cin&gt;&gt;n;    T=NULL;    for(int i=0;i&lt;n;i++){        int m;        cout &lt;&lt; &quot;输入元素:&quot;;        cin&gt;&gt;m;        InsertBST(T,m);    }    return TRUE;}int main(){    BiTree T;    CreateBST(T);    BiTree f=NULL;    BiTree    p;    int key;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key;    if(SearchBST(T,key,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    int key1;    cout&lt;&lt;&quot;请输入删除元素:&quot;;    cin&gt;&gt;key1;    DeleteBST(&amp;T,key1);    int key2;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key2;    if(SearchBST(T,key2,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="7-图"><a href="#7-图" class="headerlink" title="(7)图"></a>(7)图</h2><pre><code>#include&lt;iostream&gt;#include &quot;DL.h&quot;using namespace std;#define ERROR 0#define OK 1#define MAXVEX 100#define INFINITY 65535typedef int Boolean;Boolean visited[MAXVEX];typedef char VertexType;typedef int EdgeType;//邻接矩阵typedef struct{    VertexType vexs[MAXVEX];    EdgeType arc[MAXVEX][MAXVEX];    int numVertexes,numEdges;}MGraph;void CreateMGraph(MGraph *G){    int i,j,k,w;    cout&lt;&lt;&quot;输入顶点数和边数:\n&quot;;    cin&gt;&gt;G-&gt;numVertexes;    cin&gt;&gt;G-&gt;numEdges;    for(i=0;i&lt;G-&gt;numVertexes;i++){        cout &lt;&lt; &quot;输入顶点:&quot;;        cin&gt;&gt;G-&gt;vexs[i];    }    for(i=0;i&lt;G-&gt;numVertexes;i++){        for(j=0;j&lt;G-&gt;numVertexes;j++){            G-&gt;arc[i][j]=INFINITY;        }    }    for(k=0;k&lt;G-&gt;numEdges;k++){        cout&lt;&lt;&quot;输入边（vi,vj）上的下标i，下标j和权w:&quot;&lt;&lt;endl;        cin&gt;&gt;i;        cin&gt;&gt;j;        cin&gt;&gt;w;        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}//深度优先void DFS(MGraph G,int i){    int j;    visited[i]=1;    cout&lt;&lt;G.vexs[i];    for(j=0;j&lt;G.numVertexes;j++)        if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j])            DFS(G,j);}void DFSTraverse(MGraph G){    int i;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    for(i=0;i&lt;G.numVertexes;i++)        if(!visited[i])            DFS(G,i);}//广度遍历void BFSTraverse(MGraph G){    int i,j;    LinkQueue Q;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    InitDL(Q);    for(i=0;i&lt;G.numVertexes;i++){        if(!visited[i]){            visited[i]=1;            cout&lt;&lt;G.vexs[i];            InDL(Q,i);            while(!DLEmpty(Q)){                OutDL(Q,i);                for(j=0;j&lt;G.numVertexes;j++){                    if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j]){                        visited[j]=1;                        cout &lt;&lt;G.vexs[j];                        OutDL(Q,j);                    }                }            }        }    }}//普里姆算法void MiniSpanTree_Prim(MGraph G){    int min,i,j,k;    int adjvex[MAXVEX];    int lowcost[MAXVEX];    lowcost[0]=0;    adjvex[0]=0;    for(i=1;i&lt;G.numVertexes;i++){        lowcost[i]=G.arc[0][i];        adjvex[i]=0;    }    for(i=1;i&lt;G.numVertexes;i++){        min = INFINITY;        j=1;        k=0;        while(j&lt;G.numVertexes){            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min){                min = lowcost[j];                k=j;            }            j++;        }        cout&lt;&lt;&quot;(&quot;&lt;&lt;adjvex[k]&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;)&quot;;        lowcost[k]=0;        for(j=1;j&lt;G.numVertexes;j++){            if(lowcost[j]!=0&amp;&amp;G.arc[k][j]&lt;lowcost[j]){                lowcost[j]=G.arc[k][j];                adjvex[j]=k;            }        }    }}int main(){    MGraph G;    CreateMGraph(&amp;G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;深度遍历&quot;&lt;&lt;endl;    DFSTraverse(G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;广度遍历&quot;&lt;&lt;endl;    BFSTraverse(G);     cout &lt;&lt; endl;    MiniSpanTree_Prim(G);    return 0;}</code></pre><hr><p>这些结构里也包含它们对应的遍历、插入、删除算法（<del>有些还未经优化</del>）….<br>当然这里还漏了很多基本结构类型，之后再补吧。<br>….</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些我早期学数据结构的时候用C++实现的代码。&lt;del&gt;指针在实现上比较方便&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;(1)栈&quot;&gt;&lt;/a&gt;(1)栈&lt;/h2&gt;&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>win10使用hexo搭建blog</title>
    <link href="http://xfff.xyz/2018/09/10/win10%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/"/>
    <id>http://xfff.xyz/2018/09/10/win10使用hexo搭建blog/</id>
    <published>2018-09-10T09:02:07.000Z</published>
    <updated>2019-02-19T06:11:32.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习搭建ing…"><a href="#练习搭建ing…" class="headerlink" title="练习搭建ing….."></a>练习搭建ing…..</h2><p><strong>从下列各个站点<del>边看边搭</del>…</strong></p><ul><li><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">[用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！]</a></li><li><p><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">[hexo边搭边记]</a></p><p>最後根目録下面的_config.yml文件里的deploy的type一定要設置為git~~~<br>這個問題是真磨人。。。</p></li></ul><hr><p> 模版TKL来源…</p><ul><li><p><a href="https://github.com/SuperKieran/TKL" target="_blank" rel="noopener">[TKL]</a></p></li><li><p><a href="https://github.com/SuperKieran/hexo-generator-search-zip" target="_blank" rel="noopener">[hexo搜索工具]</a></p></li></ul><hr><p><strong>模版很好看，感谢作者~</strong></p><p><del>其实这篇文章只是为了试试能不能同步到github主页hhh</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;练习搭建ing…&quot;&gt;&lt;a href=&quot;#练习搭建ing…&quot; class=&quot;headerlink&quot; title=&quot;练习搭建ing…..&quot;&gt;&lt;/a&gt;练习搭建ing…..&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;从下列各个站点&lt;del&gt;边看边搭&lt;/del&gt;…&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="hexo主题" scheme="http://xfff.xyz/categories/hexo%E4%B8%BB%E9%A2%98/"/>
    
    
      <category term="hexo" scheme="http://xfff.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xfff.xyz/2018/08/03/hello-world/"/>
    <id>http://xfff.xyz/2018/08/03/hello-world/</id>
    <published>2018-08-03T09:02:07.000Z</published>
    <updated>2019-02-19T06:10:59.783Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>给亲爱的段启慧💖</title>
    <link href="http://xfff.xyz/2000/03/16/%E7%BB%99%E4%BA%B2%E7%88%B1%E7%9A%84%E6%AE%B5%E5%90%AF%E6%85%A7/"/>
    <id>http://xfff.xyz/2000/03/16/给亲爱的段启慧/</id>
    <published>2000-03-16T12:22:33.000Z</published>
    <updated>2019-03-17T12:14:50.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>请无关人员自行撤离</del></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>亲爱的段启慧：</p><p>&emsp;&emsp;你好！<br>&emsp;&emsp;<del>为了捍卫世界的和平，为了抑制蠢蠢欲动的黑暗领域势力，为了心中对未来的热烈期望，也为了守住人格深处的那一丝真挚和美好，为了自由，为了热血，为了你对我贴心的照顾，为了我无知点燃的导火索</del>，为了爱，我写下此信以表真心。</p><p>先引用一下《圣经》上的句子，偶然看到哒</p><blockquote><p>求你将我放在心上如印记，带在你臂上如戳记；因为爱情如死之坚强，嫉恨如阴间之残忍 （雅歌 8:6）</p></blockquote><p>&emsp;&emsp;刚在一起的那些天，我觉得糊里糊涂的，早晨一醒，好像什么都没发生，可是心里记得好像以后多了个人会去说早安晚安。我是一个敏感的人，同时又是个不爱说话的人，不爱说话是觉得别人不喜欢听我的负能量和疑惑，我讨厌打扰别人，但是心里喜欢倾诉，我会有很多想法。然后你出现了，谢谢你接纳了我，你确实也给我的生活带来了很多色彩，我真的想以后都能有你相伴。</p><p>&emsp;&emsp;你和我不一样，你活泼可爱，温柔大方，你的好多特质是我羡慕不来的。你是一个特别甜的女朋友！很多时候，你给我表达爱意的时候，我觉得这是我从未有过的感觉哈哈哈，感觉到了自内而外的开心，这是我发自内心的想法。其实我也想偶尔表达我对你的爱意，但是总是无疾而终，或者太委婉你误会了哈哈哈，在这方面我真的太差了，嘻嘻嘻。</p><p>&emsp;&emsp;前些天，我们俩第一次打了一通为了聊天的电话（之前还有几通电话不算），我果然在说话方面还是没什么进步，总是找不到合适的话来接你，但是我觉得挺有意思的。你给我说你最近发生的事，不论是玩笑还是负能量满满的想法，听到你有活力的声音我觉得好安心，前一天你赶不上进度的时候虚弱绝望好像要放弃的时候的声音真的吓坏我了。</p><p>&emsp;&emsp;你考国编的这段时间，真的好辛苦，我好心疼。我知道你为了赶上进度深夜背书补习，也能在天还没亮的时候就要起来加紧学习。可是你这么努力，发现还是完全赶不上一些优秀的同学，就会有很大的压力。脑子里会蹦出“我是不是不适合学习”、“我是不是真的笨呀”这种想法。我得郑重告诉你，没有的事好吗！我的小仙女最聪明啦！当然，我也阻止不了你有这种想法，你有这种想法的时候要记得相信自己，那些想法尽快就烟消云散啦。我会尽量在你情绪低落的时候鼓励你。</p><p>&emsp;&emsp;我真的深切明白了一个人的情绪可以和另一个人息息相关，我想你能天天开心，这是我真心的愿望。</p><p>&emsp;&emsp;不知道什么时候开始，我真的特别喜欢你了，现在你在我心里是一个特别重要的位置。我自己能感受到这个变化，你应该不明白叭。</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g15uh0i4wuj30c80c8q48.jpg" alt=""></p><p><br><br></p><p>&emsp;&emsp;我一直说不明白我喜欢什么样子的女孩子，后来看到一句话：“不是我喜欢的样子你都有，而是我喜欢你的所有样子”。我喜欢你偶尔的调皮，常驻的可爱，喜欢你认真学习的决心，喜欢你盛气凌人的严肃，喜欢你难受时的惹人怜爱，喜欢你老为我着想的贴心，喜欢你决定进步的熊熊斗志，喜欢你灵机一动的聪明，喜欢你忘带脑子的呆萌，喜欢你抱怨时候的忿忿不平，喜欢你通透清澈的眼睛，喜欢你的身高、体重、五官与包含无尽宇宙的脑洞，喜欢你和我说的每一句喜欢，喜欢你背书背了一会就背不下去的学渣形态（<del>哈哈哈哈哈哈哈哈哈谁让你在我写这段的时候来和我说背不动书了</del>）。但我不喜欢你不开心，不喜欢你生气，不喜欢你遇到不好的事，我希望能陪你一起做开心的事，不能惹你生气，陪你熬过难熬的时光。</p><p>&emsp;&emsp;在上面，我一共用到了23个喜欢，那么我还想再说一句最重要的</p><hr><p><strong>💚💜🖤我爱你🧡💛💙</strong></p><hr><p><em>一头扎进夜色里，浮潜几个呼吸，要再游多少梦境，才能遇到你。</em></p><p>我可能不够优秀，爱可以提供约束力和动力，我愿意为了你，为了美好生活，约束自己人性恶的一面，或者我们可以互相鞭挞，一起努力，成为更好的自己。</p><p>如今，我已经有了新的习惯。每当我有一些以前不想说的话，就会跑来找你倾诉。我也并不是把你当成树洞，有些时候我觉得太负能量还是会对你隐瞒，因为我不想让你觉得我是一个阴郁的人，我在乎你，我在意你对我的看法，和树洞不同，我更多时候希望得到你的回应。你总能安慰我，给我意想不到的关心，每次我带着不平而来，离你而去的时候就没有这些坏念头了，我带着喜悦而来，离你而去的时候会满载更大的喜悦，我带着难受而来，离开时也能全都烟消云散。你真的是我的神奇宝物，珍惜你是我的天命。</p><p>我其实还是很自私，我都快把你当成我自己的，要是你喜欢别人，我会吃醋，但还是喜欢你。</p><p>我之前喜欢看的一部动漫《钢之炼金术师》，我想给你讲里面的一个概念。<br>在这个动漫里，很多人都喜欢研究一种叫做炼金术的东西，而炼金术的最重要的规则，就是“等价交换”，意思是你拿出等价的材料，经过炼金术师们的操作，可以换出想要的新东西。<br>男主的妈妈病死了，因此为了把妈妈等价交换回来，他和弟弟日夜研究炼金术以及人体组成，最后收集了盐、水、蛋白质等东西准备尝试把妈妈通过炼金术交换回来，而人人都知道“人体炼成”是炼金术的禁忌，至于原因没人知道。<br>兄弟俩画好阵开始了炼金术，然而只炼出来一个黑色的“怪物”，还因为反噬把弟弟的身体和自己的手脚给吞没了。<br><em>很多人以为这是剧情的bug</em><br>直到动漫最后一集，男主对女主说：“我把下半辈子交给你，你把下半辈子交给我。”<br>然后女主回：“你们这些炼金术师啊，整天只知道等价交换，你要是想要，我把一辈子都给你啊。”<br>这时候科普说的很有意思，“对于动漫中处处遵循等价交换的原则却在炼成母亲时出错，是因为，爱是不遵循等价交换的”</p><p>哈哈哈哈哈感觉说起来有点中二，我也不知道为什么要谈到这个，就是想和你说。</p><p>我愿意把我最好的部分献给你（差的部分你要也给哈哈哈）</p><p>最后，<br><strong>余生请多指教，爱你</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><br></h2><div style="text-align: right"> <b>徐锋</b> </div><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g15yg2xw2wj30dw099q7a.jpg" alt=""></p><p><em>能问一句，那个你要说一世情话的能是我吗hhh？</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;del&gt;请无关人员自行撤离&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>dearDQH</title>
    <link href="http://xfff.xyz/1998/02/19/%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%A5%B3%E6%9C%8B%E5%8F%8B/"/>
    <id>http://xfff.xyz/1998/02/19/女朋友女朋友女朋友女朋友/</id>
    <published>1998-02-19T09:46:01.000Z</published>
    <updated>2019-03-20T02:40:28.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="balabala"><a href="#balabala" class="headerlink" title="balabala"></a>balabala</h1><p>大家好，今天是一个特别的日子</p><p>就在今天，我的女朋友出生了</p><p>哈哈哈哈哈哈哈哈</p><p>下面就是她</p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1g0wovwv98nj30u014015h.jpg" alt=""></p><p>溜了溜了，应该没人没事翻我博客叭哈哈哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;balabala&quot;&gt;&lt;a href=&quot;#balabala&quot; class=&quot;headerlink&quot; title=&quot;balabala&quot;&gt;&lt;/a&gt;balabala&lt;/h1&gt;&lt;p&gt;大家好，今天是一个特别的日子&lt;/p&gt;
&lt;p&gt;就在今天，我的女朋友出生了&lt;/p&gt;
&lt;p&gt;哈哈哈
      
    
    </summary>
    
      <category term="杂记" scheme="http://xfff.xyz/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
