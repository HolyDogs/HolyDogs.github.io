<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XFF&#39;s blog</title>
  
  <subtitle>BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xfff.xyz/"/>
  <updated>2018-10-19T17:25:54.902Z</updated>
  <id>http://xfff.xyz/</id>
  
  <author>
    <name>Xu Feng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【ssm】ssm整合配置</title>
    <link href="http://xfff.xyz/2018/10/19/%E3%80%90ssm%E3%80%91ssm%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"/>
    <id>http://xfff.xyz/2018/10/19/【ssm】ssm整合配置/</id>
    <published>2018-10-19T09:46:56.000Z</published>
    <updated>2018-10-19T17:25:54.902Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>导入所有需要的包（添加maven依赖）:</strong></li></ul><pre><code>&lt;dependencies&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.mybatis&lt;/groupId&gt;         &lt;artifactId&gt;mybatis&lt;/artifactId&gt;         &lt;version&gt;3.4.5&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;         &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-context&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-core&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-web&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;org.springframework&lt;/groupId&gt;         &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;         &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;         &lt;version&gt;3.1.0&lt;/version&gt;     &lt;/dependency&gt;     &lt;dependency&gt;         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;         &lt;artifactId&gt;jstl&lt;/artifactId&gt;         &lt;version&gt;1.2&lt;/version&gt;     &lt;/dependency&gt;           &lt;dependency&gt;         &lt;groupId&gt;junit&lt;/groupId&gt;         &lt;artifactId&gt;junit&lt;/artifactId&gt;         &lt;version&gt;4.12&lt;/version&gt;         &lt;type&gt;pom.lastUpdated&lt;/type&gt;     &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;        &lt;version&gt;3.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-logging&lt;/groupId&gt;        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;        &lt;type&gt;pom.lastUpdated&lt;/type&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-compress&lt;/artifactId&gt;        &lt;version&gt;1.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;/groupId&gt;        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;8.0.11&lt;/version&gt;      &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.mchange&lt;/groupId&gt;          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;          &lt;version&gt;0.9.5.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;aopalliance&lt;/groupId&gt;          &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;          &lt;version&gt;1.0&lt;/version&gt;          &lt;type&gt;pom.lastUpdated&lt;/type&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;</code></pre><hr><ul><li><strong>配置spring</strong></li></ul><p>为dao、service、transaction等层分别创建配置文件，方便管理。<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe0l9i9lnj3080055wei.jpg" alt=""></p><p><strong>applicationContext-dao.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.me.mapper&quot; /&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-service.xml：</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;context:component-scan base-package=&quot;com.me.service&quot; /&gt;&lt;/beans&gt;</code></pre><p><strong>applicationContext-trans.xml</strong>：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.3.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.3.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;&lt;!-- 配置事务 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- 切面aop&lt;aop:config&gt;    &lt;aop:pointcut expression=&quot;execution(* com.me.entity.TestClass.*(..))&quot; id=&quot;pointcut1&quot;/&gt;    &lt;aop:aspect ref=&quot;incretestclass&quot;&gt;        &lt;aop:before method=&quot;inc&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;        &lt;aop:after method=&quot;afterturning&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt; --&gt;&lt;/beans&gt;</code></pre><hr><ul><li><p><strong>数据库配置文件</strong><br><strong>db.properties</strong></p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://localhost\:3306/photo?characterEncoding\=utf-8jdbc.username=rootjdbc.password=olonn</code></pre></li></ul><hr><p>##mybatis</p><ul><li><strong>SqlMapConfig.xml</strong></li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><hr><h2 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;       &lt;!-- 配置扫描的包 --&gt;       &lt;context:component-scan base-package=&quot;com.me.controller&quot; /&gt;       &lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;       &lt;mvc:annotation-driven /&gt;        &lt;!--访问静态资源 --&gt;       &lt;mvc:default-servlet-handler /&gt;       &lt;!-- 视图解析器 --&gt;       &lt;bean           class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;           &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;           &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><hr><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;filter&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;      &lt;filter-name&gt;encoding&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:springmvc/springmvc.xml&lt;/param-value&gt;      &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;      &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><hr><p>可使用逆向工程生成对应数据库下的pojo类和mapper配置文件及接口，复制到对应的包下。</p><hr><hr><h2 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h2><p>创建一个service类</p><pre><code>package com.me.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.me.mapper.UserMapper;import com.me.pojo.User;@Servicepublic class UserService {    @Autowired    private UserMapper userMapper;    public User selectUser(int i) {        return userMapper.selectByPrimaryKey(i);    }}</code></pre><p>创建一个controller</p><pre><code>package com.me.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.me.service.UserService;@Controllerpublic class LoginController {    @Autowired    private UserService uService;    @RequestMapping(value=&quot;/login&quot;)    public ModelAndView login() {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;/login&quot;);        modelAndView.addObject(&quot;user&quot;, uService.selectUser(101));        return modelAndView;    }}</code></pre><p>view目录下创建一个login.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    hahaha+${user.name}&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwe14h61gsj30m906tdg9.jpg" alt=""></p><hr><ul><li><strong>配置中遇到的异常和错误</strong><blockquote><p><a href="https://blog.csdn.net/u014805893/article/details/52016570" target="_blank" rel="noopener">通配符的匹配很全面, 但无法找到元素 ‘context:property-placeholder’ 的声明</a><br><a href="https://blog.csdn.net/eacter/article/details/44624505" target="_blank" rel="noopener">关于spring”通配符的匹配很全面, 但无法找到元素 ‘context:component-scan’ 的声明“的错误</a></p></blockquote></li></ul><p>其实都是spring配置中的schema配置错误，当缺少哪条时就应该补上对应的xsd文件，具体可以在org.springframework.context.config包下找到，但添加内容并不在这里面，如缺少context的xsd，就加</p><pre><code>http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.3.xsd</code></pre><p>配对存在，第二条后面加上具体内容和版本（导入什么包，就加写什么版本）。</p><hr><p>ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入所有需要的包（添加maven依赖）:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;or
      
    
    </summary>
    
      <category term="ssm" scheme="http://xfff.xyz/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="spring" scheme="http://xfff.xyz/tags/spring/"/>
    
      <category term="ssm" scheme="http://xfff.xyz/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】注解开发的详细使用</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】注解开发的详细使用/</id>
    <published>2018-10-18T07:17:03.000Z</published>
    <updated>2018-10-18T09:59:43.545Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先，所有注解都要提前在配置文件中开启扫描。</strong><br><strong>&lt; context:component-scan base-package = “” /&gt;</strong><br>\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a> //指定扫描的路径<br>\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a> //排除扫描的路径</p><p>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:include-filter type=”regex” expression=”.controller.<em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.service.</em>“/&gt;<br>        &lt;context:include-filter type=”regex” expression=”.dao.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>=<br>&lt;context:component-scan base-package=”com.tan” &gt;<br>        &lt;context:exclude-filter type=”regex” expression=”.model.*”/&gt;<br>&lt;/context:component-scan&gt;</p><p>无论哪种情况\<a href="context:include-filter" target="_blank" rel="noopener">context:include-filter</a>和\<a href="context:exclude-filter" target="_blank" rel="noopener">context:exclude-filter</a>都不能同时存在</p><hr><p><strong>@Controller</strong><br>注册一个bean到spring，标记一个类为controller，这样才能被外界访问到</p><p><strong>@RequestMapping(“/xxx”)</strong><br>注册xxx请求绑定注解下面的类或方法.<br>该注解一共有六个属性，分别为value、method、consumes、produces、 params、headers。<br><strong>value</strong>：指定请求的实际地址，指定的地址可以是URI Template 模式，即请求的URI中可以包含变量，如<br>/test/{variable}/log.jsp,当请求/test/haha/log.jsp时，variable1对应为’haha’，配合@PathVariable使用。<br>另外，该注解还支持通配符</p><p><strong>method</strong>：指定请求的method类型， GET、POST、PUT、DELETE等</p><pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })public String testMethod() {        return &quot;method&quot; ;    }</code></pre><p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法</p><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html<br><strong>produces</strong>：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回<br><strong>params</strong>：指定request中必须包含某些参数值时，才让该方法处理</p><pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })public String testParams() {       System. out .println( &quot;test Params...........&quot; ); return &quot;testParams&quot; ;    }</code></pre><p>上面代码表面当/aa.action?后面有param1=value&amp;param2={something}且无param3时才能成功访问下面的方法</p><p><strong>headers</strong>：指定request中必须包含某些指定的header值，才能让该方法处理请求<br>与params类似</p><pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; }) public String testHeaders() {         return &quot;headers&quot; ;    }</code></pre><p>在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法</p><hr><p><strong>@Resource和@Autowired</strong><br>两者都用来注入bean，@Resource其实并不是spring的注解，仔细看import部分可以看到是javax.annotation.*下的包。<br>共同点：可以写在bean的声明或者setter方法上，如果写在字段上，就不用写setter方法。<br>不同点：<br>@Autowired是按照类型装配对象，默认要求依赖对象必须存在，如果允许存在，设置required属性为false。按名称装配时要加@Qualifier(“xxx”)<br>@Resource默认按名称装配，需要配置name属性@Resource(name=”xxx”)，也可以设置type属性来按类型装配。</p><hr><p><strong>attribute类型{</strong><br><strong>@ModelAttribute</strong><br>代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p><pre><code>@ModelAttribute ( &quot;hello&quot; ) public String getModel() {      System. out .println( &quot;-------------Hello---------&quot; );      return &quot;world&quot; ;   }</code></pre><p>上面代码会在访问方法执行前执行，打印，并把字符串”world”存入model对象中，对应关键字为”hello”<br>也可以在另外的方法参数前加上@ModelAttribute(“xxx”)即可把model里的xxx值映射到这个参数里</p><p><strong>@SessionAttributes</strong><br>将值放到session作用域中，写在class上面。</p><pre><code>@SessionAttributes(value={&quot;name&quot;,&quot;theid&quot;},type={User.class})public class MyController{    //xxxxxx....}</code></pre><p>上面的代码指定了遇到属性name或者theid或者User类型使用modelattribute注解存放的时候，都会存放到session对象里。当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称<br><strong>}</strong></p><hr><p><strong>request uri部分</strong>(variable/)<br><strong>@PathVariable</strong><br>用来将URL中的变量映射到方法的参数里</p><pre><code>@RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET) public String getLogin(@PathVariable(&quot;userId&quot;) String userId,      @PathVariable(&quot;roleId&quot;) String roleId){      System.out.println(&quot;User Id : &quot; + userId);      System.out.println(&quot;Role Id : &quot; + roleId); return &quot;hello&quot;;  }</code></pre><hr><p><strong>request body**</strong>部分{<strong></strong>@RequestParam**<br>主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型</p><pre><code>public String setupForm(@RequestParam(&quot;petId&quot;) int petId, ModelMap model) {      //xxx  }    </code></pre><p><strong>@ResponseBody</strong><br>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><pre><code>@RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT) public void handle(@RequestBody String body, Writer writer) throws IOException {    writer.write(body);  }</code></pre><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；<br><strong>}</strong></p><hr><p><strong>request header部分{</strong><br><strong>@RequestHeader</strong></p><pre><code>public  void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,@RequestHeader(&quot;Keep-Alive&quot;)   long  keepAlive) {}</code></pre><p>这段代码把request header部分的Accept-Encoding和Keep-Alive值映射到对应的参数里。</p><p><strong>@CookieValue</strong></p><pre><code>@RequestMapping(&quot;/displayHeaderInfo.do&quot;) public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {  }</code></pre><p>上面代码把cookie里的JSESSIONID值映射到对应的参数里。</p><p><strong>}</strong></p><hr><p>@Component<br>通用的注解，当不知道一个类归于哪层时，使用。不推荐使用。</p><p>@Repository<br>注解dao层，在daoImpl类上注解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;首先，所有注解都要提前在配置文件中开启扫描。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&amp;lt; context:component-scan base-package = “” /&amp;gt;&lt;/strong&gt;&lt;br&gt;\&lt;a href=&quot;context:incl
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="注解" scheme="http://xfff.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】配置和使用(二)</title>
    <link href="http://xfff.xyz/2018/10/18/%E3%80%90springmvc%E3%80%91%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-%E4%BA%8C/"/>
    <id>http://xfff.xyz/2018/10/18/【springmvc】配置和使用-二/</id>
    <published>2018-10-18T03:38:00.000Z</published>
    <updated>2018-10-18T07:06:10.242Z</updated>
    
    <content type="html"><![CDATA[<p>根据前面描述的工作流程，现在来对springmvc进行配置。</p><ul><li>首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。</li></ul><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;3.1.0&lt;/version&gt;  &lt;/dependency&gt;</code></pre><hr><ul><li><p>创建springmvc的配置文件springmvc.xml (<del>可以任意，最好规范</del>)</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans          http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context          http://www.springframework.org/schema/context/spring-context.xsd          http://www.springframework.org/schema/tx                  http://www.springframework.org/schema/tx/spring-tx.xsd         http://www.springframework.org/schema/mvc           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;/beans&gt;</code></pre></li></ul><hr><ul><li><p>在web.xml中配置前端控制器。</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li></ul><p>注意param-value中的路径无误，<br>在url-pattern中有两种配置方式：<br>第一种:  *.action  ,访问以.action结尾，由DispatcherServlet进行解析<br><strong>第二种:  \/  ,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方式实现RESTful风格的url</strong></p><p> 错误配置:  \/*  ,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错404</p><hr><ul><li><p>配置处理器映射器</p><pre><code>&lt;bean  class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;</code></pre></li></ul><ul><li><p>配置处理器适配器</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;</code></pre></li><li><p><strong>注解方式配置</strong></p><pre><code>&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;&lt;mvc:annotation-driven /&gt;</code></pre></li></ul><hr><ul><li>配置处理器Handler(controller)</li></ul><pre><code>&lt;bean  name=&quot;/xxx.action&quot;  class=&quot;com.iot.ssm.controller.xxx&quot;/&gt;</code></pre><ul><li><p><strong>注解批量扫描法</strong></p><pre><code>&lt;!-- 配置扫描的包 --&gt;&lt;context:component-scan base-package=&quot;com.springdemo.*&quot; /&gt;</code></pre></li></ul><hr><ul><li><p><strong>配置视图解析器</strong></p><pre><code>&lt;!-- 视图解析器 --&gt;&lt;bean    class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><p>property中prefix对应要查找的目录，suffix对应自动添加的后缀</p><hr><hr><p>测试：</p><p>controller:</p><pre><code>package com.springdemo.controller;import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.swing.text.View;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.springdemo.domain.User;@Controller@RequestMapping(&quot;/demo&quot;)public class TestController implements org.springframework.web.servlet.mvc.Controller{    @RequestMapping(&quot;/demo&quot;)    public String index() {        return &quot;index&quot;;    }    @Override    @RequestMapping(&quot;/test&quot;)    public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception {        Map&lt;String, Object&gt; map=new HashMap&lt;String, Object&gt;();         User user=new User();        user.setName(&quot;梁非凡&quot;);        user.setId(&quot;123&quot;);        map.put(&quot;user&quot;, user);        String str=&quot;刘醒&quot;;        map.put(&quot;str&quot;, str);        ModelAndView modelAndView=new ModelAndView();        modelAndView.addAllObjects(map);        modelAndView.setViewName(&quot;test&quot;);        return modelAndView;    }}</code></pre><p>test.jsp :</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;    pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;${user.name}Hbbbbbbbbb&lt;/body&gt;&lt;/html&gt;</code></pre><p>配置到tomcat上，启动tomcat，打开浏览器，输入地址<br><a href="http://localhost:8888/SpringMVCTest/demo/test" target="_blank" rel="noopener">http://localhost:8888/SpringMVCTest/demo/test</a></p><p>得到：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwce2yvwflj311n0a7aan.jpg" alt=""></p><p>成功…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据前面描述的工作流程，现在来对springmvc进行配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先导入springmvc需要的jar包，这里我使用的是maven管理，添加相应依赖就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
     
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
      <category term="springmvc配置" scheme="http://xfff.xyz/tags/springmvc%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】与spring整合</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E4%B8%8Espring%E6%95%B4%E5%90%88/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】与spring整合/</id>
    <published>2018-10-16T15:36:19.445Z</published>
    <updated>2018-10-17T15:34:32.313Z</updated>
    
    <content type="html"><![CDATA[<p><em>只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。</em></p><hr><p>导入相应的整合包后，首先将数据库的配置交给spring配置：</p><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context-3.2.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;    &lt;!-- 数据源，使用dbcp --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;          destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- sqlSessinFactory --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 加载mybatis的配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot; /&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>使用mapper代理开发时，在spring容器中配置mapper的接口生成代理对象：</p><pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;        //mapperInterface指定mapper接口        &lt;property name=&quot;mapperInterface&quot; value=&quot;com.iot.ssm.mapper.UserMapper&quot;/&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><p>通过MapperScannerConfigurer进行mapper扫描可以实现批量配置：</p><pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;!-- 指定扫描的包名    如果扫描多个包，每个包中间使用半角逗号分隔    --&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.ssm.mapper&quot;/&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;</code></pre><hr><p>这样，要使用mapper时，只需要通过注解的方式：</p><pre><code>@Autowiredprivate UserMapper userMapper;</code></pre><p>或加载spring配置文件的方式（Test方法里使用）:</p><pre><code>private ApplicationContext applicationContext;applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);UserMapper userMapper = (UserMapper)applicationContext.getBean(&quot;userMapper&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;只使用mybatis时，我们发现每次使用mapper接口操作数据都很麻烦，并且程序耦合度高，为了解决这个问题，可以使用spring框架与mybatis框架进行整合。将一些需要的对象交给spring容器来配置和创建。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;导入相应的整合包
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】逆向工程及详解</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】逆向工程及详解/</id>
    <published>2018-10-16T13:35:53.952Z</published>
    <updated>2018-10-17T15:49:13.171Z</updated>
    
    <content type="html"><![CDATA[<p>逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理<a href="https://baike.baidu.com/item/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/5097433?fr=aladdin" target="_blank" rel="noopener">^1</a>。</p><hr><ol><li><p>最好先创建一个新的空项目</p></li><li><p>引入Maven依赖</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwaecl9jgvj308w038dfr.jpg" alt=""></p><ol start="3"><li>创建逆向工程配置文件</li><li><p>文件配置内容</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;            connectionURL=&quot;jdbc:mysql://localhost:3306/mybatist&quot;             userId=&quot;root&quot;            password=&quot;olonn&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot;            connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot;             userId=&quot;yycg&quot;            password=&quot;yycg&quot;&gt;        &lt;/jdbcConnection&gt; --&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和             NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- targetProject:生成PO类的位置 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.me&quot;            targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- targetProject:mapper映射文件生成的位置 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- targetPackage：mapper接口生成的位置 --&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;            targetPackage=&quot;com.mapper&quot;             targetProject=&quot;.\src&quot;&gt;            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表 --&gt;        &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;buser&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;bcard&quot;&gt;&lt;/table&gt;        &lt;table tableName=&quot;ctou&quot;&gt;&lt;/table&gt;        &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt;        &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt;        &lt;!-- 有些表的字段需要指定java类型         &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt;            &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt;        &lt;/table&gt; --&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>创建一个类用来运行生成文件</p><pre><code>package com.mapper;import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class Zzz {    public void generate() throws Exception {        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        boolean overwrite = true;        File configFile = new File(&quot;src/main/resources/GeneratorConfig.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);        myBatisGenerator.generate(null);    }    public static void main(String[] args) throws Exception {        try {            Zzz zzz=new Zzz();            zzz.generate();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre></li></ol><p>注意配置文件的目录，相对根路径是从项目根目录开始的。运行即可。</p><p>运行完刷新目录，见：<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwael724nzj306s0av0sx.jpg" alt=""></p><p>我们就得到了想要的Mapper接口、配置文件和pojo类。</p><hr><hr><p>select主要通过criteria对象<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafj73fpkj30ds02jdfu.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwafimt96uj305n06hglo.jpg" alt=""></p><hr><p>总的来说，还是非常方便的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
      <category term="逆向工程" scheme="http://xfff.xyz/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(三)</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%89/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】学习总结-三/</id>
    <published>2018-10-16T07:32:59.850Z</published>
    <updated>2018-10-17T15:36:32.912Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查询的语句，然后在之后才对这个数据进行使用（比如输出），那么在输出的时候，数据库才会真正去运行这条语句返回查询的对象。</p><p>开启延迟加载的方式：</p><ul><li><strong>使用association实现延迟加载</strong></li></ul><p>在association标签里加入select和column属性，select指向查询关联数据的方法，column指向在主表中关联的列（外键那列）。</p><ul><li><p><strong>在全局配置文件中配置</strong></p><pre><code>&lt;settings&gt;    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre></li></ul><p>settings标签配置在property下面，typeAlias上面。</p><table><thead><tr><th style="text-align:left">延迟加载开关</th><th style="text-align:left">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</th><th style="text-align:right">lazyLoadingEnabled</th><th style="text-align:center">默认为false</th></tr></thead><tbody><tr><td style="text-align:left">消极加载</td><td style="text-align:left">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td><td style="text-align:right">aggressiveLazyLoading</td><td style="text-align:center">默认为true</td></tr><tr><td style="text-align:left">二级缓存</td><td style="text-align:left"><a href="#a">CLICK</a></td><td style="text-align:right">cacheEnabled</td><td style="text-align:center">默认为false</td></tr></tbody></table><ul><li><strong>一级缓存</strong></li></ul><p>Mybatis默认开启一级缓存，在同一个SqlSession中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则SqlSession的缓存清空。<br>SqlSession关闭也清空，比如一个service调用的结束，会关闭一个sqlsession，则缓存结束。</p><p><span id="a"></span></p><ul><li><strong>二级缓存</strong></li></ul><p>Mybatis需要手动设置启动二级缓存，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存,添加：</p><pre><code>&lt;cache/&gt;</code></pre><p>二级缓存的作用域是同一个namespace下的mapper映射文件内容（HashMap），多个SqlSession共享。<br>在同一个namespace下的mapper文件中，执行相同的查询SQL，第一次会去查询数据库，并写到缓存中；第二次直接从缓存中取。当执行SQL时两次查询中间发生了增删改操作，则二级缓存清空。<br>一个SqlSession关闭不会导致二级缓存清空，如果设置了二级缓存，service重复被调用查询同一条记录，只会一直从二级缓存中查询。</p><p><strong>实现序列化</strong></p><p>由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。</p><p>如果该类存在父类，那么父类也要实现序列化。</p><p><strong>设置禁用二级缓存</strong></p><p>在select中添加属性useCache=”false”默认为true。</p><p><strong>设置刷新二级缓存</strong></p><p>在select中添加属性flushCache=”true”。</p><h2 id="mybatis整合ehcache"><a href="#mybatis整合ehcache" class="headerlink" title="mybatis整合ehcache"></a>mybatis整合ehcache</h2><p>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）。</p><p>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。</p><p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p><ul><li><strong>整合方法：</strong></li></ul><p>整合ehcache所需包：</p><ul><li>ehcache-core-2.6.11.jar</li><li>mybatis-ehcache-1.1.0.jar</li></ul><p>设置mapper配置文件中</p><pre><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</code></pre><p>加入ehcache的配置文件ehcache.xml（classpath下）：</p><pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;    &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt;    &lt;defaultCache         maxElementsInMemory=&quot;1000&quot;         maxElementsOnDisk=&quot;10000000&quot;        eternal=&quot;false&quot;         overflowToDisk=&quot;false&quot;         timeToIdleSeconds=&quot;120&quot;        timeToLiveSeconds=&quot;120&quot;         diskExpiryThreadIntervalSeconds=&quot;120&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;    &lt;/defaultCache&gt;&lt;/ehcache&gt;</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;延迟加载&quot;&gt;&lt;a href=&quot;#延迟加载&quot; class=&quot;headerlink&quot; title=&quot;延迟加载&quot;&gt;&lt;/a&gt;延迟加载&lt;/h2&gt;&lt;p&gt;为了使数据库压力更小，一般对实时性不高的数据采用延迟加载方式。什么叫延迟加载，比如：我们通过mapper接口调用查
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】多对多关系</title>
    <link href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/"/>
    <id>http://xfff.xyz/2018/10/16/【mybatis】多对多关系/</id>
    <published>2018-10-16T06:50:23.956Z</published>
    <updated>2018-10-17T15:37:15.763Z</updated>
    
    <content type="html"><![CDATA[<p><em>关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。</em></p><hr><ul><li><strong>首先，创建表，建立连接关系。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2l7b67ej30ib0e8jrg.jpg" alt=""></li></ul><ul><li><strong>然后，插入示例数据。</strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2mq19o5j30ib0e8q30.jpg" alt=""></li></ul><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2n7k9vwj30ib0e8glp.jpg" alt=""></p><p>打印一下，记录<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fwa2nxp4o4j30ib0kiaa1.jpg" alt=""></p><p>分别为三张表，一张银行用户表，简单起见，只有id和name两列，一张银行卡表，有id和money两列，最后是一张关系维护表，有三列，id、对应用户的buserid、对应卡的bcardid。</p><p>我设定的银行卡为家庭卡，可以多个人用一个账号，一个人可以用多张卡。</p><h2 id="前提准备做完了，开始建立多对多关系映射。"><a href="#前提准备做完了，开始建立多对多关系映射。" class="headerlink" title="前提准备做完了，开始建立多对多关系映射。"></a>前提准备做完了，开始建立多对多关系映射。</h2><ol><li>创建用户和卡的表对应的实体类，并设置对应的映射属性，分别加入一个list\<t>属性。如下：</t></li></ol><pre><code>package com.test.domain;import java.util.List;public class Buser {    private int id;    private String name;    private List&lt;Bcard&gt; bcards;    public List&lt;Bcard&gt; getBcards() {        return bcards;    }    public void setBcards(List&lt;Bcard&gt; bcards) {        this.bcards = bcards;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><ol start="2"><li><p>创建并配置对应的mapper映射文件</p><pre><code>&lt;mapper namespace=&quot;com.test.mapper.BuserMapper&quot;&gt;    &lt;resultMap type=&quot;buser&quot; id=&quot;resultUmap&quot;&gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;&lt;!--         &lt;collection property=&quot;uList&quot; ofType=&quot;com.test.domain.Ctou&quot;&gt;            &lt;id column=&quot;c_id&quot; property=&quot;id&quot; /&gt;            &lt;result column=&quot;buserid&quot; property=&quot;buserid&quot; /&gt;            &lt;result column=&quot;bcardid&quot; property=&quot;bcardid&quot; /&gt;        &lt;/collection&gt; --&gt;        &lt;collection property=&quot;bcards&quot; ofType=&quot;com.test.domain.Bcard&quot;&gt;                &lt;id column=&quot;b_id&quot; property=&quot;id&quot; /&gt;                &lt;result column=&quot;money&quot; property=&quot;money&quot; /&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectMtoM&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;resultUmap&quot;&gt;        SELECT buser.*,bcard.id b_id,bcard.money from buser,ctou,bcard        where buser.id=#{value} and buser.id=ctou.buserid and ctou.bcardid=bcard.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li></ol><ol start="3"><li>创建对应接口和方法</li></ol><pre><code>public interface BuserMapper {    public Buser selectMtoM(Integer value) throws Exception;}</code></pre><ol start="4"><li><p>记得在总配置文件里配置</p><pre><code>&lt;typeAliases&gt;    &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;package name=&quot;com.test.domain&quot;/&gt;&lt;/typeAliases&gt;&lt;mappers&gt;    &lt;!-- &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; --&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;     &lt;package name=&quot;com.test.mapper&quot;/&gt;&lt;/mappers&gt;</code></pre></li><li><p>测试</p><pre><code>Buser buser=buserMapper.selectMtoM(111);System.out.println(buser.getName());for (Bcard bcard : buser.getBcards()) {    System.out.println(bcard.getId()+&quot; &quot;+bcard.getMoney());}</code></pre></li></ol><ol start="6"><li>结果输出：<br>胡歌<br>1002 0<br>1003 10000</li></ol><hr><p>反过来从bcard来查buser也一样的步骤。</p><p>over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;关于多对多关系，我看了很多网上的案例和讲解，觉得都说的不太清楚，决定自己结合之前学的hibernate多对多关系，自己写一篇有关的mybatis多对多关系总结。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先，创建表，建立连接关系。&lt;/stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】学习总结(二)</title>
    <link href="http://xfff.xyz/2018/10/15/%E3%80%90mybatis%E3%80%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>http://xfff.xyz/2018/10/15/【mybatis】学习总结(二)/</id>
    <published>2018-10-15T07:38:30.030Z</published>
    <updated>2018-10-17T15:37:35.815Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="动态Sql"><a href="#动态Sql" class="headerlink" title="动态Sql"></a>动态Sql</h2><p>mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。</p><ul><li><strong>if语句</strong></li></ul><p>在mapper映射文件中可以使用\<if>标签来对语句接收的参数进行判断，从而动态改变sql语句。</if></p><p>为了避免多次遇到同一段判断代码时的累赘，可以使用<strong>SQL片段</strong>来重复利用代码。<br>如下：</p><pre><code>&lt;sql id=&quot;thereissqlblock&quot;&gt;        &lt;if test=&quot;goods!=null and user!=null&quot;&gt;            &lt;if test=&quot;user.name!=null and user.name!=&apos;&apos; &quot;&gt;                AND user.password=#{goods.price}            &lt;/if&gt;        &lt;/if&gt;&lt;/sql&gt;&lt;select id=&quot;selectUseIf&quot; parameterType=&quot;userQuery&quot; resultType=&quot;user&quot;&gt;    SELECT * FROM USER    &lt;where&gt;        &lt;include refid=&quot;thereissqlblock&quot;&gt;&lt;/include&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><p><strong>具体分析：</strong><br>if标签\&lt;&gt;里的test判断的是输入的参数的值，而\&lt;&gt;外则是相应的sql语句块（另外，#表示占位符,$为匹配符）。若不符合if test里的条件，则会执行select * from user，及不设置条件会查询出所有记录，若符合，则会把sql片段拼接到原语句。</p><ul><li><strong>foreach语句</strong></li></ul><p>foreach对应sql语句为：</p><pre><code>SELECT * FROM USER WHERE userid=1 OR userid=2 OR userid=3SELECT * FROM USER WHERE userid IN(1,2,3)</code></pre><p>对于多个对象的输入查询，foreach可以解决遍历参数数组的问题。首先在参数对象中定义一个list集合并生成set和get方法，</p><pre><code>private    List&lt;T&gt; list;//set和get方法 </code></pre><p>在mapper参数类型parameterType设置为list存放对象类型，接着：</p><pre><code>&lt;if test=&quot;users!=null&quot;&gt;    &lt;foreach collection=&quot;users&quot; item=&quot;theuser&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;        userid=#{theuser.userid}    &lt;/foreach&gt;&lt;/if&gt;</code></pre><p>使用：</p><pre><code>User user1=new User();User user2=new User();user1.setUserid(1111);user2.setUserid(1112);List&lt;User&gt; users=new ArrayList&lt;&gt;();users.add(user1);users.add(user2);userQuery.setUsers(users);userMapper.selectForeach(userQuery).stream().forEach(System.out::println);</code></pre><p>即可查出id为1111,1112的俩条记录。</p><hr><h2 id="sql的一对一、一对多"><a href="#sql的一对一、一对多" class="headerlink" title="sql的一对一、一对多"></a>sql的一对一、一对多</h2><p>定义表，orders：订单，custom：用户。外键关联<br>一个用户可发起多个订单，一个订单对应一个用户。<br>在对应类里添加属性。<br>orders:private Custom custom；<br>custom:private List\<orders> orders;</orders></p><ul><li><strong>一对一：</strong></li></ul><pre><code>订单对用户为一对一关系，则根据订单查用户有如下几种方法：</code></pre><ol><li><p>创建一个新类继承Orders,在该类里添加custom的属性并生成set和get方法。然后直接使用该类查询即可，实际应用中应该加上一个输入的参数ordersid<del>这里我懒没加</del></p><pre><code>&lt;mapper namespace=&quot;com.me.mapper.OrdersMapper&quot;&gt;    &lt;select id=&quot;findCO&quot; resultType=&quot;customOrders&quot;&gt;        SELECT custom.*,orders.* FROM custom,orders WHERE orders.customid=custom.id    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li>上面方法是在没有设置private Custom custom属性时候用的，所以其实可以直接把resultType改成orders，但得不到custom对象，不会把写在mapper里的custom.*映射到orders里的custom属性。</li><li><p>怎么解决2的问题呢？使用resultMap添加association标签关联即可解决</p><pre><code>&lt;resultMap type=&quot;orders&quot; id=&quot;resultmap1&quot;&gt;    &lt;id column=&quot;orderid&quot; property=&quot;orderid&quot; /&gt;    &lt;result column=&quot;thing&quot; property=&quot;thing&quot;/&gt;    &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;association property=&quot;custom&quot; javaType=&quot;com.me.domain.Custom&quot;&gt;        &lt;id column=&quot;customid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;findCCO&quot; resultMap=&quot;resultmap1&quot;&gt;    SELECT orders.*,custom.* FROM custom,orders WHERE orders.customid=custom.id&lt;/select&gt;</code></pre><p>这里，在resultMap里少添加或者在select后面少写一项属性，得到的对象属性就会少一项属性的值（<del>所以不要偷懒少写属性</del>）。</p></li></ol><hr><ul><li><strong>一对多：</strong></li></ul><p>上面的一对一反过来，问题就变成了一对多，即一个custom对应多个orders。<br>对于一对多关系，我直接介绍最有效率的方法：<br>使用resultMap：</p><pre><code>&lt;resultMap type=&quot;custom&quot; id=&quot;ccus&quot;&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;    &lt;result column=&quot;nowdate&quot; property=&quot;nowdate&quot;/&gt;    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;    &lt;collection property=&quot;orders&quot; ofType=&quot;com.me.domain.Orders&quot;&gt;        &lt;id column=&quot;order_id&quot; property=&quot;orderid&quot;/&gt;        &lt;result column=&quot;thing&quot; property=&quot;thing&quot; /&gt;        &lt;result column=&quot;customid&quot; property=&quot;customid&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectCus&quot; resultMap=&quot;ccus&quot;&gt;    SELECT c.*,o.orderid order_id,o.thing,o.customid FROM custom c,orders o WHERE c.id=o.customid&lt;/select&gt;</code></pre><p>注意这里是collection，执行后会把符合条件的orders一条一条映射到custom的list\<orders>属性。</orders></p><p><strong>注意事项：</strong>如果关联表中有列名和主表列名相同，必须要设置别名，否则查询结果会有问题。</p><blockquote><p><a href="https://blog.csdn.net/xzm_rainbow/article/details/15336933" target="_blank" rel="noopener">具体可以看这里</a></p></blockquote><hr><ul><li><strong>多对多：</strong></li></ul><p><a href="http://xfff.xyz/2018/10/16/%E3%80%90mybatis%E3%80%91%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB/">具体看这篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;动态Sql&quot;&gt;&lt;a href=&quot;#动态Sql&quot; class=&quot;headerlink&quot; title=&quot;动态Sql&quot;&gt;&lt;/a&gt;动态Sql&lt;/h2&gt;&lt;p&gt;mybatis真正强大的地方，是可以灵活的运用sql语句进行查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;stron
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【mybatis】大概总结(一)</title>
    <link href="http://xfff.xyz/2018/10/15/%E3%80%90mybatis%E3%80%91%E5%A4%A7%E6%A6%82%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>http://xfff.xyz/2018/10/15/【mybatis】大概总结(一)/</id>
    <published>2018-10-15T05:41:46.178Z</published>
    <updated>2018-10-17T15:37:06.599Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#c">原生访问数据库方法</a><br><a href="#a">总配置文件</a><br><a href="#mapper">mapper配置</a><br><a href="#mapperj">mapper接口</a><br><a href="#mapperc">使用示例</a></p><hr><p><span id="c"></span></p><h2 id="原生访问数据库方法-jdbc"><a href="#原生访问数据库方法-jdbc" class="headerlink" title="原生访问数据库方法:jdbc"></a>原生访问数据库方法:jdbc</h2><p><strong>jdbc编程步骤:</strong></p><ol><li>加载数据库驱动</li><li>创建并获取数据库链接</li><li>创建jdbc statement对象</li><li>设置sql语句</li><li>设置sql语句中的参数(使用preparedStatement)</li><li>通过statement执行sql并获取结果</li><li>对sql执行结果进行解析处理</li><li>释放资源(resultSet、preparedstatement、connection)</li></ol><p><strong>缺点</strong>：每次对数据库操作时就得建立连接，用完又得释放，非常不方便，且对数据库造成压力较大。不灵活， 程序耦合度高。</p><hr><h1 id="–Mybatis–"><a href="#–Mybatis–" class="headerlink" title="–Mybatis–"></a>–Mybatis–</h1><p>与hibernate类似，mybatis也让表和java类产生映射关系，通过配置映射文件实现。</p><p>可创建相应实体类.xml，并在mybatis配置文件中加载（这里省略这种方法）。</p><p><span id="a"></span></p><h2 id="首先配置mybatis总配置文件SqlMapConfig-xml"><a href="#首先配置mybatis总配置文件SqlMapConfig-xml" class="headerlink" title="首先配置mybatis总配置文件SqlMapConfig.xml"></a>首先配置mybatis总配置文件SqlMapConfig.xml</h2><p><strong>注意事项:</strong></p><ul><li><strong>标签有固定的配置顺序</strong>：<br>properties（属性）<br>settings（全局配置参数）<br>typeAliases（类型别名）<br>typeHandlers（类型处理器）<br>objectFactory（对象工厂）<br>plugins（插件）<br>environments（环境集合属性对象）<br>environment（环境子属性对象）<br>transactionManager（事务管理）<br>dataSource（数据源）<br>mappers（映射器）</li><li><strong>mybatis使用自带的数据库连接池，不支持第三方连接池（网上有添加方法）</strong></li></ul><p><strong>配置建议：</strong></p><ul><li><p><strong>别名配置typeAliases</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.domain&quot;/&gt;</code></pre><p>其中com.me.domain是你要自动配置的包里类的别名（用对应类名配置）</p></li></ul><ul><li><p><strong>mappers映射器配置</strong>：使用批量配置，标签里加入</p><pre><code>&lt;package name=&quot;com.me.mapper&quot;/&gt;</code></pre><p>其中com.me.mapper对应配置的mapper的包名（同上）</p></li></ul><hr><p>示例（只配置了部分配置）:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.me.domain&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.me.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><hr><p><span id="mapper"></span></p><h2 id="mapper映射器配置"><a href="#mapper映射器配置" class="headerlink" title="mapper映射器配置"></a>mapper映射器配置</h2><p><strong>输入映射：</strong><br>resultType指定输入参数类型：</p><ul><li>简单类型(直接使用)</li><li>hashmap(直接使用)</li><li>pojo的包装类型（<strong>常用</strong>）：<br>通过创建一个新的类，在这个类里创建想用来操作的输入参数，并生成set和get方法</li></ul><p><strong>输出映射：</strong></p><ul><li><strong>resultType</strong>：列名与属性名一致才能成功映射<ul><li>输出简单类型</li><li>输出pojo对象和列表</li></ul></li><li><strong>resultMap</strong>：可以定义列的别名，通过别名来映射<ul><li>输出配置的resultMap的id对应的对象</li></ul></li></ul><p>resultMap需要先在mapper里配置resultMap（使用时若要用其他mapper里的resultMap配置，需要在前面加上对应mapper的namespace）示例：</p><pre><code>&lt;!-- 定义resultMap将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系type：resultMap最终映射的java对象类型,可以使用别名id：对resultMap的唯一标识 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;    &lt;!-- id表示查询结果集中唯一标识     column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）    --&gt;    &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;    &lt;!--     result：对普通名映射定义    column：查询出来的列名    property：type指定的pojo类型中的属性名    最终resultMap对column和property作一个映射关系 （对应关系）     --&gt;    &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt; &lt;/resultMap&gt;</code></pre><p>使用示例:</p><pre><code>&lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;    SELECT id id_,username username_ FROM USER WHERE id=#{value}&lt;/select&gt;</code></pre><p>另外在接口中，返回类型写map对应实体类就OK</p><hr><p>Mapper配置示例:</p><pre><code>&lt;!DOCTYPE mapper    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.me.mapper.GoodsMapper&quot;&gt;&lt;resultMap type=&quot;goods&quot; id=&quot;goodsResultMap&quot;&gt;    &lt;id column=&quot;gname_haha&quot; property=&quot;gname&quot; /&gt;    &lt;result column=&quot;price_haha&quot; property=&quot;price&quot; /&gt;&lt;/resultMap&gt;&lt;insert id=&quot;insertGoods&quot; parameterType=&quot;goods&quot;&gt;    INSERT INTO GOODS(gname,price) VALUE(#{gname},#{price})&lt;/insert&gt;&lt;select id=&quot;selectall&quot; resultMap=&quot;goodsResultMap&quot;&gt;    SELECT gname gname_haha,price price_haha FROM goods&lt;/select&gt;</code></pre><p></p><hr><p><span id="mapperj"></span></p><h2 id="Mapper接口："><a href="#Mapper接口：" class="headerlink" title="Mapper接口："></a><strong>Mapper接口：</strong></h2><p>创建mapper.xml映射器对应的接口。<br>在mapper.xml中配置的方法，需要在mapper接口类里配置:<br>其中必须符合以下<strong>四</strong>个规范:</p><ul><li>mapper接口类和映射文件在同一包下</li><li>mapper接口里方法名与映射文件配置id一致</li><li>mapper接口方法参数和映射文件配置参数类型一致</li><li>mapper接口方法返回类型和映射文件配置参数类型一致（可以用list&lt;类&gt;，会自动调用selectlist返回对应对象的list集合）</li></ul><p>示例:</p><pre><code>package com.me.mapper;import java.util.List;import com.me.domain.User;import com.me.domain.UserQuery;public interface UserMapper {    public User findUserById(Integer userid) throws Exception;    public User selectUserQuery(UserQuery userQuery) throws Exception;    public void updateUser(User user) throws Exception;    public List&lt;User&gt; findUserByName(String string) throws Exception;    public List&lt;User&gt; selectUserList(UserQuery userQuery) throws Exception;}</code></pre><hr><p><span id="mapperc"></span></p><h2 id="使用mapper操作数据："><a href="#使用mapper操作数据：" class="headerlink" title="使用mapper操作数据："></a>使用mapper操作数据：</h2><p>示例:</p><pre><code>import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import com.me.domain.Goods;import com.me.domain.User;import com.me.domain.UserQuery;import com.me.mapper.GoodsMapper;import com.me.mapper.UserMapper;public class Tmybati {    SqlSessionFactory sessionFactory;    //这个注解会让这个方法在test方法前执行    @Before    public void a() throws IOException {        String string=&quot;SqlMapConfig.xml&quot;;        InputStream inputStream=Resources.getResourceAsStream(string);        sessionFactory=new SqlSessionFactoryBuilder().build(inputStream);    }    //测试方法    @Test    public void tess() throws Exception {        SqlSession session=sessionFactory.openSession();        UserMapper userMapper=session.getMapper(UserMapper.class);/*                User user2=new User();        user2.setUserid(1111);        Goods goods=new Goods();        goods.setGname(&quot;吴克&quot;);        goods.setPrice(1111);        UserQuery userQuery=new UserQuery();        userQuery.setUser(user2);        userQuery.setGoods(goods);        List&lt;User&gt; users=userMapper.selectUserList(userQuery);        users.stream().forEach(System.out::println);        User user=userMapper.findUserById(1111);        System.out.println(user);*/        Goods dGoods =new Goods();        dGoods.setGname(&quot;吴克5&quot;);        dGoods.setPrice(1111);        GoodsMapper goodsMapper=session.getMapper(GoodsMapper.class);        List&lt;Goods&gt; goods=goodsMapper.selectall();        goods.stream().filter(n-&gt;n.getPrice()==123).forEach(System.out::println);        session.commit();        session.close();    }}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#c&quot;&gt;原生访问数据库方法&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#a&quot;&gt;总配置文件&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapper&quot;&gt;mapper配置&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#mapperj&quot;&gt;mapper接口&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#ma
      
    
    </summary>
    
      <category term="mybatis" scheme="http://xfff.xyz/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://xfff.xyz/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>【ajax】请求服务器+参数双向传递</title>
    <link href="http://xfff.xyz/2018/10/14/%E3%80%90ajax%E3%80%91%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8F%82%E6%95%B0%E5%8F%8C%E5%90%91%E4%BC%A0%E9%80%92/"/>
    <id>http://xfff.xyz/2018/10/14/【ajax】请求服务器-参数双向传递/</id>
    <published>2018-10-13T17:13:37.207Z</published>
    <updated>2018-10-17T15:48:49.290Z</updated>
    
    <content type="html"><![CDATA[<hr><p><strong>Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。</strong></p><hr><p> <strong>1. GET方式</strong></p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;GET&quot;,&quot;ajax!findRecord.action?&quot;+str,true);        xmlhttp.send();    });});</code></pre><p>通过在请求的URL”？”后加参数而达到传参的目的。<br>对于URL尾部的参数，后台action中只要通过request域对象即可取值。</p><pre><code>HttpServletRequest request=ServletActionContext.getRequest();HttpServletResponse response=ServletActionContext.getResponse();response.setContentType(&quot;text/html&quot;);response.setCharacterEncoding(&quot;UTF-8&quot;);Integer cardId=Integer.parseInt(request.getParameter(&quot;cardId&quot;));String date=request.getParameter(&quot;date&quot;);</code></pre><p>struts2里配置为:</p><pre><code>&lt;package name=&quot;actionA&quot; extends=&quot;json-default&quot;&gt;    &lt;global-allowed-methods&gt;regex:.*&lt;/global-allowed-methods&gt;    &lt;action name=&quot;ajax!*&quot; class=&quot;ajaxAction&quot; method=&quot;{1}&quot;&gt;        &lt;result type=&quot;json&quot;&gt;&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;</code></pre><hr><p> <strong>2. —- POST方式</strong><br>    &nbsp;post请求方式相对于get请求方式更加安全（数据信息不会显示在URL中），发送请求能提交的数据也更大。</p><pre><code>$(document).ready(function(){    $(&quot;#btnsub&quot;).click(function(){        var xmlhttp,cardId,date;        cardId=$(&quot;#cardId&quot;).val();        date=$(&quot;#date&quot;).val();        var str=&quot;cardId=&quot;+cardId+&quot;&amp;date=&quot;+date;        if (window.XMLHttpRequest)          {// code for IE7+, Firefox, Chrome, Opera, Safari          xmlhttp=new XMLHttpRequest();          }        else          {// code for IE6, IE5          xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);          }        xmlhttp.onreadystatechange=function()          {          if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)            {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;            }          }        xmlhttp.open(&quot;POST&quot;,&quot;ajax!findRecord.action&quot;,true);        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);        xmlhttp.send(str);    });});</code></pre><p>后台action内获取ajax发送来的数据参数方式同上。</p><hr><hr><h3 id="Ajax-ajax"><a href="#Ajax-ajax" class="headerlink" title="Ajax-ajax()"></a><strong>Ajax-ajax()</strong></h3><p>它是最底层、功能最强大的请求服务器数据方式，它的调用格式为：</p><pre><code>$.ajax([settings]);</code></pre><p>接下来是实际使用:</p><pre><code>$(document).ready(function(){    function doappend(list){        var tbody=&quot;&quot;;        for(i in list){            tbody+=&quot;&lt;tr&gt;&lt;td&gt;&quot;+list[i].userId+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].userName+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].email+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].password+&quot;&lt;/td&gt;&lt;td&gt;&quot;+list[i].cards+&quot;&lt;/td&gt;&lt;td&gt;&lt;a href=\&quot;#\&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=\&quot;#\&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;        }         document.getElementById(&quot;divtable&quot;).innerHTML=tbody;    };    $(&quot;#btnSend&quot;).click(function(){        $(this).attr(&quot;disabled&quot;,true);        var pag=document.getElementById(&quot;thepage&quot;).innerText;        $.ajax({            type:&quot;POST&quot;,            url:&quot;ajax!findall.action&quot;,            data:{&quot;page&quot;:pag},            dataType:&quot;json&quot;,            success:function(data){                var a=eval(&apos;(&apos;+data+&apos;)&apos;);                var am=a.aMap;                var list=am.user;                doappend(list);            }        });    });});</code></pre><p>data:标签对应为发送给服务器后台的数据，必须要使用json格式｛”name”:name,”id”:id｝。type对应请求方式，url为请求的定位，dataType为服务器返回数据的类型，success为成功获取服务器返回数据后可以执行的操作（这里我正在做分页，把页数发送给服务器，服务器查询数据库后返回相应条数的数据）。<br>function里的data为服务器返回的数据，这里是一个hashmap类型，先对data用eval方法进行json格式解析，aMap为当时hashmap设置的name值，在hashmap格式里，key值为‘user’对应的对象，为一个list<user>类型，具体可以看下面的后台代码，然后执行doappend方法，将数据一条一条加入到表格格式里。</user></p><pre><code>private String page;HashMap&lt;String, Object&gt; aMap=new HashMap&lt;String,Object&gt;();public HashMap&lt;String, Object&gt; getaMap() {    return aMap;}public String getPage() {    return page;}public void setPage(String page) {    this.page = page;}public String findall() {    int c=userService.count();    int d;    if(0==c%5) {        d=c/5;    }else {        d=(c/5)+1;    }    aMap.clear();    int p=Integer.parseInt(page);    if(p&lt;1||p&gt;d) {        return NONE;    }else {        int begin=(p-1)*5;        List&lt;User&gt; pList=userService.findPage(begin, 5);        List&lt;UserForAjax&gt; uList=new ArrayList&lt;UserForAjax&gt;();        for (User user : pList) {            StringBuffer sv=new StringBuffer(&quot;&quot;);            for(BankCard bCard:user.getSetBank()) {                sv.append(bCard.getCardId()+&quot; &quot;);            }            String str=sv.toString();            UserForAjax userForAjax=new UserForAjax();            userForAjax.setUserId(user.getUserId());            userForAjax.setEmail(user.getEmail());            userForAjax.setPassword(user.getPassword());            userForAjax.setUserName(user.getUserName());            userForAjax.setCards(str);            uList.add(userForAjax);        }        aMap.put(&quot;user&quot;, uList);        aMap.put(&quot;result&quot;, &quot;success&quot;);        return SUCCESS;    }}</code></pre><p>后台代码中，通过命名一个叫做page的string对象，并生成set和get方法，接收请求后，就能直接得到请求数据中的page对象的值（会调用set方法给this.page赋值），另外创建一个hashmap对象用来存放返回给前端的数据，并生成<strong>get</strong>方法，这样ajax那边才能得到返回的aMap，在方法中给aMap存入需要传递的值。</p><hr><p>一个简单的分页就做好啦!<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw7552c8jpj30x30at74d.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw755vane7j30x80apq30.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Ajax可以对服务器发送异步请求，从而在不刷新整个页面的情况下局部刷新页面。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt; &lt;strong&gt;1. GET方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready(func
      
    
    </summary>
    
      <category term="ajax" scheme="http://xfff.xyz/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://xfff.xyz/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】基础结构实现集合</title>
    <link href="http://xfff.xyz/2018/10/14/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88/"/>
    <id>http://xfff.xyz/2018/10/14/【数据结构】基础结构实现集合/</id>
    <published>2018-10-13T16:24:24.135Z</published>
    <updated>2018-10-17T15:38:38.510Z</updated>
    
    <content type="html"><![CDATA[<p>一些我早期学数据结构的时候用C++实现的代码。<del>指针在实现上比较方便</del></p><hr><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="(1)栈"></a>(1)栈</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int SElemType;typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStack;int InitStack(LinkStack &amp;top){    top = (StackNode*)malloc(sizeof(StackNode));    if(top!=NULL){        top = NULL;    }    return OK;}int Push(LinkStack &amp;top,SElemType e){    LinkStack p =(StackNode*)malloc(sizeof(StackNode));    p-&gt;data=e;    p-&gt;next=top;    top=p;    return OK;}int CreateStack(LinkStack &amp;top){    int n;    cout &lt;&lt; &quot;输入入栈元素个数:&quot;;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++){        int m;        cout&lt;&lt;&quot;输入进栈元素:&quot;;        cin&gt;&gt;m;        Push(top,m);    }    return OK;}int Pop(LinkStack &amp;top,SElemType &amp;e){    LinkStack p;    if(top!=NULL){        p=top;        e = top-&gt;data;        top = top-&gt;next;        free(p);    }    else        return ERROR;    return OK;}int GetTop(LinkStack top,SElemType &amp;e){    if(top!=NULL)        e = top-&gt;data;    else        return ERROR;    return OK;}void outStack(LinkStack top){    while(top!=NULL){        cout&lt;&lt;top-&gt;data&lt;&lt;endl;        top=top-&gt;next;    }}int main(){    LinkStack top;    InitStack(top);    CreateStack(top);    outStack(top);    int e;    cout&lt;&lt;&quot;出栈一次;&quot;;    Pop(top,e);    cout&lt;&lt;&quot;出栈元素:&quot;&lt;&lt;e&lt;&lt;endl;    outStack(top);    GetTop(top,e);    cout&lt;&lt;&quot;栈顶元素为:&quot;&lt;&lt;e&lt;&lt;endl;    return 0;}</code></pre><h2 id="2-静态链表"><a href="#2-静态链表" class="headerlink" title="(2)静态链表"></a>(2)静态链表</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 1000#define OK 1#define ERROR 0#define FALSE 0#define TRUE 1typedef int status;typedef struct{    status data;    int cur;}component,    SLinkList[MAXSIZE];//初始化status InitList(SLinkList space){    int i;    for(i=0;i&lt;MAXSIZE-1;i++)        space[i].cur = i+1;    space[MAXSIZE-1].cur=0;    return OK;}//若备用空间链表非空，返回分配的结点下标int Malloc_SLL(SLinkList space){    int i = space[0].cur;    if(space[0].cur)        space[0].cur = space[i].cur;    return i;}int ListLength(SLinkList sl){    int j=0;    int i=sl[MAXSIZE-1].cur;    while(i){        i=sl[i].cur;        j++;    }    return j;}//插入status ListInsert(SLinkList L,int i,status e){    int j,k,l;    k=MAXSIZE-1;    if(i&lt;1||i&gt;ListLength(L)+1)        return ERROR;    j=Malloc_SLL(L);    if(j){        L[j].data=e;        for(l=1;l&lt;=i-1;l++)            k=L[k].cur;        L[j].cur=L[k].cur;        L[k].cur=j;        return OK;    }    return ERROR;}//回收空闲结点void Free_SSL(SLinkList space,int k){    space[k].cur=space[0].cur;    space[0].cur=k;}//删除status ListDelete(SLinkList L,int i){    int j,k;    if(i&lt;1||i&gt;ListLength(L))        return ERROR;    k = MAXSIZE-1;    for(j=1;j&lt;=i-1;j++)        k=L[k].cur;    j=L[k].cur;    L[k].cur=L[j].cur;    Free_SSL(L,j);    return OK;}int main(){    return 0;}</code></pre><p>(3)链式存储结构表及表间操作</p><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;using namespace std;#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef struct LNode{    Status data;    struct LNode *next;                }LNode ,*LinkList;Status InitList(LinkList &amp;L){    L = (LNode*)malloc(sizeof(LNode));    if(L == NULL)        return ERROR;    L-&gt;next=NULL;    return OK;}Status GetElem(LinkList L,int i,Status *e){    int j;    LinkList p;    p = L-&gt;next;    j = 1;    while(p&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    *e = p-&gt;data;    return OK;}Status ListInsert(LinkList &amp;L,int i,Status e){    int j;    LinkList p,s;    p = L;    j=1;    while( p &amp;&amp; j&lt;i ){        p=p-&gt;next;        ++j;    }    if(!p||j&gt;i)        return ERROR;    s =(LinkList)malloc(sizeof(LNode));    s-&gt;data = e;    s-&gt;next = p-&gt;next;    p-&gt;next = s;      return OK;}Status ListDelete(LinkList &amp;L,int i,Status *e){    int j;    LinkList p,q;    p = L;    j = 1;    while(p-&gt;next&amp;&amp;j&lt;i){        p = p-&gt;next;        ++j;    }    if(!(p-&gt;next)||j&gt;i)        return ERROR;    q=p-&gt;next;    p-&gt;next=q-&gt;next;    *e = q-&gt;data;    free(q);    return OK;}void CreateList(LinkList &amp;L,int n){    LinkList p ;    int i;    srand(time(0));    L-&gt;next=NULL;    for(i=0;i&lt;n;i++){        p=(LinkList) malloc(sizeof(LNode));        p-&gt;data=rand()%100+1;        p-&gt;next=L-&gt;next;        L-&gt;next = p;    }}Status ClearList(LinkList &amp;L){    LinkList p,q;    p=L-&gt;next;    while(p){        q=p-&gt;next;        free(p);        p=q;    }    L-&gt;next=NULL;    return OK;}void unionList(LinkList &amp;L,LinkList L1){    LinkList p;    p=L;    L=p;    while(p-&gt;next){        p = p-&gt;next;    }    p-&gt;next=L1-&gt;next;}void outList(LinkList L){    L=L-&gt;next;    while(L!=NULL){        cout&lt;&lt;L-&gt;data&lt;&lt;&quot; &quot;;        L=L-&gt;next;    }    cout&lt;&lt;endl;}int main(){    LinkList p;    InitList(p);    CreateList(p,4);    outList(p);    cout &lt;&lt; &quot;请输入插入元素位置：&quot;;    int i;    cin&gt;&gt;i;    cout&lt;&lt;&quot;请输入插入元素:&quot;;    int e;    cin&gt;&gt;e;    ListInsert(p,i,e);    outList(p);    cout&lt;&lt;&quot;请输入删除元素位置:&quot;;    int j;    int num;    cin&gt;&gt;j;    ListDelete(p,j,&amp;num);    outList(p);    cout&lt;&lt;&quot;删除元素为:&quot;&lt;&lt;num&lt;&lt;endl;    cout &lt;&lt; &quot;表2:&quot;;    LinkList p1;    InitList(p1);    CreateList(p1,7);    outList(p1);    cout &lt;&lt; &quot;合并得:&quot;&lt;&lt;endl;    unionList(p,p1);    outList(p);    return 0;}</code></pre><h2 id="4-堆实现字符串"><a href="#4-堆实现字符串" class="headerlink" title="(4)堆实现字符串"></a>(4)堆实现字符串</h2><pre><code>//字符串的堆分配表示与实现#include&lt;iostream&gt;using namespace std;#define MAXISIZE 100#define ERROR 0#define OK 1typedef struct string {    char *str;    int length;}HeapString;//初始化串int initString(HeapString &amp;pH){    pH.str =&apos;\0&apos;;    pH.length = 0;    return OK;}//给指定的字符串赋值int strAssign(HeapString &amp;pH,char cstr[]){    int i;    int len;    if(pH.str)        free(pH.str);    for( i = 0;cstr[i]!=&apos;\0&apos;;i++);        len = i;    if(!cstr)    {        pH.length = 0;        pH.str = &apos;\0&apos;;    }    else    {        pH.str = (char * )malloc(len*sizeof(char));        if(!pH.str)        {            return ERROR;        }        for(i = 0;i&lt;len;i++)        {            pH.str[i] = cstr[i];        }        pH.length = len;    }    return OK;}//字符串的插入int strInsert(HeapString &amp;pH,int pos,HeapString S){    int i;    if(pos&lt;1||pos&gt;pH.length+1)        return ERROR;    pH.str = (char *)realloc(pH.str,(pH.length+S.length)*sizeof(char));    if(!pH.str)        return ERROR;    for(i = pH.length-1;i&gt;=pos-1;i--)    {        pH.str[i+S.length] = pH.str[i];    }    for(i = 0;i&lt;S.length;i++)    {        pH.str[i+pos-1]= S.str[i];    }    pH.length = pH.length+ S.length;    return OK;}//字符串的复制int strCopy(HeapString pH,HeapString &amp;T){    int i;    int len = pH.length;    T.str = (char * )malloc(len*sizeof(char));    if(!T.str)    {        return ERROR;    }    for( i = 0;i&lt;pH.length;i++)    {        T.str[i] = pH.str[i];    }    T.length = pH.length;    return OK;}//字符串的输出int outStr(HeapString pH){    int i;    for(i = 0;i&lt;pH.length;i++)    {        cout&lt;&lt;pH.str[i];    }    cout&lt;&lt;endl;    return OK;}int main(){    HeapString pH;    char cstr[MAXISIZE];    initString(pH);    cout&lt;&lt;&quot;请输入一个字符串:&quot;;    gets(cstr);    strAssign(pH,cstr);    cout &lt;&lt; &quot;串1:&quot;;    outStr(pH);    HeapString pH1;    initString(pH1);    strCopy(pH,pH1);    cout &lt;&lt; &quot;串2:&quot;;    outStr(pH1);    int pos;    cout&lt;&lt;&quot;请输入插入位置:&quot;;    cin&gt;&gt;pos;    strInsert(pH,pos,pH1);    cout&lt;&lt;&quot;插入操作后的串1:&quot;;    outStr(pH);    return 0;}</code></pre><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="(5)队列"></a>(5)队列</h2><pre><code>#include&lt;iostream&gt;using namespace std;#define ERROR 0#define OK 1typedef int QElemType;typedef struct QNode{    QElemType data;    struct QNode *next;}QNode,*QueuePtr;typedef struct{    QueuePtr front,rear;}LinkQueue;int InitDL(LinkQueue &amp;Q){    Q.front = Q.rear=(QNode*)malloc(sizeof(QNode));    if(!Q.front)        return ERROR;    Q.front-&gt;next=NULL;    return OK;} int InDL(LinkQueue &amp;Q,QElemType e){    QueuePtr p;    p=(QueuePtr)malloc(sizeof(QNode));    if(!p)        return ERROR;    p-&gt;data=e;    p-&gt;next=NULL;    Q.rear-&gt;next=p;    Q.rear=p;    return OK;}int OutDL(LinkQueue &amp;Q,QElemType &amp;e){    QueuePtr p;    if(Q.front==Q.rear)        return ERROR;    p = Q.front-&gt;next;    e=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)        Q.rear=Q.front;    free(p);    return OK;}int getheadDL(LinkQueue Q,QElemType &amp;e){    e=Q.front-&gt;next-&gt;data;    return OK;}int prinftDL(LinkQueue Q){    QueuePtr p;    p=Q.front-&gt;next;    while(p){        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;  &quot;;        p=p-&gt;next;    }    cout &lt;&lt; endl;    return OK;}int main(){    LinkQueue Q;    InitDL(Q);    int m,n,e;    cout&lt;&lt;&quot;输入进队元素个数:&quot;;    cin&gt;&gt;m;    for(int i=0;i&lt;m;i++){        cout &lt;&lt; &quot;输入入队元素:&quot;;        cin&gt;&gt;n;        InDL(Q,n);    }    prinftDL(Q);    getheadDL(Q,e);    cout &lt;&lt; &quot;队头元素为:&quot;&lt;&lt;e&lt;&lt;endl;    OutDL(Q,e);        cout &lt;&lt; &quot;出队一次，出队元素为:&quot;&lt;&lt;e&lt;&lt;endl;    prinftDL(Q);    return 0;}</code></pre><p>循环队列:</p><pre><code>#include&lt;iostream&gt;using namespace std;#define MAXSIZE 5#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int QElemType;typedef struct{    QElemType data[MAXSIZE];    int front;    int rear;}SqQueue;//初始化int InitQueue(SqQueue *Q){    Q-&gt;front=0;    Q-&gt;rear=0;    return OK;}//返回长度int QueueLength(SqQueue Q){    return (Q.rear-Q.front+MAXSIZE)%MAXSIZE;}//插入元素e到队尾int EnQueue(SqQueue *Q,QElemType e){    if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)        return ERROR;    Q-&gt;data[Q-&gt;rear]=e;    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;    return OK;}//若队列不空，则删除队头元素，用e返回其值int DeQueue(SqQueue *Q,QElemType *e){    if(Q-&gt;front==Q-&gt;rear)        return ERROR;    *e=Q-&gt;data[Q-&gt;front];    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;    return OK;}//输出队列void outQueue(SqQueue Q){    int j = (Q.rear-1+MAXSIZE)%MAXSIZE;    for(int i=0;i&lt;QueueLength(Q);i++){        cout &lt;&lt; (Q.data[j])&lt;&lt;&quot; &quot;;        j=((--j) + MAXSIZE)%MAXSIZE;    }    cout &lt;&lt; endl;}int main(){    SqQueue sq;    InitQueue(&amp;sq);    int a;    int count;    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int i=0;i&lt;count;i++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    int e;    int num;    cout &lt;&lt; &quot;删除元素个数:&quot;;    cin &gt;&gt; num;    for(int n=0;n&lt;num;n++){        DeQueue(&amp;sq,&amp;e);        cout &lt;&lt; &quot;删除元素:&quot;&lt;&lt; e &lt;&lt; endl;            }    outQueue(sq);    cout&lt;&lt;&quot;输入插入元素个数:&quot;;    cin&gt;&gt;count;    for(int m=0;m&lt;count;m++){        cout &lt;&lt; &quot;输入插入元素:&quot;;        cin&gt;&gt;a;        EnQueue(&amp;sq,a);            }    outQueue(sq);    cout &lt;&lt; &quot;队列长度:&quot; &lt;&lt; QueueLength(sq) &lt;&lt;endl;    return 0;}</code></pre><h2 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="(6)二叉树"></a>(6)二叉树</h2><pre><code>#include&lt;iostream&gt;#include&lt;stdlib.h&gt;using namespace std;#define TRUE 1#define FALSE 0typedef struct BiTNode{    int data;    struct BiTNode *lchild,*rchild;}BiTNode,*BiTree;int SearchBST(BiTree T,int key,BiTree f,BiTree &amp;p){    if(T==NULL){        p = f;        return FALSE;    }    else if(key == T-&gt;data){        p=T;        return TRUE;    }    else if(key&lt;T-&gt;data)        return SearchBST(T-&gt;lchild,key,T,p);    else         return SearchBST(T-&gt;rchild,key,T,p);}int InsertBST(BiTree &amp;T,int key){    BiTree p,s;    if(!SearchBST(T,key,NULL,p))    {        s = (BiTree)malloc(sizeof(BiTree));        s-&gt;data=key;        s-&gt;lchild=s-&gt;rchild=NULL;        if(!p)            T=s;        else if(key&lt;p-&gt;data)            p-&gt;lchild=s;        else            p-&gt;rchild=s;        return TRUE;    }    else        return FALSE;}int Delete(BiTree *p){    BiTree q,s;    if((*p)-&gt;lchild==NULL&amp;&amp;(*p)-&gt;rchild==NULL)        *p=NULL;    else if((*p)-&gt;rchild==NULL){        q=(*p);        (*p)=(*p)-&gt;lchild;        free(q);    }    else if((*p)-&gt;lchild==NULL){        q=(*p);        (*p)=(*p)-&gt;rchild;        free(q);    }    else{        q=(*p);        s=(*p)-&gt;lchild;        while(s-&gt;rchild!=NULL){            q=s;            s=s-&gt;rchild;        }        (*p)-&gt;data=s-&gt;data;        if(!s-&gt;lchild){            if(q!=(*p))                (q)-&gt;rchild=s-&gt;lchild;            else                (q)-&gt;lchild=s-&gt;lchild;            }        free(s);    }    return TRUE;}int DeleteBST(BiTree *T,int key){    if(!*T)        return FALSE;    else{        if(key==(*T)-&gt;data)            return Delete(T);        else if(key&lt;(*T)-&gt;data)            return DeleteBST(&amp;(*T)-&gt;lchild,key);        else            return DeleteBST(&amp;(*T)-&gt;rchild,key);    }}int CreateBST(BiTree &amp;T){    int n;    cout &lt;&lt; &quot;输入树的结点个数:&quot;;    cin&gt;&gt;n;    T=NULL;    for(int i=0;i&lt;n;i++){        int m;        cout &lt;&lt; &quot;输入元素:&quot;;        cin&gt;&gt;m;        InsertBST(T,m);    }    return TRUE;}int main(){    BiTree T;    CreateBST(T);    BiTree f=NULL;    BiTree    p;    int key;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key;    if(SearchBST(T,key,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    int key1;    cout&lt;&lt;&quot;请输入删除元素:&quot;;    cin&gt;&gt;key1;    DeleteBST(&amp;T,key1);    int key2;    cout &lt;&lt; &quot;请输入查找元素:&quot;;    cin&gt;&gt;key2;    if(SearchBST(T,key2,f,p)){        cout&lt;&lt;&quot;查找成功&quot;&lt;&lt;endl;    }    else        cout&lt;&lt;&quot;未查到此数。&quot;&lt;&lt;endl;    return 0;}</code></pre><h2 id="7-图"><a href="#7-图" class="headerlink" title="(7)图"></a>(7)图</h2><pre><code>#include&lt;iostream&gt;#include &quot;DL.h&quot;using namespace std;#define ERROR 0#define OK 1#define MAXVEX 100#define INFINITY 65535typedef int Boolean;Boolean visited[MAXVEX];typedef char VertexType;typedef int EdgeType;//邻接矩阵typedef struct{    VertexType vexs[MAXVEX];    EdgeType arc[MAXVEX][MAXVEX];    int numVertexes,numEdges;}MGraph;void CreateMGraph(MGraph *G){    int i,j,k,w;    cout&lt;&lt;&quot;输入顶点数和边数:\n&quot;;    cin&gt;&gt;G-&gt;numVertexes;    cin&gt;&gt;G-&gt;numEdges;    for(i=0;i&lt;G-&gt;numVertexes;i++){        cout &lt;&lt; &quot;输入顶点:&quot;;        cin&gt;&gt;G-&gt;vexs[i];    }    for(i=0;i&lt;G-&gt;numVertexes;i++){        for(j=0;j&lt;G-&gt;numVertexes;j++){            G-&gt;arc[i][j]=INFINITY;        }    }    for(k=0;k&lt;G-&gt;numEdges;k++){        cout&lt;&lt;&quot;输入边（vi,vj）上的下标i，下标j和权w:&quot;&lt;&lt;endl;        cin&gt;&gt;i;        cin&gt;&gt;j;        cin&gt;&gt;w;        G-&gt;arc[i][j]=w;        G-&gt;arc[j][i]=G-&gt;arc[i][j];    }}//深度优先void DFS(MGraph G,int i){    int j;    visited[i]=1;    cout&lt;&lt;G.vexs[i];    for(j=0;j&lt;G.numVertexes;j++)        if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j])            DFS(G,j);}void DFSTraverse(MGraph G){    int i;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    for(i=0;i&lt;G.numVertexes;i++)        if(!visited[i])            DFS(G,i);}//广度遍历void BFSTraverse(MGraph G){    int i,j;    LinkQueue Q;    for(i=0;i&lt;G.numVertexes;i++)        visited[i]=0;    InitDL(Q);    for(i=0;i&lt;G.numVertexes;i++){        if(!visited[i]){            visited[i]=1;            cout&lt;&lt;G.vexs[i];            InDL(Q,i);            while(!DLEmpty(Q)){                OutDL(Q,i);                for(j=0;j&lt;G.numVertexes;j++){                    if(G.arc[i][j]!=INFINITY&amp;&amp;!visited[j]){                        visited[j]=1;                        cout &lt;&lt;G.vexs[j];                        OutDL(Q,j);                    }                }            }        }    }}//普里姆算法void MiniSpanTree_Prim(MGraph G){    int min,i,j,k;    int adjvex[MAXVEX];    int lowcost[MAXVEX];    lowcost[0]=0;    adjvex[0]=0;    for(i=1;i&lt;G.numVertexes;i++){        lowcost[i]=G.arc[0][i];        adjvex[i]=0;    }    for(i=1;i&lt;G.numVertexes;i++){        min = INFINITY;        j=1;        k=0;        while(j&lt;G.numVertexes){            if(lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min){                min = lowcost[j];                k=j;            }            j++;        }        cout&lt;&lt;&quot;(&quot;&lt;&lt;adjvex[k]&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;)&quot;;        lowcost[k]=0;        for(j=1;j&lt;G.numVertexes;j++){            if(lowcost[j]!=0&amp;&amp;G.arc[k][j]&lt;lowcost[j]){                lowcost[j]=G.arc[k][j];                adjvex[j]=k;            }        }    }}int main(){    MGraph G;    CreateMGraph(&amp;G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;深度遍历&quot;&lt;&lt;endl;    DFSTraverse(G);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;广度遍历&quot;&lt;&lt;endl;    BFSTraverse(G);     cout &lt;&lt; endl;    MiniSpanTree_Prim(G);    return 0;}</code></pre><hr><p>这些结构里也包含它们对应的遍历、插入、删除算法（<del>有些还未经优化</del>）….<br>当然这里还漏了很多基本结构类型，之后再补吧。<br>….</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些我早期学数据结构的时候用C++实现的代码。&lt;del&gt;指针在实现上比较方便&lt;/del&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-栈&quot;&gt;&lt;a href=&quot;#1-栈&quot; class=&quot;headerlink&quot; title=&quot;(1)栈&quot;&gt;&lt;/a&gt;(1)栈&lt;/h2&gt;&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xfff.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://xfff.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【JAVA8新特性】</title>
    <link href="http://xfff.xyz/2018/10/13/%E3%80%90JAVA8%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/13/【JAVA8新特性】/</id>
    <published>2018-10-13T06:35:59.026Z</published>
    <updated>2018-10-18T03:32:58.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Lambda表达式"><a href="#一-Lambda表达式" class="headerlink" title="(一)Lambda表达式"></a>(一)Lambda表达式</h2><p>java8新特性支持lambda表达式，能让代码看起来更简洁。</p><pre><code>interface Aaa{public void printz(String z);}//老版本    String t=&quot;gggg&quot;;    Aaa olda=new Aaa() {        @Override        public void printz(String z) {            // TODO Auto-generated method stub            System.out.println(z);        }    };    olda.printz(t);    //JAVA 8    //变量t在只后不得更改值，否则会报错，Local variable t defined in an enclosing    //scope must be final or effectively final    //lambda表达式内部只能调用final修饰的变量    Aaa zAaa=((String z)-&gt;System.out.println(z+&quot;qq&quot;+t));    zAaa.printz(t);    //老版本    Runnable oldrunnable=new Runnable() {        @Override        public void run() {            // TODO Auto-generated method stub            System.out.println(&quot;helloWorld&quot;);        }    };    new Thread(oldrunnable).start();    //java 8    new Thread(()-&gt;System.out.print(&quot;helloWorld8&quot;)).start();</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6ltopgbuj303k01q0hu.jpg" alt=""></p><h2 id="（二）方法引用"><a href="#（二）方法引用" class="headerlink" title="（二）方法引用"></a>（二）方法引用</h2><pre><code>      List&lt;Name&gt; names = new ArrayList&lt;Name&gt;();      names.add(new Name(&quot;Bob&quot;));      names.add(new Name(&quot;JECK&quot;));      names.add(new Name(&quot;AICE&quot;));      names.add(new Name(&quot;SENCE&quot;));      names.add(new Name(&quot;MONTE&quot;));      names.forEach(Name::printz);}class Name{    private String name;    public Name(String name) {        this.name=name;    }    public void printz() {        System.out.println(name);    }}`</code></pre><p>输出<br>Bob<br>JECK<br>AICE<br>SENCE<br>MONTE</p><h2 id="（三）函数式接口"><a href="#（三）函数式接口" class="headerlink" title="（三）函数式接口"></a>（三）函数式接口</h2><p>java8新提供了很多函数式接口，具体自行搜索，这里用其中一种做例子。</p><pre><code>    public static void method1(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate) {    for (Integer integer : list) {        if(predicate.test(integer)) {            System.out.print(integer+&quot; &quot;);        }    }}    List&lt;Integer&gt; nIntegers=Arrays.asList(1,2,3,4,5,6,7,8,9,10);    //如何获取list里大于5的元素呢？    //老方法    for (Integer integer : nIntegers) {        if(integer&gt;5) {            System.out.print(integer+&quot; &quot;);        }    }    System.out.println();    //运用java8提供的函数接口    method1(nIntegers, n-&gt;n&gt;5);    System.out.println();    //运用java8新特性省略方法，更简洁    nIntegers.stream().filter(n-&gt;n&gt;5).forEach(System.out::print);</code></pre><p>结果<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6nh9r48ij303p01h0gw.jpg" alt=""></p><h2 id="（四）默认方法"><a href="#（四）默认方法" class="headerlink" title="（四）默认方法"></a>（四）默认方法</h2><p>Java 8 新增了接口的默认方法。</p><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</p><p>我们只需在方法名前面加个default关键字即可实现默认方法<br>    为了解决接口的修改与现有的实现不兼容的问题。</p><pre><code>public class Java8Test {@Testpublic void test() {    System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date()));    CarS car=new CarS();    car.ss();}public interface Car{default void haha() {    System.out.println(&quot;haha&quot;);}}public interface Bus{default void haha() {    System.out.println(&quot;heihei&quot;);}}public class CarS implements Car,Bus{public void ss() {    haha();}@Overridepublic void haha() {    // TODO Auto-generated method stub    Bus.super.haha();    Car.super.haha();}}}</code></pre><h2 id="（五）Stream"><a href="#（五）Stream" class="headerlink" title="（五）Stream"></a>（五）Stream</h2><p>java8引入一种新的抽象称做流Stream，能以声明的方式来处理数据。</p><p>下面代码实现了随机产生10个数，并把大于0的数输出。</p><pre><code>Random random=new Random();random.ints().limit(10).filter(n-&gt;n&gt;0).forEach(System.out::println);</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teiaq9ij305j01g0mq.jpg" alt=""></h2><p>下面代码对list里的字符串重复拼接输出到5条记录的数组里，并输出数组。            </p><pre><code>List&lt;String&gt; sList=Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;);System.out.println(sList.stream().map(n-&gt;n+n).limit(5).collect(Collectors.toList()));</code></pre><p><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw6teszddcj306w00m0cp.jpg" alt=""></p><p>另外，parallelStream()相对于stream()，是流并行处理方式。<br>统计结果的收集器</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);                 IntSummaryStatistics  stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum());System.out.println(&quot;平均数 : &quot; + stats.getAverage());</code></pre><h2 id="（六）Optional类"><a href="#（六）Optional类" class="headerlink" title="（六）Optional类"></a>（六）Optional类</h2><p>一个可以存放null的容器，解决了nullpoint空指针问题。</p><pre><code>    Integer value1 = null;Integer value2 = 222;Optional&lt;Integer&gt; a = Optional.ofNullable(value1);  // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerExceptionOptional&lt;Integer&gt; b = Optional.of(value2);System.out.println(a.orElse(555));System.out.println(b.get());</code></pre><p>输出555<br>222<br>其中a.orElse为如果为空值则取555，b若为空则抛出异常。</p><h2 id="（七）Nashorn-JavaScript"><a href="#（七）Nashorn-JavaScript" class="headerlink" title="（七）Nashorn JavaScript"></a>（七）Nashorn JavaScript</h2><p>Nashorn 一个 javascript 引擎。</p><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p><p>实现了java和JavaScript互相调用。</p><pre><code>ScriptEngineManager  scriptEngineManager = new  ScriptEngineManager(); ScriptEngine  nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); String  name = &quot;Runoob&quot;; Integer  result = null; try  {  nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;); result = (Integer)   nashorn.eval(&quot;10 + 2&quot;);  }catch(ScriptException  e){   System.out.println(&quot;执行脚本错误: &quot;+ e.getMessage());    }     System.out.println(result.toString());</code></pre><p>输出Runoob  12</p><pre><code>var  BigDecimal  =  Java.type(&apos;java.math.BigDecimal&apos;); function calculate(amount, percentage)  { var result =  new  BigDecimal(amount).multiply(  new  BigDecimal(percentage)).divide(new  BigDecimal(&quot;100&quot;),  2,  BigDecimal.ROUND_HALF_EVEN);return result.toPlainString();  }  var result = calculate(568000000000000000023,13.9);  print(result);</code></pre><p>命令行运行上诉程序 : jjs xxx.js<br>结果：78952000000000002017.94</p><h2 id="（八）日期时间API"><a href="#（八）日期时间API" class="headerlink" title="（八）日期时间API"></a>（八）日期时间API</h2><p>旧版java中，日期时间相关的类存在诸多问题：<strong>非线程安全</strong>、<strong>设计差</strong>（java.util和java.sql中日期类名相同，但对应内容不一致，前者多了具体时间）、<strong>时区处理麻烦</strong>。</p><p>java8在java.time包里引入了很多新的API：local、 zoned….</p><pre><code>    // 获取当前的日期时间LocalDateTime currentTime = LocalDateTime.now();System.out.println(&quot;LocalDateTime.now: &quot; + currentTime);LocalDate date1 = currentTime.toLocalDate();System.out.println(&quot;localdatetime.tolocaldate=localdate: &quot; + date1);Month month = currentTime.getMonth();int day = currentTime.getDayOfMonth();int seconds = currentTime.getSecond();System.out.println(&quot;localdatetime.getmonth=month: &quot; + month +&quot;, localdatetime.getdayofmonth=int: &quot; + day +&quot;, localdatetime.getseconds=int: &quot; + seconds);//用当前时间，修改天数和年份LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);System.out.println(&quot;date2: &quot; + date2);//设置一个日期对象的值LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);System.out.println(&quot;date3: &quot; + date3);//设置时间的值LocalTime date4 = LocalTime.of(22, 15);System.out.println(&quot;date4: &quot; + date4);//用另一种格式设置时间LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);System.out.println(&quot;date5: &quot; + date5);</code></pre><p>输出：LocalDateTime.now: 2018-10-13T20:14:29.390<br>localdatetime.tolocaldate=localdate: 2018-10-13<br>localdatetime.getmonth=month: OCTOBER, localdatetime.getdayofmonth=int: 13, localdatetime.getseconds=int: 29<br>date2: 2012-10-10T20:14:29.390<br>date3: 2014-12-12<br>date4: 22:15<br>date5: 20:15:30</p><p><strong>时区相关:</strong></p><pre><code>    ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);System.out.println(&quot;date1: &quot; + date1);ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);System.out.println(&quot;ZoneId: &quot; + id);ZoneId currentZone = ZoneId.systemDefault();System.out.println(&quot;当期时区: &quot; + currentZone);ZonedDateTime dateTime=ZonedDateTime.now(currentZone);System.out.println(&quot;当前时区时间:&quot;+dateTime);</code></pre><p>输出：<br>date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]<br>ZoneId: Europe/Paris<br>当期时区: Asia/Shanghai<br>当前时区时间:2018-10-13T20:20:45.466+08:00[Asia/Shanghai]</p><hr><p>时间相关的计算:计算上个月的今天是周几?</p><pre><code>LocalDateTime currentTime = LocalDateTime.now();currentTime=currentTime.withMonth(currentTime.getMonthValue()-1);System.out.println(currentTime.getDayOfWeek());</code></pre><p>结果:THURSDAY</p><h2 id="（九）Base64"><a href="#（九）Base64" class="headerlink" title="（九）Base64"></a>（九）Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器。</p><pre><code>   try {   // 使用基本编码   String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 比那么字符串 (基本) :&quot; + base64encodedString);   // 解码   byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);   System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));   base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));   System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);   StringBuilder stringBuilder = new StringBuilder();   for (int i = 0; i &lt; 10; ++i) {      stringBuilder.append(UUID.randomUUID().toString());   }   byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);   String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);   System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);   byte[] aString=Base64.getMimeDecoder().decode(mimeEncodedString);   String aString2=new String(aString,&quot;utf-8&quot;);   System.out.println(aString2);}catch(UnsupportedEncodingException e){   System.out.println(&quot;Error :&quot; + e.getMessage());}</code></pre><p>结果:<br>Base64 比那么字符串 (基本) :cnVub29iP2phdmE4<br>原始字符串: runoob?java8<br>Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=<br>Base64 编码字符串 (MIME) :ZDEzM2E2MGEtNTllMS00ZGI5LWE5OWItNDFkNWMwZWU4ZWRlNzVkMmM5NTctMjFmNi00NTM3LWE2<br>NjQtMTUwNmJkOGU0ZWZjNDk0YjEyMTctM2RhZi00NDQ0LTgzNGItYzE0ZWFiY2ZhZWUxYzUxYjNj<br>N2MtMjQ0My00Y2UwLTlhZWItNjE0M2EzZDUzNmQ5OGNjMTgxZTgtMjg3MS00ZDY0LTg0MDktZTgw<br>MGE2OTNlZDdiM2QyOTBiNmQtYTUyYi00NzY3LWFjZmYtMWM0ODRiOGNmNGQzZjhkZjQ0MDItOWMw<br>Ni00YjMzLWEyZGUtZDcxYzc4N2NiZjBkMzQ2ZTY1OWQtMjU1OS00ZDVjLWE3ZjktMDQyMWNmYmY4<br>MjVlMmNhMDhkZGItMDU5OC00Yjk1LTg2ZjktNTdmYWRjZDBjMDBiOWYyYmMzYWMtZDAwNi00ZThk<br>LTlhNjQtNTU3OTcxODk1NjZi<br>d133a60a-59e1-4db9-a99b-41d5c0ee8ede75d2c957-21f6-4537-a664-1506bd8e4efc494b1217-3daf-4444-834b-c14eabcfaee1c51b3c7c-2443-4ce0-9aeb-6143a3d536d98cc181e8-2871-4d64-8409-e800a693ed7b3d290b6d-a52b-4767-acff-1c484b8cf4d3f8df4402-9c06-4b33-a2de-d71c787cbf0d346e659d-2559-4d5c-a7f9-0421cfbf825e2ca08ddb-0598-4b95-86f9-57fadcd0c00b9f2bc3ac-d006-4e8d-9a64-55797189566b</p><hr><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2><p>Over~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Lambda表达式&quot;&gt;&lt;a href=&quot;#一-Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;(一)Lambda表达式&quot;&gt;&lt;/a&gt;(一)Lambda表达式&lt;/h2&gt;&lt;p&gt;java8新特性支持lambda表达式，能让代码看起来更简洁。&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://xfff.xyz/categories/java/"/>
    
    
      <category term="java8" scheme="http://xfff.xyz/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>【springmvc】工作流程理解（一）</title>
    <link href="http://xfff.xyz/2018/10/11/%E3%80%90springmvc%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%90%86%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xfff.xyz/2018/10/11/【springmvc】工作流程理解（一）/</id>
    <published>2018-10-11T06:52:21.451Z</published>
    <updated>2018-10-17T15:38:01.179Z</updated>
    
    <content type="html"><![CDATA[<ol><li>用户通过URL发送请求，到达<strong>DispatcherServlet-前端(核心)控制器</strong>(通过在web.xml中配置)</li><li><strong>DispatcherServlet</strong>把请求转发给<strong>HandlerMapper-处理器映射器</strong>（在springmvc配置文件中注册）</li><li><strong>HandlerMapper</strong>根据请求返回映射的<strong>controller控制器对象链</strong>给<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>把<strong>controller</strong>对象处理链转发给<strong>HandlerAdapter处理器适配器（在springmvc配置文件中注册）</strong></li><li><strong>HandlerAdapter</strong>根据请求通知<strong>controller处理器</strong>应该实现的方法（配置扫描、注解）</li><li><strong>controller</strong>调用对应的方法，返回<strong>ModelAndView</strong>对象（配置注解）</li><li>经<strong>HandlerAdapter</strong>又发送回<strong>DispatcherServlet</strong></li><li><strong>DispatcherServlet</strong>将<strong>ModelAndView</strong>对象发送给<strong>ViewResolver</strong>视图解析器（在springmvc配置文件中配置）</li><li><strong>ViewResolver</strong>对传来的<strong>Model</strong>（数据..）和<strong>View</strong>（对应的页面..）进行渲染返回给<strong>DispatcherServlet</strong></li><li><strong>Response</strong> 响应给用户</li></ol><hr><p>上诉为自己总结，可能有些错误，是我初学理解不够深刻。</p><hr><p><strong><em>网图:</em></strong><br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw4bmgbq81j30pj09h75h.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;用户通过URL发送请求，到达&lt;strong&gt;DispatcherServlet-前端(核心)控制器&lt;/strong&gt;(通过在web.xml中配置)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;把请求转发给&lt;strong&gt;
      
    
    </summary>
    
      <category term="springmvc" scheme="http://xfff.xyz/categories/springmvc/"/>
    
    
      <category term="springmvc" scheme="http://xfff.xyz/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>【好用的工具合集】</title>
    <link href="http://xfff.xyz/2018/10/10/%E3%80%90%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/10/【好用的工具合集】/</id>
    <published>2018-10-10T15:15:28.314Z</published>
    <updated>2018-10-17T15:38:22.268Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="项目开发类："><a href="#项目开发类：" class="headerlink" title="项目开发类："></a>项目开发类：</h2><ul><li><a href="https://www.cnblogs.com/xdp-gacl/p/4233289.html" target="_blank" rel="noopener">maven &gt;&gt;struts项目示例及插件</a></li><li><a href="#">git</a></li><li><a href="http://www.w3school.com.cn/tiy/t.asp?f=ajax_xml" target="_blank" rel="noopener">ajax普通请求示例</a></li><li><a href="https://blog.csdn.net/thinkscape/article/details/7467153" target="_blank" rel="noopener">ajax规范请求示例</a></li></ul><hr><h2 id="图形设计类"><a href="#图形设计类" class="headerlink" title="图形设计类:"></a>图形设计类:</h2><ul><li><a href="https://www.runoob.com/try/bootstrap/layoutit/#" target="_blank" rel="noopener">bootstrapHtml简易设计工具</a></li><li><a href="http://color.oulu.me/" target="_blank" rel="noopener">颜色渐变</a></li><li><a href="https://pan.baidu.com/s/1eQiXZKu" target="_blank" rel="noopener">截图工具FastStone Capture</a></li></ul><hr><h2 id="github-page："><a href="#github-page：" class="headerlink" title="github page："></a>github page：</h2><ul><li><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">hexo</a>+<a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">hexo</a></li></ul><hr><h2 id="Markdown设计："><a href="#Markdown设计：" class="headerlink" title="Markdown设计："></a>Markdown设计：</h2><ul><li><a href="https://stackedit.io/app#" target="_blank" rel="noopener">Stackedit编辑器</a></li><li><a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf" target="_blank" rel="noopener">图床-用来插入图片</a></li></ul><hr><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具:"></a>其他工具:</h2><ul><li><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴 Tampermonkey</a>+<a href="https://greasyfork.org/zh-CN/scripts" target="_blank" rel="noopener">脚本资源</a></li><li><a href="https://chrome.google.com/webstore/detail/isearch/jmalocgcmlilelcdekhigpadlhfbjpnp" target="_blank" rel="noopener">搜索引擎相关</a></li><li><a href="https://blog.csdn.net/wanwuguicang/article/details/80716178" target="_blank" rel="noopener">chrome插件伴侣</a></li><li><a href="https://pan.baidu.com/s/1XII8zxn5HAAcW2-4dLWGAg" target="_blank" rel="noopener">google学术搜索</a><br><del>这样就能发光了？？</del></li></ul><hr><p>持续更新……..<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3kxn6swfj31hc0u0wgk.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;项目开发类：&quot;&gt;&lt;a href=&quot;#项目开发类：&quot; class=&quot;headerlink&quot; title=&quot;项目开发类：&quot;&gt;&lt;/a&gt;项目开发类：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xdp-gacl/p
      
    
    </summary>
    
      <category term="tools" scheme="http://xfff.xyz/categories/tools/"/>
    
    
      <category term="tools" scheme="http://xfff.xyz/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>【Error集合】</title>
    <link href="http://xfff.xyz/2018/10/10/%E3%80%90Error%E9%9B%86%E5%90%88%E3%80%91/"/>
    <id>http://xfff.xyz/2018/10/10/【Error集合】/</id>
    <published>2018-10-10T14:50:11.441Z</published>
    <updated>2018-10-17T15:39:38.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h2><ul><li><a href="https://www.cnblogs.com/zhaideyou/p/5964509.html" target="_blank" rel="noopener">Struts2配置问题java.lang.ClassNotFoundException:org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</a></li><li><a href="https://blog.csdn.net/li7134600/article/details/78071785" target="_blank" rel="noopener">动态通配符配置Action出错</a>  </li><li><a href="https://blog.csdn.net/T_just_for_tomorrow/article/details/79504049" target="_blank" rel="noopener">动态调用action</a>  </li><li><a href="https://blog.csdn.net/cgy_workman/article/details/40862993" target="_blank" rel="noopener">关于struts2配置struts.devMode问题解释</a>  </li></ul><hr><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li><a href="https://blog.csdn.net/H_anxx/article/details/78983591" target="_blank" rel="noopener">org.springframework.web.context.ContextLoaderListener解决方法</a></li></ul><hr><h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><ul><li><a href="https://blog.csdn.net/u010504064/article/details/47832721" target="_blank" rel="noopener">关于Hibernate一对多关系加载方式fetch配置</a></li></ul><hr><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li><a href="https://zhidao.baidu.com/question/1894863609449400500.html" target="_blank" rel="noopener">JS中字符串与数字进行算术运算eval使用注意</a></li></ul><hr><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li><a href="https://www.cnblogs.com/bsn-huang/p/3933442.html" target="_blank" rel="noopener">githubSSHkey添加</a></li><li><a href="https://www.cnblogs.com/sheldonxu/archive/2012/09/17/2688281.html" target="_blank" rel="noopener">伴随问题</a></li></ul><hr><p>持续更新…….<br><img src="http://ww1.sinaimg.cn/large/006azB5Sly1fw3j95uqblj31hc0u0b29.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Struts2&quot;&gt;&lt;a href=&quot;#Struts2&quot; class=&quot;headerlink&quot; title=&quot;Struts2&quot;&gt;&lt;/a&gt;Struts2&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaideyou/p
      
    
    </summary>
    
      <category term="errors" scheme="http://xfff.xyz/categories/errors/"/>
    
    
      <category term="errors" scheme="http://xfff.xyz/tags/errors/"/>
    
  </entry>
  
  <entry>
    <title>win10使用hexo搭建blog</title>
    <link href="http://xfff.xyz/2018/10/09/win10%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAblog/"/>
    <id>http://xfff.xyz/2018/10/09/win10使用hexo搭建blog/</id>
    <published>2018-10-09T15:49:42.936Z</published>
    <updated>2018-10-17T15:38:58.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="练习搭建ing…"><a href="#练习搭建ing…" class="headerlink" title="练习搭建ing….."></a>练习搭建ing…..</h2><p><strong>从下列各个站点<del>边看边搭</del>…</strong></p><ul><li><a href="https://blog.csdn.net/Hoshea_chx/article/details/78826689" target="_blank" rel="noopener">[用Hexo + github搭建自己的博客 — 再也不用羡慕别人了！]</a></li><li><p><a href="http://blog.sunnyxx.com/2014/02/27/hexo_startup/" target="_blank" rel="noopener">[hexo边搭边记]</a></p><p>最後根目録下面的_config.yml文件里的deploy的type一定要設置為git~~~<br>這個問題是真磨人。。。</p></li></ul><hr><p> 模版TKL来源…</p><ul><li><p><a href="https://github.com/SuperKieran/TKL" target="_blank" rel="noopener">[TKL]</a></p></li><li><p><a href="https://github.com/SuperKieran/hexo-generator-search-zip" target="_blank" rel="noopener">[hexo搜索工具]</a></p></li></ul><hr><p><strong>模版很好看，感谢作者~</strong></p><p><del>其实这篇文章只是为了试试能不能同步到github主页hhh</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;练习搭建ing…&quot;&gt;&lt;a href=&quot;#练习搭建ing…&quot; class=&quot;headerlink&quot; title=&quot;练习搭建ing…..&quot;&gt;&lt;/a&gt;练习搭建ing…..&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;从下列各个站点&lt;del&gt;边看边搭&lt;/del&gt;…&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="hexo主题" scheme="http://xfff.xyz/categories/hexo%E4%B8%BB%E9%A2%98/"/>
    
    
      <category term="hexo" scheme="http://xfff.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://xfff.xyz/2018/10/09/hello-world/"/>
    <id>http://xfff.xyz/2018/10/09/hello-world/</id>
    <published>2018-10-09T13:14:11.965Z</published>
    <updated>2018-10-09T13:14:11.965Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
